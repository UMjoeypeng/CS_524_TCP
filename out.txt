		     \||||||||||||||||||/
		   --- Welcome to Maude ---
		     /||||||||||||||||||\
	     Maude 3.3 built: Mar 21 2023 22:31:13
	     Copyright 1997-2023 SRI International
		   Sun Apr 23 00:53:33 2023
==========================================
frewrite in SEQNO-UNORDERED : (< "Bob" : Receiver | greatestSeqNoRcvd : 0,
    msgsRcvd : nil, sender : "Alice", rcvBuffer : (mts mts), rcvCheck : (false
    false), channel : "C", bufferSize : 2, bufferStart : 1, rcvEOF : false,
    EOFPos : 0 > < "C" : Channel | msgs : Mnil, count : 0 >) < "Alice" : Sender
    | msgsToSend : ("0" "1" "2" EOF), sendBuffer : Mnil, currentSeqNo : 0,
    receiver : "Bob", ackBuffer : (false false), numWordsInBuffer : 0,
    finishSend : false, channel : "C", bufferSize : 2, bufferStart : 0,
    actionCount : 0 > .
*********** rule
rl < O : V:Sender | Atts:AttributeSet, currentSeqNo : 0, ackBuffer : A:[
    BoolList], finishSend : A2:[BoolList], bufferSize : N, bufferStart : A3:[
    Int,FindResult], actionCount : I0 > => < O : V:Sender | Atts:AttributeSet,
    currentSeqNo : 0, ackBuffer : n N true, finishSend : false, bufferSize : N,
    bufferStart : (1 - N), actionCount : (I0 + 1) > [label start] .
O --> "Alice"
V:Sender --> Sender
Atts:AttributeSet --> msgsToSend : ("0" "1" "2" EOF), sendBuffer : Mnil,
    receiver : "Bob", numWordsInBuffer : 0, channel : "C"
A:[BoolList] --> false false
A2:[BoolList] --> false
N --> 2
A3:[Int,FindResult] --> 0
I0 --> 0
< "Alice" : Sender | msgsToSend : ("0" "1" "2" EOF), sendBuffer : Mnil,
    currentSeqNo : 0, receiver : "Bob", ackBuffer : (false false),
    numWordsInBuffer : 0, finishSend : false, channel : "C", bufferSize : 2,
    bufferStart : 0, actionCount : 0 >
--->
< "Alice" : Sender | (msgsToSend : ("0" "1" "2" EOF), sendBuffer : Mnil,
    receiver : "Bob", numWordsInBuffer : 0, channel : "C"), currentSeqNo : 0,
    ackBuffer : n 2 true, finishSend : false, bufferSize : 2, bufferStart : (1
    - 2), actionCount : (0 + 1) >
*********** equation
eq n N:Int true = if N:Int <= 0 then (nil).BoolList else true n N:Int - 1 true
    fi .
N:Int --> 2
n 2 true
--->
if 2 <= 0 then (nil).BoolList else true n 2 - 1 true fi
*********** equation
(built-in equation for symbol _<=_)
2 <= 0
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then (nil).BoolList else true n 2 - 1 true fi
--->
true n 2 - 1 true
*********** equation
(built-in equation for symbol _-_)
2 - 1
--->
1
*********** equation
eq n N:Int true = if N:Int <= 0 then (nil).BoolList else true n N:Int - 1 true
    fi .
N:Int --> 1
n 1 true
--->
if 1 <= 0 then (nil).BoolList else true n 1 - 1 true fi
*********** equation
(built-in equation for symbol _<=_)
1 <= 0
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then (nil).BoolList else true n 1 - 1 true fi
--->
true n 1 - 1 true
*********** equation
(built-in equation for symbol _-_)
1 - 1
--->
0
*********** equation
eq n N:Int true = if N:Int <= 0 then (nil).BoolList else true n N:Int - 1 true
    fi .
N:Int --> 0
n 0 true
--->
if 0 <= 0 then (nil).BoolList else true n 0 - 1 true fi
*********** equation
(built-in equation for symbol _<=_)
0 <= 0
--->
true
*********** equation
(built-in equation for symbol if_then_else_fi)
if true then (nil).BoolList else true n 0 - 1 true fi
--->
(nil).BoolList
*********** equation
(built-in equation for symbol _-_)
1 - 2
--->
-1
*********** equation
(built-in equation for symbol _+_)
0 + 1
--->
1
*********** trial #1
crl < O : V:Receiver | Atts:AttributeSet, bufferSize : N0, bufferStart : I0,
    greatestSeqNoRcvd : N, msgsRcvd : SL, rcvBuffer : SL0, rcvCheck : BL,
    rcvEOF : B0, EOFPos : N1 > => < O : V:Receiver | Atts:AttributeSet,
    bufferSize : N0, bufferStart : (N0 + I0), greatestSeqNoRcvd : (N + N0),
    msgsRcvd : (SL SL0), rcvBuffer : n N0 mts, rcvCheck : n N0 false, rcvEOF :
    B0, EOFPos : N1 > if allTrue(BL) or B0 and lastConsecutiveTrue(BL) >= N1 =
    true [label loadWordsFromBuffer] .
O --> "Bob"
V:Receiver --> Receiver
Atts:AttributeSet --> channel : "C", sender : "Alice"
N0 --> 2
I0 --> 1
N --> 0
SL --> (nil).StringList
SL0 --> mts mts
BL --> false false
B0 --> false
N1 --> 0
*********** solving condition fragment
allTrue(BL) or B0 and lastConsecutiveTrue(BL) >= N1 = true
*********** equation
eq allTrue(B BL) = allTrue(BL) and allTrue(B) .
B --> false
BL --> false
allTrue(false false)
--->
allTrue(false) and allTrue(false)
*********** equation
eq allTrue(B) = B .
B --> false
allTrue(false)
--->
false
*********** equation
eq allTrue(B) = B .
B --> false
allTrue(false)
--->
false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq lastConsecutiveTrue(BL) = if BL == (nil).BoolList or head(BL) == false then
    -1 else 1 + lastConsecutiveTrue(tail(BL)) fi .
BL --> false false
lastConsecutiveTrue(false false)
--->
if false false == (nil).BoolList or head(false false) == false then -1 else 1 +
    lastConsecutiveTrue(tail(false false)) fi
*********** equation
(built-in equation for symbol _==_)
false false == (nil).BoolList
--->
false
*********** equation
eq head(E:Bool L:BoolList) = E:Bool .
E:Bool --> false
L:BoolList --> false
head(false false)
--->
false
*********** equation
(built-in equation for symbol _==_)
false == false
--->
true
*********** equation
eq A:Bool or B = A:Bool and B xor A:Bool xor B .
A:Bool --> false
B --> true
true or false
--->
false and true xor false xor true
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> false
true and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> true
true xor false
--->
true
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> true
true xor false
--->
true
*********** equation
(built-in equation for symbol if_then_else_fi)
if true then -1 else 1 + lastConsecutiveTrue(tail(false false)) fi
--->
-1
*********** equation
(built-in equation for symbol _>=_)
-1 >= 0
--->
false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq A:Bool or B = A:Bool and B xor A:Bool xor B .
A:Bool --> false
B --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** failure for condition fragment
allTrue(BL) or B0 and lastConsecutiveTrue(BL) >= N1 = true
*********** failure #1
*********** trial #2
crl < O : V:Channel | Atts:AttributeSet, msgs : ML, count : N > => (ML[random(
    N) rem size(ML)]) < O : V:Channel | Atts:AttributeSet, msgs : pop(ML,
    random(N) rem size(ML)), count : (N + 1) > if size(ML) > 0 = true [label
    convey-msg] .
O --> "C"
V:Channel --> Channel
Atts:AttributeSet --> (none).AttributeSet
ML --> Mnil
N --> 0
*********** solving condition fragment
size(ML) > 0 = true
*********** equation
eq size(T) = if T == Mnil then 0 else 1 + size(tail(T)) fi .
T --> Mnil
size(Mnil)
--->
if Mnil == Mnil then 0 else 1 + size(tail(Mnil)) fi
*********** equation
(built-in equation for symbol _==_)
Mnil == Mnil
--->
true
*********** equation
(built-in equation for symbol if_then_else_fi)
if true then 0 else 1 + size(tail(Mnil)) fi
--->
0
*********** equation
(built-in equation for symbol _>_)
0 > 0
--->
false
*********** failure for condition fragment
size(ML) > 0 = true
*********** failure #2
*********** trial #3
crl < O : V:Sender | Atts:AttributeSet, sendBuffer : ML, numWordsInBuffer : N',
    finishSend : B, bufferSize : N0, actionCount : I0 > < O' : V2:Channel |
    Atts2:AttributeSet, msgs : ML0, count : N > => < O : V:Sender |
    Atts:AttributeSet, sendBuffer : Mnil, numWordsInBuffer : 0, finishSend : B,
    bufferSize : N0, actionCount : (I0 + 1) > < O' : V2:Channel |
    Atts2:AttributeSet, msgs : (ML0 ++ ML), count : (N + 1) > if B and size(ML)
    > 0 or N' == N0 = true [label sendCurrentMsgs] .
O --> "Alice"
V:Sender --> Sender
Atts:AttributeSet --> msgsToSend : ("0" "1" "2" EOF), currentSeqNo : 0,
    receiver : "Bob", ackBuffer : (true true), channel : "C", bufferStart : -1
ML --> Mnil
N' --> 0
B --> false
N0 --> 2
I0 --> 1
O' --> "C"
V2:Channel --> Channel
Atts2:AttributeSet --> (none).AttributeSet
ML0 --> Mnil
N --> 0
*********** solving condition fragment
B and size(ML) > 0 or N' == N0 = true
*********** equation
eq size(T) = if T == Mnil then 0 else 1 + size(tail(T)) fi .
T --> Mnil
size(Mnil)
--->
if Mnil == Mnil then 0 else 1 + size(tail(Mnil)) fi
*********** equation
(built-in equation for symbol _==_)
Mnil == Mnil
--->
true
*********** equation
(built-in equation for symbol if_then_else_fi)
if true then 0 else 1 + size(tail(Mnil)) fi
--->
0
*********** equation
(built-in equation for symbol _>_)
0 > 0
--->
false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
(built-in equation for symbol _==_)
0 == 2
--->
false
*********** equation
eq A:Bool or B = A:Bool and B xor A:Bool xor B .
A:Bool --> false
B --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** failure for condition fragment
B and size(ML) > 0 or N' == N0 = true
*********** failure #3
*********** trial #4
crl < O : V:Sender | Atts:AttributeSet, msgsToSend : (S SL), sendBuffer : ML,
    currentSeqNo : N', receiver : O', ackBuffer : AckL, numWordsInBuffer : N,
    finishSend : B, bufferSize : N0, bufferStart : I, actionCount : I0 > => < O
    : V:Sender | Atts:AttributeSet, msgsToSend : SL, sendBuffer : ((msg S
    withSeqNo s N' from O to O') ++ ML), currentSeqNo : s N', receiver : O',
    ackBuffer : n N0 false, numWordsInBuffer : s N, finishSend : B, bufferSize
    : N0, bufferStart : (I + 1), actionCount : (I0 + 1) > if not B and (
    allTrue(AckL) and N == 0 or N < N0 and N > 0) = true [label load_word] .
O --> "Alice"
V:Sender --> Sender
Atts:AttributeSet --> channel : "C"
S --> "0"
SL --> "1" "2" EOF
ML --> Mnil
N' --> 0
O' --> "Bob"
AckL --> true true
N --> 0
B --> false
N0 --> 2
I --> -1
I0 --> 1
*********** solving condition fragment
not B and (allTrue(AckL) and N == 0 or N < N0 and N > 0) = true
*********** equation
eq not A:Bool = true xor A:Bool .
A:Bool --> false
not false
--->
true xor false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> true
true xor false
--->
true
*********** equation
eq allTrue(B BL) = allTrue(BL) and allTrue(B) .
B --> true
BL --> true
allTrue(true true)
--->
allTrue(true) and allTrue(true)
*********** equation
eq allTrue(B) = B .
B --> true
allTrue(true)
--->
true
*********** equation
eq allTrue(B) = B .
B --> true
allTrue(true)
--->
true
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> true
true and true
--->
true
*********** equation
(built-in equation for symbol _==_)
0 == 0
--->
true
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> true
true and true
--->
true
*********** equation
(built-in equation for symbol _<_)
0 < 2
--->
true
*********** equation
(built-in equation for symbol _>_)
0 > 0
--->
false
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> false
true and false
--->
false
*********** equation
eq A:Bool or B = A:Bool and B xor A:Bool xor B .
A:Bool --> false
B --> true
true or false
--->
false and true xor false xor true
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> false
true and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> true
true xor false
--->
true
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> true
true xor false
--->
true
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> true
true and true
--->
true
*********** success for condition fragment
not B and (allTrue(AckL) and N == 0 or N < N0 and N > 0) = true
O --> "Alice"
V:Sender --> Sender
Atts:AttributeSet --> channel : "C"
S --> "0"
SL --> "1" "2" EOF
ML --> Mnil
N' --> 0
O' --> "Bob"
AckL --> true true
N --> 0
B --> false
N0 --> 2
I --> -1
I0 --> 1
*********** success #4
*********** rule
crl < O : V:Sender | Atts:AttributeSet, msgsToSend : (S SL), sendBuffer : ML,
    currentSeqNo : N', receiver : O', ackBuffer : AckL, numWordsInBuffer : N,
    finishSend : B, bufferSize : N0, bufferStart : I, actionCount : I0 > => < O
    : V:Sender | Atts:AttributeSet, msgsToSend : SL, sendBuffer : ((msg S
    withSeqNo s N' from O to O') ++ ML), currentSeqNo : s N', receiver : O',
    ackBuffer : n N0 false, numWordsInBuffer : s N, finishSend : B, bufferSize
    : N0, bufferStart : (I + 1), actionCount : (I0 + 1) > if not B and (
    allTrue(AckL) and N == 0 or N < N0 and N > 0) = true [label load_word] .
O --> "Alice"
V:Sender --> Sender
Atts:AttributeSet --> channel : "C"
S --> "0"
SL --> "1" "2" EOF
ML --> Mnil
N' --> 0
O' --> "Bob"
AckL --> true true
N --> 0
B --> false
N0 --> 2
I --> -1
I0 --> 1
< "Alice" : Sender | msgsToSend : ("0" "1" "2" EOF), sendBuffer : Mnil,
    currentSeqNo : 0, receiver : "Bob", ackBuffer : (true true),
    numWordsInBuffer : 0, finishSend : false, channel : "C", bufferSize : 2,
    bufferStart : -1, actionCount : 1 >
--->
< "Alice" : Sender | channel : "C", msgsToSend : ("1" "2" EOF), sendBuffer : ((
    msg "0" withSeqNo 1 from "Alice" to "Bob") ++ Mnil), currentSeqNo : 1,
    receiver : "Bob", ackBuffer : n 2 false, numWordsInBuffer : 1, finishSend :
    false, bufferSize : 2, bufferStart : (-1 + 1), actionCount : (1 + 1) >
*********** equation
eq n N:Int false = if N:Int <= 0 then (nil).BoolList else false n N:Int - 1
    false fi .
N:Int --> 2
n 2 false
--->
if 2 <= 0 then (nil).BoolList else false n 2 - 1 false fi
*********** equation
(built-in equation for symbol _<=_)
2 <= 0
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then (nil).BoolList else false n 2 - 1 false fi
--->
false n 2 - 1 false
*********** equation
(built-in equation for symbol _-_)
2 - 1
--->
1
*********** equation
eq n N:Int false = if N:Int <= 0 then (nil).BoolList else false n N:Int - 1
    false fi .
N:Int --> 1
n 1 false
--->
if 1 <= 0 then (nil).BoolList else false n 1 - 1 false fi
*********** equation
(built-in equation for symbol _<=_)
1 <= 0
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then (nil).BoolList else false n 1 - 1 false fi
--->
false n 1 - 1 false
*********** equation
(built-in equation for symbol _-_)
1 - 1
--->
0
*********** equation
eq n N:Int false = if N:Int <= 0 then (nil).BoolList else false n N:Int - 1
    false fi .
N:Int --> 0
n 0 false
--->
if 0 <= 0 then (nil).BoolList else false n 0 - 1 false fi
*********** equation
(built-in equation for symbol _<=_)
0 <= 0
--->
true
*********** equation
(built-in equation for symbol if_then_else_fi)
if true then (nil).BoolList else false n 0 - 1 false fi
--->
(nil).BoolList
*********** equation
(built-in equation for symbol _+_)
1 + -1
--->
0
*********** equation
(built-in equation for symbol _+_)
1 + 1
--->
2
*********** trial #5
crl < O : V:Sender | Atts:AttributeSet, sendBuffer : ML, numWordsInBuffer : N',
    finishSend : B, bufferSize : N0, actionCount : I0 > < O' : V2:Channel |
    Atts2:AttributeSet, msgs : ML0, count : N > => < O : V:Sender |
    Atts:AttributeSet, sendBuffer : Mnil, numWordsInBuffer : 0, finishSend : B,
    bufferSize : N0, actionCount : (I0 + 1) > < O' : V2:Channel |
    Atts2:AttributeSet, msgs : (ML0 ++ ML), count : (N + 1) > if B and size(ML)
    > 0 or N' == N0 = true [label sendCurrentMsgs] .
O --> "Alice"
V:Sender --> Sender
Atts:AttributeSet --> msgsToSend : ("1" "2" EOF), currentSeqNo : 1, receiver :
    "Bob", ackBuffer : (false false), channel : "C", bufferStart : 0
ML --> msg "0" withSeqNo 1 from "Alice" to "Bob"
N' --> 1
B --> false
N0 --> 2
I0 --> 2
O' --> "C"
V2:Channel --> Channel
Atts2:AttributeSet --> (none).AttributeSet
ML0 --> Mnil
N --> 0
*********** solving condition fragment
B and size(ML) > 0 or N' == N0 = true
*********** equation
eq size(T) = if T == Mnil then 0 else 1 + size(tail(T)) fi .
T --> msg "0" withSeqNo 1 from "Alice" to "Bob"
size(msg "0" withSeqNo 1 from "Alice" to "Bob")
--->
if msg "0" withSeqNo 1 from "Alice" to "Bob" == Mnil then 0 else 1 + size(tail(
    msg "0" withSeqNo 1 from "Alice" to "Bob")) fi
*********** equation
(built-in equation for symbol _==_)
msg "0" withSeqNo 1 from "Alice" to "Bob" == Mnil
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then 0 else 1 + size(tail(msg "0" withSeqNo 1 from "Alice" to "Bob"))
    fi
--->
1 + size(tail(msg "0" withSeqNo 1 from "Alice" to "Bob"))
*********** equation
eq tail(H ++ T) = T .
H --> msg "0" withSeqNo 1 from "Alice" to "Bob"
T --> Mnil
tail(msg "0" withSeqNo 1 from "Alice" to "Bob")
--->
Mnil
*********** equation
eq size(T) = if T == Mnil then 0 else 1 + size(tail(T)) fi .
T --> Mnil
size(Mnil)
--->
if Mnil == Mnil then 0 else 1 + size(tail(Mnil)) fi
*********** equation
(built-in equation for symbol _==_)
Mnil == Mnil
--->
true
*********** equation
(built-in equation for symbol if_then_else_fi)
if true then 0 else 1 + size(tail(Mnil)) fi
--->
0
*********** equation
(built-in equation for symbol _+_)
0 + 1
--->
1
*********** equation
(built-in equation for symbol _>_)
1 > 0
--->
true
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> false
true and false
--->
false
*********** equation
(built-in equation for symbol _==_)
1 == 2
--->
false
*********** equation
eq A:Bool or B = A:Bool and B xor A:Bool xor B .
A:Bool --> false
B --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** failure for condition fragment
B and size(ML) > 0 or N' == N0 = true
*********** failure #5
*********** trial #6
crl < O : V:Sender | Atts:AttributeSet, msgsToSend : (S SL), sendBuffer : ML,
    currentSeqNo : N', receiver : O', ackBuffer : AckL, numWordsInBuffer : N,
    finishSend : B, bufferSize : N0, bufferStart : I, actionCount : I0 > => < O
    : V:Sender | Atts:AttributeSet, msgsToSend : SL, sendBuffer : ((msg S
    withSeqNo s N' from O to O') ++ ML), currentSeqNo : s N', receiver : O',
    ackBuffer : n N0 false, numWordsInBuffer : s N, finishSend : B, bufferSize
    : N0, bufferStart : (I + 1), actionCount : (I0 + 1) > if not B and (
    allTrue(AckL) and N == 0 or N < N0 and N > 0) = true [label load_word] .
O --> "Alice"
V:Sender --> Sender
Atts:AttributeSet --> channel : "C"
S --> "1"
SL --> "2" EOF
ML --> msg "0" withSeqNo 1 from "Alice" to "Bob"
N' --> 1
O' --> "Bob"
AckL --> false false
N --> 1
B --> false
N0 --> 2
I --> 0
I0 --> 2
*********** solving condition fragment
not B and (allTrue(AckL) and N == 0 or N < N0 and N > 0) = true
*********** equation
eq not A:Bool = true xor A:Bool .
A:Bool --> false
not false
--->
true xor false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> true
true xor false
--->
true
*********** equation
eq allTrue(B BL) = allTrue(BL) and allTrue(B) .
B --> false
BL --> false
allTrue(false false)
--->
allTrue(false) and allTrue(false)
*********** equation
eq allTrue(B) = B .
B --> false
allTrue(false)
--->
false
*********** equation
eq allTrue(B) = B .
B --> false
allTrue(false)
--->
false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
(built-in equation for symbol _==_)
1 == 0
--->
false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
(built-in equation for symbol _<_)
1 < 2
--->
true
*********** equation
(built-in equation for symbol _>_)
1 > 0
--->
true
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> true
true and true
--->
true
*********** equation
eq A:Bool or B = A:Bool and B xor A:Bool xor B .
A:Bool --> false
B --> true
true or false
--->
false and true xor false xor true
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> false
true and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> true
true xor false
--->
true
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> true
true xor false
--->
true
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> true
true and true
--->
true
*********** success for condition fragment
not B and (allTrue(AckL) and N == 0 or N < N0 and N > 0) = true
O --> "Alice"
V:Sender --> Sender
Atts:AttributeSet --> channel : "C"
S --> "1"
SL --> "2" EOF
ML --> msg "0" withSeqNo 1 from "Alice" to "Bob"
N' --> 1
O' --> "Bob"
AckL --> false false
N --> 1
B --> false
N0 --> 2
I --> 0
I0 --> 2
*********** success #6
*********** rule
crl < O : V:Sender | Atts:AttributeSet, msgsToSend : (S SL), sendBuffer : ML,
    currentSeqNo : N', receiver : O', ackBuffer : AckL, numWordsInBuffer : N,
    finishSend : B, bufferSize : N0, bufferStart : I, actionCount : I0 > => < O
    : V:Sender | Atts:AttributeSet, msgsToSend : SL, sendBuffer : ((msg S
    withSeqNo s N' from O to O') ++ ML), currentSeqNo : s N', receiver : O',
    ackBuffer : n N0 false, numWordsInBuffer : s N, finishSend : B, bufferSize
    : N0, bufferStart : (I + 1), actionCount : (I0 + 1) > if not B and (
    allTrue(AckL) and N == 0 or N < N0 and N > 0) = true [label load_word] .
O --> "Alice"
V:Sender --> Sender
Atts:AttributeSet --> channel : "C"
S --> "1"
SL --> "2" EOF
ML --> msg "0" withSeqNo 1 from "Alice" to "Bob"
N' --> 1
O' --> "Bob"
AckL --> false false
N --> 1
B --> false
N0 --> 2
I --> 0
I0 --> 2
< "Alice" : Sender | msgsToSend : ("1" "2" EOF), sendBuffer : msg "0" withSeqNo
    1 from "Alice" to "Bob", currentSeqNo : 1, receiver : "Bob", ackBuffer : (
    false false), numWordsInBuffer : 1, finishSend : false, channel : "C",
    bufferSize : 2, bufferStart : 0, actionCount : 2 >
--->
< "Alice" : Sender | channel : "C", msgsToSend : ("2" EOF), sendBuffer : ((msg
    "1" withSeqNo s 1 from "Alice" to "Bob") ++ msg "0" withSeqNo 1 from
    "Alice" to "Bob"), currentSeqNo : s 1, receiver : "Bob", ackBuffer : n 2
    false, numWordsInBuffer : s 1, finishSend : false, bufferSize : 2,
    bufferStart : (0 + 1), actionCount : (2 + 1) >
*********** equation
eq n N:Int false = if N:Int <= 0 then (nil).BoolList else false n N:Int - 1
    false fi .
N:Int --> 2
n 2 false
--->
if 2 <= 0 then (nil).BoolList else false n 2 - 1 false fi
*********** equation
(built-in equation for symbol _<=_)
2 <= 0
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then (nil).BoolList else false n 2 - 1 false fi
--->
false n 2 - 1 false
*********** equation
(built-in equation for symbol _-_)
2 - 1
--->
1
*********** equation
eq n N:Int false = if N:Int <= 0 then (nil).BoolList else false n N:Int - 1
    false fi .
N:Int --> 1
n 1 false
--->
if 1 <= 0 then (nil).BoolList else false n 1 - 1 false fi
*********** equation
(built-in equation for symbol _<=_)
1 <= 0
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then (nil).BoolList else false n 1 - 1 false fi
--->
false n 1 - 1 false
*********** equation
(built-in equation for symbol _-_)
1 - 1
--->
0
*********** equation
eq n N:Int false = if N:Int <= 0 then (nil).BoolList else false n N:Int - 1
    false fi .
N:Int --> 0
n 0 false
--->
if 0 <= 0 then (nil).BoolList else false n 0 - 1 false fi
*********** equation
(built-in equation for symbol _<=_)
0 <= 0
--->
true
*********** equation
(built-in equation for symbol if_then_else_fi)
if true then (nil).BoolList else false n 0 - 1 false fi
--->
(nil).BoolList
*********** equation
(built-in equation for symbol _+_)
0 + 1
--->
1
*********** equation
(built-in equation for symbol _+_)
1 + 2
--->
3
*********** trial #7
crl < O : V:Sender | Atts:AttributeSet, sendBuffer : ML, numWordsInBuffer : N',
    finishSend : B, bufferSize : N0, actionCount : I0 > < O' : V2:Channel |
    Atts2:AttributeSet, msgs : ML0, count : N > => < O : V:Sender |
    Atts:AttributeSet, sendBuffer : Mnil, numWordsInBuffer : 0, finishSend : B,
    bufferSize : N0, actionCount : (I0 + 1) > < O' : V2:Channel |
    Atts2:AttributeSet, msgs : (ML0 ++ ML), count : (N + 1) > if B and size(ML)
    > 0 or N' == N0 = true [label sendCurrentMsgs] .
O --> "Alice"
V:Sender --> Sender
Atts:AttributeSet --> msgsToSend : ("2" EOF), currentSeqNo : 2, receiver :
    "Bob", ackBuffer : (false false), channel : "C", bufferStart : 1
ML --> (msg "1" withSeqNo 2 from "Alice" to "Bob") ++ msg "0" withSeqNo 1 from
    "Alice" to "Bob"
N' --> 2
B --> false
N0 --> 2
I0 --> 3
O' --> "C"
V2:Channel --> Channel
Atts2:AttributeSet --> (none).AttributeSet
ML0 --> Mnil
N --> 0
*********** solving condition fragment
B and size(ML) > 0 or N' == N0 = true
*********** equation
eq size(T) = if T == Mnil then 0 else 1 + size(tail(T)) fi .
T --> (msg "1" withSeqNo 2 from "Alice" to "Bob") ++ msg "0" withSeqNo 1 from
    "Alice" to "Bob"
size((msg "1" withSeqNo 2 from "Alice" to "Bob") ++ msg "0" withSeqNo 1 from
    "Alice" to "Bob")
--->
if (msg "1" withSeqNo 2 from "Alice" to "Bob") ++ msg "0" withSeqNo 1 from
    "Alice" to "Bob" == Mnil then 0 else 1 + size(tail((msg "1" withSeqNo 2
    from "Alice" to "Bob") ++ msg "0" withSeqNo 1 from "Alice" to "Bob")) fi
*********** equation
(built-in equation for symbol _==_)
(msg "1" withSeqNo 2 from "Alice" to "Bob") ++ msg "0" withSeqNo 1 from "Alice"
    to "Bob" == Mnil
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then 0 else 1 + size(tail((msg "1" withSeqNo 2 from "Alice" to "Bob")
    ++ msg "0" withSeqNo 1 from "Alice" to "Bob")) fi
--->
1 + size(tail((msg "1" withSeqNo 2 from "Alice" to "Bob") ++ msg "0" withSeqNo
    1 from "Alice" to "Bob"))
*********** equation
eq tail(H ++ T) = T .
H --> msg "1" withSeqNo 2 from "Alice" to "Bob"
T --> msg "0" withSeqNo 1 from "Alice" to "Bob"
tail((msg "1" withSeqNo 2 from "Alice" to "Bob") ++ msg "0" withSeqNo 1 from
    "Alice" to "Bob")
--->
msg "0" withSeqNo 1 from "Alice" to "Bob"
*********** equation
eq size(T) = if T == Mnil then 0 else 1 + size(tail(T)) fi .
T --> msg "0" withSeqNo 1 from "Alice" to "Bob"
size(msg "0" withSeqNo 1 from "Alice" to "Bob")
--->
if msg "0" withSeqNo 1 from "Alice" to "Bob" == Mnil then 0 else 1 + size(tail(
    msg "0" withSeqNo 1 from "Alice" to "Bob")) fi
*********** equation
(built-in equation for symbol _==_)
msg "0" withSeqNo 1 from "Alice" to "Bob" == Mnil
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then 0 else 1 + size(tail(msg "0" withSeqNo 1 from "Alice" to "Bob"))
    fi
--->
1 + size(tail(msg "0" withSeqNo 1 from "Alice" to "Bob"))
*********** equation
eq tail(H ++ T) = T .
H --> msg "0" withSeqNo 1 from "Alice" to "Bob"
T --> Mnil
tail(msg "0" withSeqNo 1 from "Alice" to "Bob")
--->
Mnil
*********** equation
eq size(T) = if T == Mnil then 0 else 1 + size(tail(T)) fi .
T --> Mnil
size(Mnil)
--->
if Mnil == Mnil then 0 else 1 + size(tail(Mnil)) fi
*********** equation
(built-in equation for symbol _==_)
Mnil == Mnil
--->
true
*********** equation
(built-in equation for symbol if_then_else_fi)
if true then 0 else 1 + size(tail(Mnil)) fi
--->
0
*********** equation
(built-in equation for symbol _+_)
0 + 1
--->
1
*********** equation
(built-in equation for symbol _+_)
1 + 1
--->
2
*********** equation
(built-in equation for symbol _>_)
2 > 0
--->
true
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> false
true and false
--->
false
*********** equation
(built-in equation for symbol _==_)
2 == 2
--->
true
*********** equation
eq A:Bool or B = A:Bool and B xor A:Bool xor B .
A:Bool --> false
B --> true
true or false
--->
false and true xor false xor true
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> false
true and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> true
true xor false
--->
true
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> true
true xor false
--->
true
*********** success for condition fragment
B and size(ML) > 0 or N' == N0 = true
O --> "Alice"
V:Sender --> Sender
Atts:AttributeSet --> msgsToSend : ("2" EOF), currentSeqNo : 2, receiver :
    "Bob", ackBuffer : (false false), channel : "C", bufferStart : 1
ML --> (msg "1" withSeqNo 2 from "Alice" to "Bob") ++ msg "0" withSeqNo 1 from
    "Alice" to "Bob"
N' --> 2
B --> false
N0 --> 2
I0 --> 3
O' --> "C"
V2:Channel --> Channel
Atts2:AttributeSet --> (none).AttributeSet
ML0 --> Mnil
N --> 0
*********** success #7
*********** rule
crl < O : V:Sender | Atts:AttributeSet, sendBuffer : ML, numWordsInBuffer : N',
    finishSend : B, bufferSize : N0, actionCount : I0 > < O' : V2:Channel |
    Atts2:AttributeSet, msgs : ML0, count : N > => < O : V:Sender |
    Atts:AttributeSet, sendBuffer : Mnil, numWordsInBuffer : 0, finishSend : B,
    bufferSize : N0, actionCount : (I0 + 1) > < O' : V2:Channel |
    Atts2:AttributeSet, msgs : (ML0 ++ ML), count : (N + 1) > if B and size(ML)
    > 0 or N' == N0 = true [label sendCurrentMsgs] .
O --> "Alice"
V:Sender --> Sender
Atts:AttributeSet --> msgsToSend : ("2" EOF), currentSeqNo : 2, receiver :
    "Bob", ackBuffer : (false false), channel : "C", bufferStart : 1
ML --> (msg "1" withSeqNo 2 from "Alice" to "Bob") ++ msg "0" withSeqNo 1 from
    "Alice" to "Bob"
N' --> 2
B --> false
N0 --> 2
I0 --> 3
O' --> "C"
V2:Channel --> Channel
Atts2:AttributeSet --> (none).AttributeSet
ML0 --> Mnil
N --> 0
< "Alice" : Sender | msgsToSend : ("2" EOF), sendBuffer : ((msg "1" withSeqNo 2
    from "Alice" to "Bob") ++ msg "0" withSeqNo 1 from "Alice" to "Bob"),
    currentSeqNo : 2, receiver : "Bob", ackBuffer : (false false),
    numWordsInBuffer : 2, finishSend : false, channel : "C", bufferSize : 2,
    bufferStart : 1, actionCount : 3 > < "Bob" : Receiver | channel : "C",
    bufferSize : 2, bufferStart : 1, greatestSeqNoRcvd : 0, sender : "Alice",
    msgsRcvd : nil, rcvBuffer : (mts mts), rcvCheck : (false false), rcvEOF :
    false, EOFPos : 0 > < "C" : Channel | msgs : Mnil, count : 0 >
--->
< "Bob" : Receiver | channel : "C", bufferSize : 2, bufferStart : 1,
    greatestSeqNoRcvd : 0, sender : "Alice", msgsRcvd : nil, rcvBuffer : (mts
    mts), rcvCheck : (false false), rcvEOF : false, EOFPos : 0 > < "Alice" :
    Sender | (msgsToSend : ("2" EOF), currentSeqNo : 2, receiver : "Bob",
    ackBuffer : (false false), channel : "C", bufferStart : 1), sendBuffer :
    Mnil, numWordsInBuffer : 0, finishSend : false, bufferSize : 2, actionCount
    : (3 + 1) > < "C" : Channel | none, msgs : (Mnil ++ (msg "1" withSeqNo 2
    from "Alice" to "Bob") ++ msg "0" withSeqNo 1 from "Alice" to "Bob"), count
    : (0 + 1) >
*********** equation
(built-in equation for symbol _+_)
1 + 3
--->
4
*********** equation
(built-in equation for symbol _+_)
0 + 1
--->
1
*********** trial #8
crl < O : V:Sender | Atts:AttributeSet, msgsToSend : (S SL), sendBuffer : ML,
    currentSeqNo : N', receiver : O', ackBuffer : AckL, numWordsInBuffer : N,
    finishSend : B, bufferSize : N0, bufferStart : I, actionCount : I0 > => < O
    : V:Sender | Atts:AttributeSet, msgsToSend : SL, sendBuffer : ((msg S
    withSeqNo s N' from O to O') ++ ML), currentSeqNo : s N', receiver : O',
    ackBuffer : n N0 false, numWordsInBuffer : s N, finishSend : B, bufferSize
    : N0, bufferStart : (I + 1), actionCount : (I0 + 1) > if not B and (
    allTrue(AckL) and N == 0 or N < N0 and N > 0) = true [label load_word] .
O --> "Alice"
V:Sender --> Sender
Atts:AttributeSet --> channel : "C"
S --> "2"
SL --> EOF
ML --> Mnil
N' --> 2
O' --> "Bob"
AckL --> false false
N --> 0
B --> false
N0 --> 2
I --> 1
I0 --> 4
*********** solving condition fragment
not B and (allTrue(AckL) and N == 0 or N < N0 and N > 0) = true
*********** equation
eq not A:Bool = true xor A:Bool .
A:Bool --> false
not false
--->
true xor false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> true
true xor false
--->
true
*********** equation
eq allTrue(B BL) = allTrue(BL) and allTrue(B) .
B --> false
BL --> false
allTrue(false false)
--->
allTrue(false) and allTrue(false)
*********** equation
eq allTrue(B) = B .
B --> false
allTrue(false)
--->
false
*********** equation
eq allTrue(B) = B .
B --> false
allTrue(false)
--->
false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
(built-in equation for symbol _==_)
0 == 0
--->
true
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> false
true and false
--->
false
*********** equation
(built-in equation for symbol _<_)
0 < 2
--->
true
*********** equation
(built-in equation for symbol _>_)
0 > 0
--->
false
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> false
true and false
--->
false
*********** equation
eq A:Bool or B = A:Bool and B xor A:Bool xor B .
A:Bool --> false
B --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> false
true and false
--->
false
*********** failure for condition fragment
not B and (allTrue(AckL) and N == 0 or N < N0 and N > 0) = true
*********** failure #8
*********** trial #9
crl < O : V:Channel | Atts:AttributeSet, msgs : ML, count : N > => (ML[random(
    N) rem size(ML)]) < O : V:Channel | Atts:AttributeSet, msgs : pop(ML,
    random(N) rem size(ML)), count : (N + 1) > if size(ML) > 0 = true [label
    convey-msg] .
O --> "C"
V:Channel --> Channel
Atts:AttributeSet --> (none).AttributeSet
ML --> (msg "1" withSeqNo 2 from "Alice" to "Bob") ++ msg "0" withSeqNo 1 from
    "Alice" to "Bob"
N --> 1
*********** solving condition fragment
size(ML) > 0 = true
*********** equation
eq size(T) = if T == Mnil then 0 else 1 + size(tail(T)) fi .
T --> (msg "1" withSeqNo 2 from "Alice" to "Bob") ++ msg "0" withSeqNo 1 from
    "Alice" to "Bob"
size((msg "1" withSeqNo 2 from "Alice" to "Bob") ++ msg "0" withSeqNo 1 from
    "Alice" to "Bob")
--->
if (msg "1" withSeqNo 2 from "Alice" to "Bob") ++ msg "0" withSeqNo 1 from
    "Alice" to "Bob" == Mnil then 0 else 1 + size(tail((msg "1" withSeqNo 2
    from "Alice" to "Bob") ++ msg "0" withSeqNo 1 from "Alice" to "Bob")) fi
*********** equation
(built-in equation for symbol _==_)
(msg "1" withSeqNo 2 from "Alice" to "Bob") ++ msg "0" withSeqNo 1 from "Alice"
    to "Bob" == Mnil
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then 0 else 1 + size(tail((msg "1" withSeqNo 2 from "Alice" to "Bob")
    ++ msg "0" withSeqNo 1 from "Alice" to "Bob")) fi
--->
1 + size(tail((msg "1" withSeqNo 2 from "Alice" to "Bob") ++ msg "0" withSeqNo
    1 from "Alice" to "Bob"))
*********** equation
eq tail(H ++ T) = T .
H --> msg "1" withSeqNo 2 from "Alice" to "Bob"
T --> msg "0" withSeqNo 1 from "Alice" to "Bob"
tail((msg "1" withSeqNo 2 from "Alice" to "Bob") ++ msg "0" withSeqNo 1 from
    "Alice" to "Bob")
--->
msg "0" withSeqNo 1 from "Alice" to "Bob"
*********** equation
eq size(T) = if T == Mnil then 0 else 1 + size(tail(T)) fi .
T --> msg "0" withSeqNo 1 from "Alice" to "Bob"
size(msg "0" withSeqNo 1 from "Alice" to "Bob")
--->
if msg "0" withSeqNo 1 from "Alice" to "Bob" == Mnil then 0 else 1 + size(tail(
    msg "0" withSeqNo 1 from "Alice" to "Bob")) fi
*********** equation
(built-in equation for symbol _==_)
msg "0" withSeqNo 1 from "Alice" to "Bob" == Mnil
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then 0 else 1 + size(tail(msg "0" withSeqNo 1 from "Alice" to "Bob"))
    fi
--->
1 + size(tail(msg "0" withSeqNo 1 from "Alice" to "Bob"))
*********** equation
eq tail(H ++ T) = T .
H --> msg "0" withSeqNo 1 from "Alice" to "Bob"
T --> Mnil
tail(msg "0" withSeqNo 1 from "Alice" to "Bob")
--->
Mnil
*********** equation
eq size(T) = if T == Mnil then 0 else 1 + size(tail(T)) fi .
T --> Mnil
size(Mnil)
--->
if Mnil == Mnil then 0 else 1 + size(tail(Mnil)) fi
*********** equation
(built-in equation for symbol _==_)
Mnil == Mnil
--->
true
*********** equation
(built-in equation for symbol if_then_else_fi)
if true then 0 else 1 + size(tail(Mnil)) fi
--->
0
*********** equation
(built-in equation for symbol _+_)
0 + 1
--->
1
*********** equation
(built-in equation for symbol _+_)
1 + 1
--->
2
*********** equation
(built-in equation for symbol _>_)
2 > 0
--->
true
*********** success for condition fragment
size(ML) > 0 = true
O --> "C"
V:Channel --> Channel
Atts:AttributeSet --> (none).AttributeSet
ML --> (msg "1" withSeqNo 2 from "Alice" to "Bob") ++ msg "0" withSeqNo 1 from
    "Alice" to "Bob"
N --> 1
*********** success #9
*********** rule
crl < O : V:Channel | Atts:AttributeSet, msgs : ML, count : N > => (ML[random(
    N) rem size(ML)]) < O : V:Channel | Atts:AttributeSet, msgs : pop(ML,
    random(N) rem size(ML)), count : (N + 1) > if size(ML) > 0 = true [label
    convey-msg] .
O --> "C"
V:Channel --> Channel
Atts:AttributeSet --> (none).AttributeSet
ML --> (msg "1" withSeqNo 2 from "Alice" to "Bob") ++ msg "0" withSeqNo 1 from
    "Alice" to "Bob"
N --> 1
< "C" : Channel | msgs : ((msg "1" withSeqNo 2 from "Alice" to "Bob") ++ msg
    "0" withSeqNo 1 from "Alice" to "Bob"), count : 1 >
--->
(((msg "1" withSeqNo 2 from "Alice" to "Bob") ++ msg "0" withSeqNo 1 from
    "Alice" to "Bob")[random(1) rem 2]) < "C" : Channel | none, msgs : pop((msg
    "1" withSeqNo 2 from "Alice" to "Bob") ++ msg "0" withSeqNo 1 from "Alice"
    to "Bob",random(1) rem 2), count : (1 + 1) >
*********** equation
(built-in equation for symbol random)
random(1)
--->
2546248239
*********** equation
(built-in equation for symbol _rem_)
2546248239 rem 2
--->
1
*********** equation
eq T[N] = if N <= 0 then if N == 0 then head(T) else Mnil fi else tail(T)[N -
    1] fi .
T --> (msg "1" withSeqNo 2 from "Alice" to "Bob") ++ msg "0" withSeqNo 1 from
    "Alice" to "Bob"
N --> 1
((msg "1" withSeqNo 2 from "Alice" to "Bob") ++ msg "0" withSeqNo 1 from
    "Alice" to "Bob")[1]
--->
if 1 <= 0 then if 1 == 0 then head((msg "1" withSeqNo 2 from "Alice" to "Bob")
    ++ msg "0" withSeqNo 1 from "Alice" to "Bob") else Mnil fi else tail((msg
    "1" withSeqNo 2 from "Alice" to "Bob") ++ msg "0" withSeqNo 1 from "Alice"
    to "Bob")[1 - 1] fi
*********** equation
(built-in equation for symbol _<=_)
1 <= 0
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then if 1 == 0 then head((msg "1" withSeqNo 2 from "Alice" to "Bob")
    ++ msg "0" withSeqNo 1 from "Alice" to "Bob") else Mnil fi else tail((msg
    "1" withSeqNo 2 from "Alice" to "Bob") ++ msg "0" withSeqNo 1 from "Alice"
    to "Bob")[1 - 1] fi
--->
tail((msg "1" withSeqNo 2 from "Alice" to "Bob") ++ msg "0" withSeqNo 1 from
    "Alice" to "Bob")[1 - 1]
*********** equation
eq tail(H ++ T) = T .
H --> msg "1" withSeqNo 2 from "Alice" to "Bob"
T --> msg "0" withSeqNo 1 from "Alice" to "Bob"
tail((msg "1" withSeqNo 2 from "Alice" to "Bob") ++ msg "0" withSeqNo 1 from
    "Alice" to "Bob")
--->
msg "0" withSeqNo 1 from "Alice" to "Bob"
*********** equation
(built-in equation for symbol _-_)
1 - 1
--->
0
*********** equation
eq T[N] = if N <= 0 then if N == 0 then head(T) else Mnil fi else tail(T)[N -
    1] fi .
T --> msg "0" withSeqNo 1 from "Alice" to "Bob"
N --> 0
msg "0" withSeqNo 1 from "Alice" to "Bob"[0]
--->
if 0 <= 0 then if 0 == 0 then head(msg "0" withSeqNo 1 from "Alice" to "Bob")
    else Mnil fi else tail(msg "0" withSeqNo 1 from "Alice" to "Bob")[0 - 1] fi
*********** equation
(built-in equation for symbol _<=_)
0 <= 0
--->
true
*********** equation
(built-in equation for symbol if_then_else_fi)
if true then if 0 == 0 then head(msg "0" withSeqNo 1 from "Alice" to "Bob")
    else Mnil fi else tail(msg "0" withSeqNo 1 from "Alice" to "Bob")[0 - 1] fi
--->
if 0 == 0 then head(msg "0" withSeqNo 1 from "Alice" to "Bob") else Mnil fi
*********** equation
(built-in equation for symbol _==_)
0 == 0
--->
true
*********** equation
(built-in equation for symbol if_then_else_fi)
if true then head(msg "0" withSeqNo 1 from "Alice" to "Bob") else Mnil fi
--->
head(msg "0" withSeqNo 1 from "Alice" to "Bob")
*********** equation
eq head(H ++ T) = H .
H --> msg "0" withSeqNo 1 from "Alice" to "Bob"
T --> Mnil
head(msg "0" withSeqNo 1 from "Alice" to "Bob")
--->
msg "0" withSeqNo 1 from "Alice" to "Bob"
*********** equation
eq pop(T,N) = if N == 0 then tail(T) else head(T) ++ pop(tail(T),N - 1) fi .
T --> (msg "1" withSeqNo 2 from "Alice" to "Bob") ++ msg "0" withSeqNo 1 from
    "Alice" to "Bob"
N --> 1
pop((msg "1" withSeqNo 2 from "Alice" to "Bob") ++ msg "0" withSeqNo 1 from
    "Alice" to "Bob",1)
--->
if 1 == 0 then tail((msg "1" withSeqNo 2 from "Alice" to "Bob") ++ msg "0"
    withSeqNo 1 from "Alice" to "Bob") else head((msg "1" withSeqNo 2 from
    "Alice" to "Bob") ++ msg "0" withSeqNo 1 from "Alice" to "Bob") ++ pop(
    tail((msg "1" withSeqNo 2 from "Alice" to "Bob") ++ msg "0" withSeqNo 1
    from "Alice" to "Bob"),1 - 1) fi
*********** equation
(built-in equation for symbol _==_)
1 == 0
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then tail((msg "1" withSeqNo 2 from "Alice" to "Bob") ++ msg "0"
    withSeqNo 1 from "Alice" to "Bob") else head((msg "1" withSeqNo 2 from
    "Alice" to "Bob") ++ msg "0" withSeqNo 1 from "Alice" to "Bob") ++ pop(
    tail((msg "1" withSeqNo 2 from "Alice" to "Bob") ++ msg "0" withSeqNo 1
    from "Alice" to "Bob"),1 - 1) fi
--->
head((msg "1" withSeqNo 2 from "Alice" to "Bob") ++ msg "0" withSeqNo 1 from
    "Alice" to "Bob") ++ pop(tail((msg "1" withSeqNo 2 from "Alice" to "Bob")
    ++ msg "0" withSeqNo 1 from "Alice" to "Bob"),1 - 1)
*********** equation
eq head(H ++ T) = H .
H --> msg "1" withSeqNo 2 from "Alice" to "Bob"
T --> msg "0" withSeqNo 1 from "Alice" to "Bob"
head((msg "1" withSeqNo 2 from "Alice" to "Bob") ++ msg "0" withSeqNo 1 from
    "Alice" to "Bob")
--->
msg "1" withSeqNo 2 from "Alice" to "Bob"
*********** equation
eq tail(H ++ T) = T .
H --> msg "1" withSeqNo 2 from "Alice" to "Bob"
T --> msg "0" withSeqNo 1 from "Alice" to "Bob"
tail((msg "1" withSeqNo 2 from "Alice" to "Bob") ++ msg "0" withSeqNo 1 from
    "Alice" to "Bob")
--->
msg "0" withSeqNo 1 from "Alice" to "Bob"
*********** equation
(built-in equation for symbol _-_)
1 - 1
--->
0
*********** equation
eq pop(T,N) = if N == 0 then tail(T) else head(T) ++ pop(tail(T),N - 1) fi .
T --> msg "0" withSeqNo 1 from "Alice" to "Bob"
N --> 0
pop(msg "0" withSeqNo 1 from "Alice" to "Bob",0)
--->
if 0 == 0 then tail(msg "0" withSeqNo 1 from "Alice" to "Bob") else head(msg
    "0" withSeqNo 1 from "Alice" to "Bob") ++ pop(tail(msg "0" withSeqNo 1 from
    "Alice" to "Bob"),0 - 1) fi
*********** equation
(built-in equation for symbol _==_)
0 == 0
--->
true
*********** equation
(built-in equation for symbol if_then_else_fi)
if true then tail(msg "0" withSeqNo 1 from "Alice" to "Bob") else head(msg "0"
    withSeqNo 1 from "Alice" to "Bob") ++ pop(tail(msg "0" withSeqNo 1 from
    "Alice" to "Bob"),0 - 1) fi
--->
tail(msg "0" withSeqNo 1 from "Alice" to "Bob")
*********** equation
eq tail(H ++ T) = T .
H --> msg "0" withSeqNo 1 from "Alice" to "Bob"
T --> Mnil
tail(msg "0" withSeqNo 1 from "Alice" to "Bob")
--->
Mnil
*********** equation
(built-in equation for symbol _+_)
1 + 1
--->
2
*********** trial #10
crl < O : V:Receiver | Atts:AttributeSet, greatestSeqNoRcvd : N' > msg S
    withSeqNo N from O' to O => < O : V:Receiver | Atts:AttributeSet,
    greatestSeqNoRcvd : N' > msg ack withSeqNo N' from O to O' if N <= N' =
    true [label rcvOldPacket] .
O --> "Bob"
V:Receiver --> Receiver
Atts:AttributeSet --> channel : "C", bufferSize : 2, bufferStart : 1, sender :
    "Alice", msgsRcvd : nil, rcvBuffer : (mts mts), rcvCheck : (false false),
    rcvEOF : false, EOFPos : 0
N' --> 0
S --> "0"
N --> 1
O' --> "Alice"
*********** solving condition fragment
N <= N' = true
*********** equation
(built-in equation for symbol _<=_)
1 <= 0
--->
false
*********** failure for condition fragment
N <= N' = true
*********** failure #10
*********** trial #11
crl < O : V:Receiver | Atts:AttributeSet, bufferSize : N1, bufferStart : N0,
    greatestSeqNoRcvd : N', rcvBuffer : SL, rcvCheck : BL > < O2 : V2:Channel |
    Atts2:AttributeSet, count : N2 > msg S withSeqNo N from O' to O => (< O2 :
    V2:Channel | Atts2:AttributeSet, count : s N2 > msg ack withSeqNo N0 +
    lastConsecutiveTrue(assign(BL,N - N0,true)) from O to O') < O : V:Receiver
    | Atts:AttributeSet, bufferSize : N1, bufferStart : N0, greatestSeqNoRcvd :
    N', rcvBuffer : assign(SL,N - N0,S), rcvCheck : assign(BL,N - N0,true) > if
    N >= N' = true /\ N < N0 + N1 = true /\ not S == EOF = true [label
    rcvNewPacket] .
O --> "Bob"
V:Receiver --> Receiver
Atts:AttributeSet --> channel : "C", sender : "Alice", msgsRcvd : nil, rcvEOF :
    false, EOFPos : 0
N1 --> 2
N0 --> 1
N' --> 0
SL --> mts mts
BL --> false false
O2 --> "C"
V2:Channel --> Channel
Atts2:AttributeSet --> msgs : msg "1" withSeqNo 2 from "Alice" to "Bob"
N2 --> 2
S --> "0"
N --> 1
O' --> "Alice"
*********** solving condition fragment
N >= N' = true
*********** equation
(built-in equation for symbol _>=_)
1 >= 0
--->
true
*********** success for condition fragment
N >= N' = true
O --> "Bob"
V:Receiver --> Receiver
Atts:AttributeSet --> channel : "C", sender : "Alice", msgsRcvd : nil, rcvEOF :
    false, EOFPos : 0
N1 --> 2
N0 --> 1
N' --> 0
SL --> mts mts
BL --> false false
O2 --> "C"
V2:Channel --> Channel
Atts2:AttributeSet --> msgs : msg "1" withSeqNo 2 from "Alice" to "Bob"
N2 --> 2
S --> "0"
N --> 1
O' --> "Alice"
*********** solving condition fragment
N < N0 + N1 = true
*********** equation
(built-in equation for symbol _+_)
1 + 2
--->
3
*********** equation
(built-in equation for symbol _<_)
1 < 3
--->
true
*********** success for condition fragment
N < N0 + N1 = true
O --> "Bob"
V:Receiver --> Receiver
Atts:AttributeSet --> channel : "C", sender : "Alice", msgsRcvd : nil, rcvEOF :
    false, EOFPos : 0
N1 --> 2
N0 --> 1
N' --> 0
SL --> mts mts
BL --> false false
O2 --> "C"
V2:Channel --> Channel
Atts2:AttributeSet --> msgs : msg "1" withSeqNo 2 from "Alice" to "Bob"
N2 --> 2
S --> "0"
N --> 1
O' --> "Alice"
*********** solving condition fragment
not S == EOF = true
*********** equation
(built-in equation for symbol _==_)
"0" == EOF
--->
false
*********** equation
eq not A:Bool = true xor A:Bool .
A:Bool --> false
not false
--->
true xor false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> true
true xor false
--->
true
*********** success for condition fragment
not S == EOF = true
O --> "Bob"
V:Receiver --> Receiver
Atts:AttributeSet --> channel : "C", sender : "Alice", msgsRcvd : nil, rcvEOF :
    false, EOFPos : 0
N1 --> 2
N0 --> 1
N' --> 0
SL --> mts mts
BL --> false false
O2 --> "C"
V2:Channel --> Channel
Atts2:AttributeSet --> msgs : msg "1" withSeqNo 2 from "Alice" to "Bob"
N2 --> 2
S --> "0"
N --> 1
O' --> "Alice"
*********** success #11
*********** rule
crl < O : V:Receiver | Atts:AttributeSet, bufferSize : N1, bufferStart : N0,
    greatestSeqNoRcvd : N', rcvBuffer : SL, rcvCheck : BL > < O2 : V2:Channel |
    Atts2:AttributeSet, count : N2 > msg S withSeqNo N from O' to O => (< O2 :
    V2:Channel | Atts2:AttributeSet, count : s N2 > msg ack withSeqNo N0 +
    lastConsecutiveTrue(assign(BL,N - N0,true)) from O to O') < O : V:Receiver
    | Atts:AttributeSet, bufferSize : N1, bufferStart : N0, greatestSeqNoRcvd :
    N', rcvBuffer : assign(SL,N - N0,S), rcvCheck : assign(BL,N - N0,true) > if
    N >= N' = true /\ N < N0 + N1 = true /\ not S == EOF = true [label
    rcvNewPacket] .
O --> "Bob"
V:Receiver --> Receiver
Atts:AttributeSet --> channel : "C", sender : "Alice", msgsRcvd : nil, rcvEOF :
    false, EOFPos : 0
N1 --> 2
N0 --> 1
N' --> 0
SL --> mts mts
BL --> false false
O2 --> "C"
V2:Channel --> Channel
Atts2:AttributeSet --> msgs : msg "1" withSeqNo 2 from "Alice" to "Bob"
N2 --> 2
S --> "0"
N --> 1
O' --> "Alice"
< "Alice" : Sender | msgsToSend : ("2" EOF), sendBuffer : Mnil, currentSeqNo :
    2, receiver : "Bob", ackBuffer : (false false), numWordsInBuffer : 0,
    finishSend : false, channel : "C", bufferSize : 2, bufferStart : 1,
    actionCount : 4 > < "Bob" : Receiver | channel : "C", bufferSize : 2,
    bufferStart : 1, greatestSeqNoRcvd : 0, sender : "Alice", msgsRcvd : nil,
    rcvBuffer : (mts mts), rcvCheck : (false false), rcvEOF : false, EOFPos : 0
    > < "C" : Channel | msgs : msg "1" withSeqNo 2 from "Alice" to "Bob", count
    : 2 > msg "0" withSeqNo 1 from "Alice" to "Bob"
--->
< "Alice" : Sender | msgsToSend : ("2" EOF), sendBuffer : Mnil, currentSeqNo :
    2, receiver : "Bob", ackBuffer : (false false), numWordsInBuffer : 0,
    finishSend : false, channel : "C", bufferSize : 2, bufferStart : 1,
    actionCount : 4 > (< "C" : Channel | msgs : msg "1" withSeqNo 2 from
    "Alice" to "Bob", count : s 2 > msg ack withSeqNo 1 + lastConsecutiveTrue(
    assign(false false,1 - 1,true)) from "Bob" to "Alice") < "Bob" : Receiver |
    (channel : "C", sender : "Alice", msgsRcvd : nil, rcvEOF : false, EOFPos :
    0), bufferSize : 2, bufferStart : 1, greatestSeqNoRcvd : 0, rcvBuffer :
    assign(mts mts,1 - 1,"0"), rcvCheck : assign(false false,1 - 1,true) >
*********** equation
(built-in equation for symbol _-_)
1 - 1
--->
0
*********** equation
eq assign(BL,N:Int,B) = if N:Int < 0 or N:Int >= size(BL) then BL else if N:Int
    == 0 then B tail(BL) else head(BL) assign(tail(BL),N:Int - 1,B) fi fi .
BL --> false false
N:Int --> 0
B --> true
assign(false false,0,true)
--->
if 0 < 0 or 0 >= size(false false) then false false else if 0 == 0 then true
    tail(false false) else head(false false) assign(tail(false false),0 - 1,
    true) fi fi
*********** equation
(built-in equation for symbol _<_)
0 < 0
--->
false
*********** equation
eq size(L:BoolList) = $size(L:BoolList, 0) .
L:BoolList --> false false
size(false false)
--->
$size(false false, 0)
*********** equation
eq $size(E:Bool L:BoolList, C:Nat) = $size(L:BoolList, C:Nat + 1) .
E:Bool --> false
L:BoolList --> false
C:Nat --> 0
$size(false false, 0)
--->
$size(false, 0 + 1)
*********** equation
(built-in equation for symbol _+_)
0 + 1
--->
1
*********** equation
eq $size(E:Bool L:BoolList, C:Nat) = $size(L:BoolList, C:Nat + 1) .
E:Bool --> false
L:BoolList --> (nil).BoolList
C:Nat --> 1
$size(false, 1)
--->
$size((nil).BoolList, 1 + 1)
*********** equation
(built-in equation for symbol _+_)
1 + 1
--->
2
*********** equation
eq $size((nil).BoolList, C:Nat) = C:Nat .
C:Nat --> 2
$size((nil).BoolList, 2)
--->
2
*********** equation
(built-in equation for symbol _>=_)
0 >= 2
--->
false
*********** equation
eq A:Bool or B = A:Bool and B xor A:Bool xor B .
A:Bool --> false
B --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then false false else if 0 == 0 then true tail(false false) else head(
    false false) assign(tail(false false),0 - 1,true) fi fi
--->
if 0 == 0 then true tail(false false) else head(false false) assign(tail(false
    false),0 - 1,true) fi
*********** equation
(built-in equation for symbol _==_)
0 == 0
--->
true
*********** equation
(built-in equation for symbol if_then_else_fi)
if true then true tail(false false) else head(false false) assign(tail(false
    false),0 - 1,true) fi
--->
true tail(false false)
*********** equation
eq tail(E:Bool L:BoolList) = L:BoolList .
E:Bool --> false
L:BoolList --> false
tail(false false)
--->
false
*********** equation
eq lastConsecutiveTrue(BL) = if BL == (nil).BoolList or head(BL) == false then
    -1 else 1 + lastConsecutiveTrue(tail(BL)) fi .
BL --> true false
lastConsecutiveTrue(true false)
--->
if true false == (nil).BoolList or head(true false) == false then -1 else 1 +
    lastConsecutiveTrue(tail(true false)) fi
*********** equation
(built-in equation for symbol _==_)
true false == (nil).BoolList
--->
false
*********** equation
eq head(E:Bool L:BoolList) = E:Bool .
E:Bool --> true
L:BoolList --> false
head(true false)
--->
true
*********** equation
(built-in equation for symbol _==_)
true == false
--->
false
*********** equation
eq A:Bool or B = A:Bool and B xor A:Bool xor B .
A:Bool --> false
B --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then -1 else 1 + lastConsecutiveTrue(tail(true false)) fi
--->
1 + lastConsecutiveTrue(tail(true false))
*********** equation
eq tail(E:Bool L:BoolList) = L:BoolList .
E:Bool --> true
L:BoolList --> false
tail(true false)
--->
false
*********** equation
eq lastConsecutiveTrue(BL) = if BL == (nil).BoolList or head(BL) == false then
    -1 else 1 + lastConsecutiveTrue(tail(BL)) fi .
BL --> false
lastConsecutiveTrue(false)
--->
if false == (nil).BoolList or head(false) == false then -1 else 1 +
    lastConsecutiveTrue(tail(false)) fi
*********** equation
(built-in equation for symbol _==_)
false == (nil).BoolList
--->
false
*********** equation
eq head(E:Bool L:BoolList) = E:Bool .
E:Bool --> false
L:BoolList --> (nil).BoolList
head(false)
--->
false
*********** equation
(built-in equation for symbol _==_)
false == false
--->
true
*********** equation
eq A:Bool or B = A:Bool and B xor A:Bool xor B .
A:Bool --> false
B --> true
true or false
--->
false and true xor false xor true
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> false
true and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> true
true xor false
--->
true
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> true
true xor false
--->
true
*********** equation
(built-in equation for symbol if_then_else_fi)
if true then -1 else 1 + lastConsecutiveTrue(tail(false)) fi
--->
-1
*********** equation
(built-in equation for symbol _+_)
1 + -1
--->
0
*********** equation
(built-in equation for symbol _+_)
0 + 1
--->
1
*********** equation
eq assign(SL,N:Int,S) = if N:Int < 0 or N:Int >= size(SL) then SL else if N:Int
    == 0 then S tail(SL) else head(SL) assign(tail(SL),N:Int - 1,S) fi fi .
SL --> mts mts
N:Int --> 0
S --> "0"
assign(mts mts,0,"0")
--->
if 0 < 0 or 0 >= size(mts mts) then mts mts else if 0 == 0 then "0" tail(mts
    mts) else head(mts mts) assign(tail(mts mts),0 - 1,"0") fi fi
*********** equation
(built-in equation for symbol _<_)
0 < 0
--->
false
*********** equation
eq size(L:StringList) = $size(L:StringList, 0) .
L:StringList --> mts mts
size(mts mts)
--->
$size(mts mts, 0)
*********** equation
eq $size(E:String L:StringList, C:Nat) = $size(L:StringList, C:Nat + 1) .
E:String --> mts
L:StringList --> mts
C:Nat --> 0
$size(mts mts, 0)
--->
$size(mts, 0 + 1)
*********** equation
(built-in equation for symbol _+_)
0 + 1
--->
1
*********** equation
eq $size(E:String L:StringList, C:Nat) = $size(L:StringList, C:Nat + 1) .
E:String --> mts
L:StringList --> (nil).StringList
C:Nat --> 1
$size(mts, 1)
--->
$size((nil).StringList, 1 + 1)
*********** equation
(built-in equation for symbol _+_)
1 + 1
--->
2
*********** equation
eq $size((nil).StringList, C:Nat) = C:Nat .
C:Nat --> 2
$size((nil).StringList, 2)
--->
2
*********** equation
(built-in equation for symbol _>=_)
0 >= 2
--->
false
*********** equation
eq A:Bool or B = A:Bool and B xor A:Bool xor B .
A:Bool --> false
B --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then mts mts else if 0 == 0 then "0" tail(mts mts) else head(mts mts)
    assign(tail(mts mts),0 - 1,"0") fi fi
--->
if 0 == 0 then "0" tail(mts mts) else head(mts mts) assign(tail(mts mts),0 - 1,
    "0") fi
*********** equation
(built-in equation for symbol _==_)
0 == 0
--->
true
*********** equation
(built-in equation for symbol if_then_else_fi)
if true then "0" tail(mts mts) else head(mts mts) assign(tail(mts mts),0 - 1,
    "0") fi
--->
"0" tail(mts mts)
*********** equation
eq tail(E:String L:StringList) = L:StringList .
E:String --> mts
L:StringList --> mts
tail(mts mts)
--->
mts
*********** trial #12
crl < O : V:Receiver | Atts:AttributeSet, bufferSize : N0, bufferStart : I0,
    greatestSeqNoRcvd : N, msgsRcvd : SL, rcvBuffer : SL0, rcvCheck : BL,
    rcvEOF : B0, EOFPos : N1 > => < O : V:Receiver | Atts:AttributeSet,
    bufferSize : N0, bufferStart : (N0 + I0), greatestSeqNoRcvd : (N + N0),
    msgsRcvd : (SL SL0), rcvBuffer : n N0 mts, rcvCheck : n N0 false, rcvEOF :
    B0, EOFPos : N1 > if allTrue(BL) or B0 and lastConsecutiveTrue(BL) >= N1 =
    true [label loadWordsFromBuffer] .
O --> "Bob"
V:Receiver --> Receiver
Atts:AttributeSet --> channel : "C", sender : "Alice"
N0 --> 2
I0 --> 1
N --> 0
SL --> (nil).StringList
SL0 --> "0" mts
BL --> true false
B0 --> false
N1 --> 0
*********** solving condition fragment
allTrue(BL) or B0 and lastConsecutiveTrue(BL) >= N1 = true
*********** equation
eq allTrue(B BL) = allTrue(BL) and allTrue(B) .
B --> true
BL --> false
allTrue(true false)
--->
allTrue(false) and allTrue(true)
*********** equation
eq allTrue(B) = B .
B --> false
allTrue(false)
--->
false
*********** equation
eq allTrue(B) = B .
B --> true
allTrue(true)
--->
true
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> false
true and false
--->
false
*********** equation
eq lastConsecutiveTrue(BL) = if BL == (nil).BoolList or head(BL) == false then
    -1 else 1 + lastConsecutiveTrue(tail(BL)) fi .
BL --> true false
lastConsecutiveTrue(true false)
--->
if true false == (nil).BoolList or head(true false) == false then -1 else 1 +
    lastConsecutiveTrue(tail(true false)) fi
*********** equation
(built-in equation for symbol _==_)
true false == (nil).BoolList
--->
false
*********** equation
eq head(E:Bool L:BoolList) = E:Bool .
E:Bool --> true
L:BoolList --> false
head(true false)
--->
true
*********** equation
(built-in equation for symbol _==_)
true == false
--->
false
*********** equation
eq A:Bool or B = A:Bool and B xor A:Bool xor B .
A:Bool --> false
B --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then -1 else 1 + lastConsecutiveTrue(tail(true false)) fi
--->
1 + lastConsecutiveTrue(tail(true false))
*********** equation
eq tail(E:Bool L:BoolList) = L:BoolList .
E:Bool --> true
L:BoolList --> false
tail(true false)
--->
false
*********** equation
eq lastConsecutiveTrue(BL) = if BL == (nil).BoolList or head(BL) == false then
    -1 else 1 + lastConsecutiveTrue(tail(BL)) fi .
BL --> false
lastConsecutiveTrue(false)
--->
if false == (nil).BoolList or head(false) == false then -1 else 1 +
    lastConsecutiveTrue(tail(false)) fi
*********** equation
(built-in equation for symbol _==_)
false == (nil).BoolList
--->
false
*********** equation
eq head(E:Bool L:BoolList) = E:Bool .
E:Bool --> false
L:BoolList --> (nil).BoolList
head(false)
--->
false
*********** equation
(built-in equation for symbol _==_)
false == false
--->
true
*********** equation
eq A:Bool or B = A:Bool and B xor A:Bool xor B .
A:Bool --> false
B --> true
true or false
--->
false and true xor false xor true
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> false
true and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> true
true xor false
--->
true
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> true
true xor false
--->
true
*********** equation
(built-in equation for symbol if_then_else_fi)
if true then -1 else 1 + lastConsecutiveTrue(tail(false)) fi
--->
-1
*********** equation
(built-in equation for symbol _+_)
1 + -1
--->
0
*********** equation
(built-in equation for symbol _>=_)
0 >= 0
--->
true
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> false
true and false
--->
false
*********** equation
eq A:Bool or B = A:Bool and B xor A:Bool xor B .
A:Bool --> false
B --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** failure for condition fragment
allTrue(BL) or B0 and lastConsecutiveTrue(BL) >= N1 = true
*********** failure #12
*********** trial #13
crl < O : V:Channel | Atts:AttributeSet, msgs : ML, count : N > => (ML[random(
    N) rem size(ML)]) < O : V:Channel | Atts:AttributeSet, msgs : pop(ML,
    random(N) rem size(ML)), count : (N + 1) > if size(ML) > 0 = true [label
    convey-msg] .
O --> "C"
V:Channel --> Channel
Atts:AttributeSet --> (none).AttributeSet
ML --> msg "1" withSeqNo 2 from "Alice" to "Bob"
N --> 3
*********** solving condition fragment
size(ML) > 0 = true
*********** equation
eq size(T) = if T == Mnil then 0 else 1 + size(tail(T)) fi .
T --> msg "1" withSeqNo 2 from "Alice" to "Bob"
size(msg "1" withSeqNo 2 from "Alice" to "Bob")
--->
if msg "1" withSeqNo 2 from "Alice" to "Bob" == Mnil then 0 else 1 + size(tail(
    msg "1" withSeqNo 2 from "Alice" to "Bob")) fi
*********** equation
(built-in equation for symbol _==_)
msg "1" withSeqNo 2 from "Alice" to "Bob" == Mnil
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then 0 else 1 + size(tail(msg "1" withSeqNo 2 from "Alice" to "Bob"))
    fi
--->
1 + size(tail(msg "1" withSeqNo 2 from "Alice" to "Bob"))
*********** equation
eq tail(H ++ T) = T .
H --> msg "1" withSeqNo 2 from "Alice" to "Bob"
T --> Mnil
tail(msg "1" withSeqNo 2 from "Alice" to "Bob")
--->
Mnil
*********** equation
eq size(T) = if T == Mnil then 0 else 1 + size(tail(T)) fi .
T --> Mnil
size(Mnil)
--->
if Mnil == Mnil then 0 else 1 + size(tail(Mnil)) fi
*********** equation
(built-in equation for symbol _==_)
Mnil == Mnil
--->
true
*********** equation
(built-in equation for symbol if_then_else_fi)
if true then 0 else 1 + size(tail(Mnil)) fi
--->
0
*********** equation
(built-in equation for symbol _+_)
0 + 1
--->
1
*********** equation
(built-in equation for symbol _>_)
1 > 0
--->
true
*********** success for condition fragment
size(ML) > 0 = true
O --> "C"
V:Channel --> Channel
Atts:AttributeSet --> (none).AttributeSet
ML --> msg "1" withSeqNo 2 from "Alice" to "Bob"
N --> 3
*********** success #13
*********** rule
crl < O : V:Channel | Atts:AttributeSet, msgs : ML, count : N > => (ML[random(
    N) rem size(ML)]) < O : V:Channel | Atts:AttributeSet, msgs : pop(ML,
    random(N) rem size(ML)), count : (N + 1) > if size(ML) > 0 = true [label
    convey-msg] .
O --> "C"
V:Channel --> Channel
Atts:AttributeSet --> (none).AttributeSet
ML --> msg "1" withSeqNo 2 from "Alice" to "Bob"
N --> 3
< "C" : Channel | msgs : msg "1" withSeqNo 2 from "Alice" to "Bob", count : 3 >
--->
(msg "1" withSeqNo 2 from "Alice" to "Bob"[random(3) rem 1]) < "C" : Channel |
    none, msgs : pop(msg "1" withSeqNo 2 from "Alice" to "Bob",random(3) rem
    1), count : (3 + 1) >
*********** equation
(built-in equation for symbol random)
random(3)
--->
3626093760
*********** equation
(built-in equation for symbol _rem_)
3626093760 rem 1
--->
0
*********** equation
eq T[N] = if N <= 0 then if N == 0 then head(T) else Mnil fi else tail(T)[N -
    1] fi .
T --> msg "1" withSeqNo 2 from "Alice" to "Bob"
N --> 0
msg "1" withSeqNo 2 from "Alice" to "Bob"[0]
--->
if 0 <= 0 then if 0 == 0 then head(msg "1" withSeqNo 2 from "Alice" to "Bob")
    else Mnil fi else tail(msg "1" withSeqNo 2 from "Alice" to "Bob")[0 - 1] fi
*********** equation
(built-in equation for symbol _<=_)
0 <= 0
--->
true
*********** equation
(built-in equation for symbol if_then_else_fi)
if true then if 0 == 0 then head(msg "1" withSeqNo 2 from "Alice" to "Bob")
    else Mnil fi else tail(msg "1" withSeqNo 2 from "Alice" to "Bob")[0 - 1] fi
--->
if 0 == 0 then head(msg "1" withSeqNo 2 from "Alice" to "Bob") else Mnil fi
*********** equation
(built-in equation for symbol _==_)
0 == 0
--->
true
*********** equation
(built-in equation for symbol if_then_else_fi)
if true then head(msg "1" withSeqNo 2 from "Alice" to "Bob") else Mnil fi
--->
head(msg "1" withSeqNo 2 from "Alice" to "Bob")
*********** equation
eq head(H ++ T) = H .
H --> msg "1" withSeqNo 2 from "Alice" to "Bob"
T --> Mnil
head(msg "1" withSeqNo 2 from "Alice" to "Bob")
--->
msg "1" withSeqNo 2 from "Alice" to "Bob"
*********** equation
eq pop(T,N) = if N == 0 then tail(T) else head(T) ++ pop(tail(T),N - 1) fi .
T --> msg "1" withSeqNo 2 from "Alice" to "Bob"
N --> 0
pop(msg "1" withSeqNo 2 from "Alice" to "Bob",0)
--->
if 0 == 0 then tail(msg "1" withSeqNo 2 from "Alice" to "Bob") else head(msg
    "1" withSeqNo 2 from "Alice" to "Bob") ++ pop(tail(msg "1" withSeqNo 2 from
    "Alice" to "Bob"),0 - 1) fi
*********** equation
(built-in equation for symbol _==_)
0 == 0
--->
true
*********** equation
(built-in equation for symbol if_then_else_fi)
if true then tail(msg "1" withSeqNo 2 from "Alice" to "Bob") else head(msg "1"
    withSeqNo 2 from "Alice" to "Bob") ++ pop(tail(msg "1" withSeqNo 2 from
    "Alice" to "Bob"),0 - 1) fi
--->
tail(msg "1" withSeqNo 2 from "Alice" to "Bob")
*********** equation
eq tail(H ++ T) = T .
H --> msg "1" withSeqNo 2 from "Alice" to "Bob"
T --> Mnil
tail(msg "1" withSeqNo 2 from "Alice" to "Bob")
--->
Mnil
*********** equation
(built-in equation for symbol _+_)
1 + 3
--->
4
*********** trial #14
crl < O : V:Sender | Atts:AttributeSet, sendBuffer : ML, numWordsInBuffer : N',
    finishSend : B, bufferSize : N0, actionCount : I0 > < O' : V2:Channel |
    Atts2:AttributeSet, msgs : ML0, count : N > => < O : V:Sender |
    Atts:AttributeSet, sendBuffer : Mnil, numWordsInBuffer : 0, finishSend : B,
    bufferSize : N0, actionCount : (I0 + 1) > < O' : V2:Channel |
    Atts2:AttributeSet, msgs : (ML0 ++ ML), count : (N + 1) > if B and size(ML)
    > 0 or N' == N0 = true [label sendCurrentMsgs] .
O --> "Alice"
V:Sender --> Sender
Atts:AttributeSet --> msgsToSend : ("2" EOF), currentSeqNo : 2, receiver :
    "Bob", ackBuffer : (false false), channel : "C", bufferStart : 1
ML --> Mnil
N' --> 0
B --> false
N0 --> 2
I0 --> 4
O' --> "C"
V2:Channel --> Channel
Atts2:AttributeSet --> (none).AttributeSet
ML0 --> Mnil
N --> 4
*********** solving condition fragment
B and size(ML) > 0 or N' == N0 = true
*********** equation
eq size(T) = if T == Mnil then 0 else 1 + size(tail(T)) fi .
T --> Mnil
size(Mnil)
--->
if Mnil == Mnil then 0 else 1 + size(tail(Mnil)) fi
*********** equation
(built-in equation for symbol _==_)
Mnil == Mnil
--->
true
*********** equation
(built-in equation for symbol if_then_else_fi)
if true then 0 else 1 + size(tail(Mnil)) fi
--->
0
*********** equation
(built-in equation for symbol _>_)
0 > 0
--->
false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
(built-in equation for symbol _==_)
0 == 2
--->
false
*********** equation
eq A:Bool or B = A:Bool and B xor A:Bool xor B .
A:Bool --> false
B --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** failure for condition fragment
B and size(ML) > 0 or N' == N0 = true
*********** failure #14
*********** trial #15
crl < O : V:Sender | Atts:AttributeSet, ackBuffer : AckL, bufferStart : N0 >
    msg ack withSeqNo N from O' to O => < O : V:Sender | Atts:AttributeSet,
    ackBuffer : assign(AckL,0 : N - N0,true), bufferStart : N0 > if s N > N0 =
    true [label rcvNewAck] .
O --> "Alice"
V:Sender --> Sender
Atts:AttributeSet --> msgsToSend : ("2" EOF), sendBuffer : Mnil, currentSeqNo :
    2, receiver : "Bob", numWordsInBuffer : 0, finishSend : false, channel :
    "C", bufferSize : 2, actionCount : 4
AckL --> false false
N0 --> 1
N --> 1
O' --> "Bob"
*********** solving condition fragment
s N > N0 = true
*********** equation
(built-in equation for symbol _>_)
2 > 1
--->
true
*********** success for condition fragment
s N > N0 = true
O --> "Alice"
V:Sender --> Sender
Atts:AttributeSet --> msgsToSend : ("2" EOF), sendBuffer : Mnil, currentSeqNo :
    2, receiver : "Bob", numWordsInBuffer : 0, finishSend : false, channel :
    "C", bufferSize : 2, actionCount : 4
AckL --> false false
N0 --> 1
N --> 1
O' --> "Bob"
*********** success #15
*********** rule
crl < O : V:Sender | Atts:AttributeSet, ackBuffer : AckL, bufferStart : N0 >
    msg ack withSeqNo N from O' to O => < O : V:Sender | Atts:AttributeSet,
    ackBuffer : assign(AckL,0 : N - N0,true), bufferStart : N0 > if s N > N0 =
    true [label rcvNewAck] .
O --> "Alice"
V:Sender --> Sender
Atts:AttributeSet --> msgsToSend : ("2" EOF), sendBuffer : Mnil, currentSeqNo :
    2, receiver : "Bob", numWordsInBuffer : 0, finishSend : false, channel :
    "C", bufferSize : 2, actionCount : 4
AckL --> false false
N0 --> 1
N --> 1
O' --> "Bob"
< "Alice" : Sender | msgsToSend : ("2" EOF), sendBuffer : Mnil, currentSeqNo :
    2, receiver : "Bob", ackBuffer : (false false), numWordsInBuffer : 0,
    finishSend : false, channel : "C", bufferSize : 2, bufferStart : 1,
    actionCount : 4 > < "Bob" : Receiver | channel : "C", bufferSize : 2,
    bufferStart : 1, greatestSeqNoRcvd : 0, sender : "Alice", msgsRcvd : nil,
    rcvBuffer : ("0" mts), rcvCheck : (true false), rcvEOF : false, EOFPos : 0
    > < "C" : Channel | msgs : Mnil, count : 4 > (msg "1" withSeqNo 2 from
    "Alice" to "Bob") msg ack withSeqNo 1 from "Bob" to "Alice"
--->
(< "Bob" : Receiver | channel : "C", bufferSize : 2, bufferStart : 1,
    greatestSeqNoRcvd : 0, sender : "Alice", msgsRcvd : nil, rcvBuffer : ("0"
    mts), rcvCheck : (true false), rcvEOF : false, EOFPos : 0 > < "C" : Channel
    | msgs : Mnil, count : 4 > msg "1" withSeqNo 2 from "Alice" to "Bob") <
    "Alice" : Sender | (msgsToSend : ("2" EOF), sendBuffer : Mnil, currentSeqNo
    : 2, receiver : "Bob", numWordsInBuffer : 0, finishSend : false, channel :
    "C", bufferSize : 2, actionCount : 4), ackBuffer : assign(false false,0 : 1
    - 1,true), bufferStart : 1 >
*********** equation
(built-in equation for symbol _-_)
1 - 1
--->
0
*********** equation
eq assign(BL,N:Int : N':Int,B) = if (N:Int > N':Int or N':Int >= size(BL)) or
    N:Int < 0 then BL else if N:Int == 0 then B assign(tail(BL),0 : N':Int - 1,
    B) else head(BL) assign(tail(BL),N:Int - 1 : N':Int - 1,B) fi fi .
BL --> false false
N:Int --> 0
N':Int --> 0
B --> true
assign(false false,0 : 0,true)
--->
if (0 > 0 or 0 >= size(false false)) or 0 < 0 then false false else if 0 == 0
    then true assign(tail(false false),0 : 0 - 1,true) else head(false false)
    assign(tail(false false),0 - 1 : 0 - 1,true) fi fi
*********** equation
(built-in equation for symbol _>_)
0 > 0
--->
false
*********** equation
eq size(L:BoolList) = $size(L:BoolList, 0) .
L:BoolList --> false false
size(false false)
--->
$size(false false, 0)
*********** equation
eq $size(E:Bool L:BoolList, C:Nat) = $size(L:BoolList, C:Nat + 1) .
E:Bool --> false
L:BoolList --> false
C:Nat --> 0
$size(false false, 0)
--->
$size(false, 0 + 1)
*********** equation
(built-in equation for symbol _+_)
0 + 1
--->
1
*********** equation
eq $size(E:Bool L:BoolList, C:Nat) = $size(L:BoolList, C:Nat + 1) .
E:Bool --> false
L:BoolList --> (nil).BoolList
C:Nat --> 1
$size(false, 1)
--->
$size((nil).BoolList, 1 + 1)
*********** equation
(built-in equation for symbol _+_)
1 + 1
--->
2
*********** equation
eq $size((nil).BoolList, C:Nat) = C:Nat .
C:Nat --> 2
$size((nil).BoolList, 2)
--->
2
*********** equation
(built-in equation for symbol _>=_)
0 >= 2
--->
false
*********** equation
eq A:Bool or B = A:Bool and B xor A:Bool xor B .
A:Bool --> false
B --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
(built-in equation for symbol _<_)
0 < 0
--->
false
*********** equation
eq A:Bool or B = A:Bool and B xor A:Bool xor B .
A:Bool --> false
B --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then false false else if 0 == 0 then true assign(tail(false false),0 :
    0 - 1,true) else head(false false) assign(tail(false false),0 - 1 : 0 - 1,
    true) fi fi
--->
if 0 == 0 then true assign(tail(false false),0 : 0 - 1,true) else head(false
    false) assign(tail(false false),0 - 1 : 0 - 1,true) fi
*********** equation
(built-in equation for symbol _==_)
0 == 0
--->
true
*********** equation
(built-in equation for symbol if_then_else_fi)
if true then true assign(tail(false false),0 : 0 - 1,true) else head(false
    false) assign(tail(false false),0 - 1 : 0 - 1,true) fi
--->
true assign(tail(false false),0 : 0 - 1,true)
*********** equation
eq tail(E:Bool L:BoolList) = L:BoolList .
E:Bool --> false
L:BoolList --> false
tail(false false)
--->
false
*********** equation
(built-in equation for symbol _-_)
0 - 1
--->
-1
*********** equation
eq assign(BL,N:Int : N':Int,B) = if (N:Int > N':Int or N':Int >= size(BL)) or
    N:Int < 0 then BL else if N:Int == 0 then B assign(tail(BL),0 : N':Int - 1,
    B) else head(BL) assign(tail(BL),N:Int - 1 : N':Int - 1,B) fi fi .
BL --> false
N:Int --> 0
N':Int --> -1
B --> true
assign(false,0 : -1,true)
--->
if (0 > -1 or -1 >= size(false)) or 0 < 0 then false else if 0 == 0 then true
    assign(tail(false),0 : -1 - 1,true) else head(false) assign(tail(false),0 -
    1 : -1 - 1,true) fi fi
*********** equation
(built-in equation for symbol _>_)
0 > -1
--->
true
*********** equation
eq size(L:BoolList) = $size(L:BoolList, 0) .
L:BoolList --> false
size(false)
--->
$size(false, 0)
*********** equation
eq $size(E:Bool L:BoolList, C:Nat) = $size(L:BoolList, C:Nat + 1) .
E:Bool --> false
L:BoolList --> (nil).BoolList
C:Nat --> 0
$size(false, 0)
--->
$size((nil).BoolList, 0 + 1)
*********** equation
(built-in equation for symbol _+_)
0 + 1
--->
1
*********** equation
eq $size((nil).BoolList, C:Nat) = C:Nat .
C:Nat --> 1
$size((nil).BoolList, 1)
--->
1
*********** equation
(built-in equation for symbol _>=_)
-1 >= 1
--->
false
*********** equation
eq A:Bool or B = A:Bool and B xor A:Bool xor B .
A:Bool --> false
B --> true
true or false
--->
false and true xor false xor true
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> false
true and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> true
true xor false
--->
true
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> true
true xor false
--->
true
*********** equation
(built-in equation for symbol _<_)
0 < 0
--->
false
*********** equation
eq A:Bool or B = A:Bool and B xor A:Bool xor B .
A:Bool --> false
B --> true
true or false
--->
false and true xor false xor true
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> false
true and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> true
true xor false
--->
true
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> true
true xor false
--->
true
*********** equation
(built-in equation for symbol if_then_else_fi)
if true then false else if 0 == 0 then true assign(tail(false),0 : -1 - 1,true)
    else head(false) assign(tail(false),0 - 1 : -1 - 1,true) fi fi
--->
false
*********** trial #16
crl < O : V:Sender | Atts:AttributeSet, msgsToSend : (S SL), sendBuffer : ML,
    currentSeqNo : N', receiver : O', ackBuffer : AckL, numWordsInBuffer : N,
    finishSend : B, bufferSize : N0, bufferStart : I, actionCount : I0 > => < O
    : V:Sender | Atts:AttributeSet, msgsToSend : SL, sendBuffer : ((msg S
    withSeqNo s N' from O to O') ++ ML), currentSeqNo : s N', receiver : O',
    ackBuffer : n N0 false, numWordsInBuffer : s N, finishSend : B, bufferSize
    : N0, bufferStart : (I + 1), actionCount : (I0 + 1) > if not B and (
    allTrue(AckL) and N == 0 or N < N0 and N > 0) = true [label load_word] .
O --> "Alice"
V:Sender --> Sender
Atts:AttributeSet --> channel : "C"
S --> "2"
SL --> EOF
ML --> Mnil
N' --> 2
O' --> "Bob"
AckL --> true false
N --> 0
B --> false
N0 --> 2
I --> 1
I0 --> 4
*********** solving condition fragment
not B and (allTrue(AckL) and N == 0 or N < N0 and N > 0) = true
*********** equation
eq not A:Bool = true xor A:Bool .
A:Bool --> false
not false
--->
true xor false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> true
true xor false
--->
true
*********** equation
eq allTrue(B BL) = allTrue(BL) and allTrue(B) .
B --> true
BL --> false
allTrue(true false)
--->
allTrue(false) and allTrue(true)
*********** equation
eq allTrue(B) = B .
B --> false
allTrue(false)
--->
false
*********** equation
eq allTrue(B) = B .
B --> true
allTrue(true)
--->
true
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> false
true and false
--->
false
*********** equation
(built-in equation for symbol _==_)
0 == 0
--->
true
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> false
true and false
--->
false
*********** equation
(built-in equation for symbol _<_)
0 < 2
--->
true
*********** equation
(built-in equation for symbol _>_)
0 > 0
--->
false
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> false
true and false
--->
false
*********** equation
eq A:Bool or B = A:Bool and B xor A:Bool xor B .
A:Bool --> false
B --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> false
true and false
--->
false
*********** failure for condition fragment
not B and (allTrue(AckL) and N == 0 or N < N0 and N > 0) = true
*********** failure #16
*********** trial #17
crl < O : V:Channel | Atts:AttributeSet, msgs : ML, count : N > => (ML[random(
    N) rem size(ML)]) < O : V:Channel | Atts:AttributeSet, msgs : pop(ML,
    random(N) rem size(ML)), count : (N + 1) > if size(ML) > 0 = true [label
    convey-msg] .
O --> "C"
V:Channel --> Channel
Atts:AttributeSet --> (none).AttributeSet
ML --> Mnil
N --> 4
*********** solving condition fragment
size(ML) > 0 = true
*********** equation
eq size(T) = if T == Mnil then 0 else 1 + size(tail(T)) fi .
T --> Mnil
size(Mnil)
--->
if Mnil == Mnil then 0 else 1 + size(tail(Mnil)) fi
*********** equation
(built-in equation for symbol _==_)
Mnil == Mnil
--->
true
*********** equation
(built-in equation for symbol if_then_else_fi)
if true then 0 else 1 + size(tail(Mnil)) fi
--->
0
*********** equation
(built-in equation for symbol _>_)
0 > 0
--->
false
*********** failure for condition fragment
size(ML) > 0 = true
*********** failure #17
*********** trial #18
crl < O : V:Receiver | Atts:AttributeSet, greatestSeqNoRcvd : N' > msg S
    withSeqNo N from O' to O => < O : V:Receiver | Atts:AttributeSet,
    greatestSeqNoRcvd : N' > msg ack withSeqNo N' from O to O' if N <= N' =
    true [label rcvOldPacket] .
O --> "Bob"
V:Receiver --> Receiver
Atts:AttributeSet --> channel : "C", bufferSize : 2, bufferStart : 1, sender :
    "Alice", msgsRcvd : nil, rcvBuffer : ("0" mts), rcvCheck : (true false),
    rcvEOF : false, EOFPos : 0
N' --> 0
S --> "1"
N --> 2
O' --> "Alice"
*********** solving condition fragment
N <= N' = true
*********** equation
(built-in equation for symbol _<=_)
2 <= 0
--->
false
*********** failure for condition fragment
N <= N' = true
*********** failure #18
*********** trial #19
crl < O : V:Receiver | Atts:AttributeSet, bufferSize : N1, bufferStart : N0,
    greatestSeqNoRcvd : N', rcvBuffer : SL, rcvCheck : BL > < O2 : V2:Channel |
    Atts2:AttributeSet, count : N2 > msg S withSeqNo N from O' to O => (< O2 :
    V2:Channel | Atts2:AttributeSet, count : s N2 > msg ack withSeqNo N0 +
    lastConsecutiveTrue(assign(BL,N - N0,true)) from O to O') < O : V:Receiver
    | Atts:AttributeSet, bufferSize : N1, bufferStart : N0, greatestSeqNoRcvd :
    N', rcvBuffer : assign(SL,N - N0,S), rcvCheck : assign(BL,N - N0,true) > if
    N >= N' = true /\ N < N0 + N1 = true /\ not S == EOF = true [label
    rcvNewPacket] .
O --> "Bob"
V:Receiver --> Receiver
Atts:AttributeSet --> channel : "C", sender : "Alice", msgsRcvd : nil, rcvEOF :
    false, EOFPos : 0
N1 --> 2
N0 --> 1
N' --> 0
SL --> "0" mts
BL --> true false
O2 --> "C"
V2:Channel --> Channel
Atts2:AttributeSet --> msgs : Mnil
N2 --> 4
S --> "1"
N --> 2
O' --> "Alice"
*********** solving condition fragment
N >= N' = true
*********** equation
(built-in equation for symbol _>=_)
2 >= 0
--->
true
*********** success for condition fragment
N >= N' = true
O --> "Bob"
V:Receiver --> Receiver
Atts:AttributeSet --> channel : "C", sender : "Alice", msgsRcvd : nil, rcvEOF :
    false, EOFPos : 0
N1 --> 2
N0 --> 1
N' --> 0
SL --> "0" mts
BL --> true false
O2 --> "C"
V2:Channel --> Channel
Atts2:AttributeSet --> msgs : Mnil
N2 --> 4
S --> "1"
N --> 2
O' --> "Alice"
*********** solving condition fragment
N < N0 + N1 = true
*********** equation
(built-in equation for symbol _+_)
1 + 2
--->
3
*********** equation
(built-in equation for symbol _<_)
2 < 3
--->
true
*********** success for condition fragment
N < N0 + N1 = true
O --> "Bob"
V:Receiver --> Receiver
Atts:AttributeSet --> channel : "C", sender : "Alice", msgsRcvd : nil, rcvEOF :
    false, EOFPos : 0
N1 --> 2
N0 --> 1
N' --> 0
SL --> "0" mts
BL --> true false
O2 --> "C"
V2:Channel --> Channel
Atts2:AttributeSet --> msgs : Mnil
N2 --> 4
S --> "1"
N --> 2
O' --> "Alice"
*********** solving condition fragment
not S == EOF = true
*********** equation
(built-in equation for symbol _==_)
"1" == EOF
--->
false
*********** equation
eq not A:Bool = true xor A:Bool .
A:Bool --> false
not false
--->
true xor false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> true
true xor false
--->
true
*********** success for condition fragment
not S == EOF = true
O --> "Bob"
V:Receiver --> Receiver
Atts:AttributeSet --> channel : "C", sender : "Alice", msgsRcvd : nil, rcvEOF :
    false, EOFPos : 0
N1 --> 2
N0 --> 1
N' --> 0
SL --> "0" mts
BL --> true false
O2 --> "C"
V2:Channel --> Channel
Atts2:AttributeSet --> msgs : Mnil
N2 --> 4
S --> "1"
N --> 2
O' --> "Alice"
*********** success #19
*********** rule
crl < O : V:Receiver | Atts:AttributeSet, bufferSize : N1, bufferStart : N0,
    greatestSeqNoRcvd : N', rcvBuffer : SL, rcvCheck : BL > < O2 : V2:Channel |
    Atts2:AttributeSet, count : N2 > msg S withSeqNo N from O' to O => (< O2 :
    V2:Channel | Atts2:AttributeSet, count : s N2 > msg ack withSeqNo N0 +
    lastConsecutiveTrue(assign(BL,N - N0,true)) from O to O') < O : V:Receiver
    | Atts:AttributeSet, bufferSize : N1, bufferStart : N0, greatestSeqNoRcvd :
    N', rcvBuffer : assign(SL,N - N0,S), rcvCheck : assign(BL,N - N0,true) > if
    N >= N' = true /\ N < N0 + N1 = true /\ not S == EOF = true [label
    rcvNewPacket] .
O --> "Bob"
V:Receiver --> Receiver
Atts:AttributeSet --> channel : "C", sender : "Alice", msgsRcvd : nil, rcvEOF :
    false, EOFPos : 0
N1 --> 2
N0 --> 1
N' --> 0
SL --> "0" mts
BL --> true false
O2 --> "C"
V2:Channel --> Channel
Atts2:AttributeSet --> msgs : Mnil
N2 --> 4
S --> "1"
N --> 2
O' --> "Alice"
< "Alice" : Sender | msgsToSend : ("2" EOF), sendBuffer : Mnil, currentSeqNo :
    2, receiver : "Bob", ackBuffer : (true false), numWordsInBuffer : 0,
    finishSend : false, channel : "C", bufferSize : 2, bufferStart : 1,
    actionCount : 4 > < "Bob" : Receiver | channel : "C", bufferSize : 2,
    bufferStart : 1, greatestSeqNoRcvd : 0, sender : "Alice", msgsRcvd : nil,
    rcvBuffer : ("0" mts), rcvCheck : (true false), rcvEOF : false, EOFPos : 0
    > < "C" : Channel | msgs : Mnil, count : 4 > msg "1" withSeqNo 2 from
    "Alice" to "Bob"
--->
< "Alice" : Sender | msgsToSend : ("2" EOF), sendBuffer : Mnil, currentSeqNo :
    2, receiver : "Bob", ackBuffer : (true false), numWordsInBuffer : 0,
    finishSend : false, channel : "C", bufferSize : 2, bufferStart : 1,
    actionCount : 4 > (< "C" : Channel | msgs : Mnil, count : s 4 > msg ack
    withSeqNo 1 + lastConsecutiveTrue(assign(true false,2 - 1,true)) from "Bob"
    to "Alice") < "Bob" : Receiver | (channel : "C", sender : "Alice", msgsRcvd
    : nil, rcvEOF : false, EOFPos : 0), bufferSize : 2, bufferStart : 1,
    greatestSeqNoRcvd : 0, rcvBuffer : assign("0" mts,2 - 1,"1"), rcvCheck :
    assign(true false,2 - 1,true) >
*********** equation
(built-in equation for symbol _-_)
2 - 1
--->
1
*********** equation
eq assign(BL,N:Int,B) = if N:Int < 0 or N:Int >= size(BL) then BL else if N:Int
    == 0 then B tail(BL) else head(BL) assign(tail(BL),N:Int - 1,B) fi fi .
BL --> true false
N:Int --> 1
B --> true
assign(true false,1,true)
--->
if 1 < 0 or 1 >= size(true false) then true false else if 1 == 0 then true
    tail(true false) else head(true false) assign(tail(true false),1 - 1,true)
    fi fi
*********** equation
(built-in equation for symbol _<_)
1 < 0
--->
false
*********** equation
eq size(L:BoolList) = $size(L:BoolList, 0) .
L:BoolList --> true false
size(true false)
--->
$size(true false, 0)
*********** equation
eq $size(E:Bool L:BoolList, C:Nat) = $size(L:BoolList, C:Nat + 1) .
E:Bool --> true
L:BoolList --> false
C:Nat --> 0
$size(true false, 0)
--->
$size(false, 0 + 1)
*********** equation
(built-in equation for symbol _+_)
0 + 1
--->
1
*********** equation
eq $size(E:Bool L:BoolList, C:Nat) = $size(L:BoolList, C:Nat + 1) .
E:Bool --> false
L:BoolList --> (nil).BoolList
C:Nat --> 1
$size(false, 1)
--->
$size((nil).BoolList, 1 + 1)
*********** equation
(built-in equation for symbol _+_)
1 + 1
--->
2
*********** equation
eq $size((nil).BoolList, C:Nat) = C:Nat .
C:Nat --> 2
$size((nil).BoolList, 2)
--->
2
*********** equation
(built-in equation for symbol _>=_)
1 >= 2
--->
false
*********** equation
eq A:Bool or B = A:Bool and B xor A:Bool xor B .
A:Bool --> false
B --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then true false else if 1 == 0 then true tail(true false) else head(
    true false) assign(tail(true false),1 - 1,true) fi fi
--->
if 1 == 0 then true tail(true false) else head(true false) assign(tail(true
    false),1 - 1,true) fi
*********** equation
(built-in equation for symbol _==_)
1 == 0
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then true tail(true false) else head(true false) assign(tail(true
    false),1 - 1,true) fi
--->
head(true false) assign(tail(true false),1 - 1,true)
*********** equation
eq head(E:Bool L:BoolList) = E:Bool .
E:Bool --> true
L:BoolList --> false
head(true false)
--->
true
*********** equation
eq tail(E:Bool L:BoolList) = L:BoolList .
E:Bool --> true
L:BoolList --> false
tail(true false)
--->
false
*********** equation
(built-in equation for symbol _-_)
1 - 1
--->
0
*********** equation
eq assign(BL,N:Int,B) = if N:Int < 0 or N:Int >= size(BL) then BL else if N:Int
    == 0 then B tail(BL) else head(BL) assign(tail(BL),N:Int - 1,B) fi fi .
BL --> false
N:Int --> 0
B --> true
assign(false,0,true)
--->
if 0 < 0 or 0 >= size(false) then false else if 0 == 0 then true tail(false)
    else head(false) assign(tail(false),0 - 1,true) fi fi
*********** equation
(built-in equation for symbol _<_)
0 < 0
--->
false
*********** equation
eq size(L:BoolList) = $size(L:BoolList, 0) .
L:BoolList --> false
size(false)
--->
$size(false, 0)
*********** equation
eq $size(E:Bool L:BoolList, C:Nat) = $size(L:BoolList, C:Nat + 1) .
E:Bool --> false
L:BoolList --> (nil).BoolList
C:Nat --> 0
$size(false, 0)
--->
$size((nil).BoolList, 0 + 1)
*********** equation
(built-in equation for symbol _+_)
0 + 1
--->
1
*********** equation
eq $size((nil).BoolList, C:Nat) = C:Nat .
C:Nat --> 1
$size((nil).BoolList, 1)
--->
1
*********** equation
(built-in equation for symbol _>=_)
0 >= 1
--->
false
*********** equation
eq A:Bool or B = A:Bool and B xor A:Bool xor B .
A:Bool --> false
B --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then false else if 0 == 0 then true tail(false) else head(false)
    assign(tail(false),0 - 1,true) fi fi
--->
if 0 == 0 then true tail(false) else head(false) assign(tail(false),0 - 1,true)
    fi
*********** equation
(built-in equation for symbol _==_)
0 == 0
--->
true
*********** equation
(built-in equation for symbol if_then_else_fi)
if true then true tail(false) else head(false) assign(tail(false),0 - 1,true)
    fi
--->
true tail(false)
*********** equation
eq tail(E:Bool L:BoolList) = L:BoolList .
E:Bool --> false
L:BoolList --> (nil).BoolList
tail(false)
--->
(nil).BoolList
*********** equation
eq lastConsecutiveTrue(BL) = if BL == (nil).BoolList or head(BL) == false then
    -1 else 1 + lastConsecutiveTrue(tail(BL)) fi .
BL --> true true
lastConsecutiveTrue(true true)
--->
if true true == (nil).BoolList or head(true true) == false then -1 else 1 +
    lastConsecutiveTrue(tail(true true)) fi
*********** equation
(built-in equation for symbol _==_)
true true == (nil).BoolList
--->
false
*********** equation
eq head(E:Bool L:BoolList) = E:Bool .
E:Bool --> true
L:BoolList --> true
head(true true)
--->
true
*********** equation
(built-in equation for symbol _==_)
true == false
--->
false
*********** equation
eq A:Bool or B = A:Bool and B xor A:Bool xor B .
A:Bool --> false
B --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then -1 else 1 + lastConsecutiveTrue(tail(true true)) fi
--->
1 + lastConsecutiveTrue(tail(true true))
*********** equation
eq tail(E:Bool L:BoolList) = L:BoolList .
E:Bool --> true
L:BoolList --> true
tail(true true)
--->
true
*********** equation
eq lastConsecutiveTrue(BL) = if BL == (nil).BoolList or head(BL) == false then
    -1 else 1 + lastConsecutiveTrue(tail(BL)) fi .
BL --> true
lastConsecutiveTrue(true)
--->
if true == (nil).BoolList or head(true) == false then -1 else 1 +
    lastConsecutiveTrue(tail(true)) fi
*********** equation
(built-in equation for symbol _==_)
true == (nil).BoolList
--->
false
*********** equation
eq head(E:Bool L:BoolList) = E:Bool .
E:Bool --> true
L:BoolList --> (nil).BoolList
head(true)
--->
true
*********** equation
(built-in equation for symbol _==_)
true == false
--->
false
*********** equation
eq A:Bool or B = A:Bool and B xor A:Bool xor B .
A:Bool --> false
B --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then -1 else 1 + lastConsecutiveTrue(tail(true)) fi
--->
1 + lastConsecutiveTrue(tail(true))
*********** equation
eq tail(E:Bool L:BoolList) = L:BoolList .
E:Bool --> true
L:BoolList --> (nil).BoolList
tail(true)
--->
(nil).BoolList
*********** equation
eq lastConsecutiveTrue(BL) = if BL == (nil).BoolList or head(BL) == false then
    -1 else 1 + lastConsecutiveTrue(tail(BL)) fi .
BL --> (nil).BoolList
lastConsecutiveTrue(nil)
--->
if (nil).BoolList == (nil).BoolList or head((nil).BoolList) == false then -1
    else 1 + lastConsecutiveTrue(tail(nil)) fi
*********** equation
(built-in equation for symbol _==_)
(nil).BoolList == (nil).BoolList
--->
true
*********** equation
eq head((nil).BoolList) = (nil).BoolList .
empty substitution
head((nil).BoolList)
--->
(nil).BoolList
*********** equation
(built-in equation for symbol _==_)
(nil).BoolList == false
--->
false
*********** equation
eq A:Bool or B = A:Bool and B xor A:Bool xor B .
A:Bool --> false
B --> true
true or false
--->
false and true xor false xor true
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> false
true and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> true
true xor false
--->
true
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> true
true xor false
--->
true
*********** equation
(built-in equation for symbol if_then_else_fi)
if true then -1 else 1 + lastConsecutiveTrue(tail(nil)) fi
--->
-1
*********** equation
(built-in equation for symbol _+_)
1 + -1
--->
0
*********** equation
(built-in equation for symbol _+_)
0 + 1
--->
1
*********** equation
(built-in equation for symbol _+_)
1 + 1
--->
2
*********** equation
eq assign(SL,N:Int,S) = if N:Int < 0 or N:Int >= size(SL) then SL else if N:Int
    == 0 then S tail(SL) else head(SL) assign(tail(SL),N:Int - 1,S) fi fi .
SL --> "0" mts
N:Int --> 1
S --> "1"
assign("0" mts,1,"1")
--->
if 1 < 0 or 1 >= size("0" mts) then "0" mts else if 1 == 0 then "1" tail("0"
    mts) else head("0" mts) assign(tail("0" mts),1 - 1,"1") fi fi
*********** equation
(built-in equation for symbol _<_)
1 < 0
--->
false
*********** equation
eq size(L:StringList) = $size(L:StringList, 0) .
L:StringList --> "0" mts
size("0" mts)
--->
$size("0" mts, 0)
*********** equation
eq $size(E:String L:StringList, C:Nat) = $size(L:StringList, C:Nat + 1) .
E:String --> "0"
L:StringList --> mts
C:Nat --> 0
$size("0" mts, 0)
--->
$size(mts, 0 + 1)
*********** equation
(built-in equation for symbol _+_)
0 + 1
--->
1
*********** equation
eq $size(E:String L:StringList, C:Nat) = $size(L:StringList, C:Nat + 1) .
E:String --> mts
L:StringList --> (nil).StringList
C:Nat --> 1
$size(mts, 1)
--->
$size((nil).StringList, 1 + 1)
*********** equation
(built-in equation for symbol _+_)
1 + 1
--->
2
*********** equation
eq $size((nil).StringList, C:Nat) = C:Nat .
C:Nat --> 2
$size((nil).StringList, 2)
--->
2
*********** equation
(built-in equation for symbol _>=_)
1 >= 2
--->
false
*********** equation
eq A:Bool or B = A:Bool and B xor A:Bool xor B .
A:Bool --> false
B --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then "0" mts else if 1 == 0 then "1" tail("0" mts) else head("0" mts)
    assign(tail("0" mts),1 - 1,"1") fi fi
--->
if 1 == 0 then "1" tail("0" mts) else head("0" mts) assign(tail("0" mts),1 - 1,
    "1") fi
*********** equation
(built-in equation for symbol _==_)
1 == 0
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then "1" tail("0" mts) else head("0" mts) assign(tail("0" mts),1 - 1,
    "1") fi
--->
head("0" mts) assign(tail("0" mts),1 - 1,"1")
*********** equation
eq head(E:String L:StringList) = E:String .
E:String --> "0"
L:StringList --> mts
head("0" mts)
--->
"0"
*********** equation
eq tail(E:String L:StringList) = L:StringList .
E:String --> "0"
L:StringList --> mts
tail("0" mts)
--->
mts
*********** equation
(built-in equation for symbol _-_)
1 - 1
--->
0
*********** equation
eq assign(SL,N:Int,S) = if N:Int < 0 or N:Int >= size(SL) then SL else if N:Int
    == 0 then S tail(SL) else head(SL) assign(tail(SL),N:Int - 1,S) fi fi .
SL --> mts
N:Int --> 0
S --> "1"
assign(mts,0,"1")
--->
if 0 < 0 or 0 >= size(mts) then mts else if 0 == 0 then "1" tail(mts) else
    head(mts) assign(tail(mts),0 - 1,"1") fi fi
*********** equation
(built-in equation for symbol _<_)
0 < 0
--->
false
*********** equation
eq size(L:StringList) = $size(L:StringList, 0) .
L:StringList --> mts
size(mts)
--->
$size(mts, 0)
*********** equation
eq $size(E:String L:StringList, C:Nat) = $size(L:StringList, C:Nat + 1) .
E:String --> mts
L:StringList --> (nil).StringList
C:Nat --> 0
$size(mts, 0)
--->
$size((nil).StringList, 0 + 1)
*********** equation
(built-in equation for symbol _+_)
0 + 1
--->
1
*********** equation
eq $size((nil).StringList, C:Nat) = C:Nat .
C:Nat --> 1
$size((nil).StringList, 1)
--->
1
*********** equation
(built-in equation for symbol _>=_)
0 >= 1
--->
false
*********** equation
eq A:Bool or B = A:Bool and B xor A:Bool xor B .
A:Bool --> false
B --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then mts else if 0 == 0 then "1" tail(mts) else head(mts) assign(tail(
    mts),0 - 1,"1") fi fi
--->
if 0 == 0 then "1" tail(mts) else head(mts) assign(tail(mts),0 - 1,"1") fi
*********** equation
(built-in equation for symbol _==_)
0 == 0
--->
true
*********** equation
(built-in equation for symbol if_then_else_fi)
if true then "1" tail(mts) else head(mts) assign(tail(mts),0 - 1,"1") fi
--->
"1" tail(mts)
*********** equation
eq tail(E:String L:StringList) = L:StringList .
E:String --> mts
L:StringList --> (nil).StringList
tail(mts)
--->
(nil).StringList
*********** trial #20
crl < O : V:Receiver | Atts:AttributeSet, bufferSize : N0, bufferStart : I0,
    greatestSeqNoRcvd : N, msgsRcvd : SL, rcvBuffer : SL0, rcvCheck : BL,
    rcvEOF : B0, EOFPos : N1 > => < O : V:Receiver | Atts:AttributeSet,
    bufferSize : N0, bufferStart : (N0 + I0), greatestSeqNoRcvd : (N + N0),
    msgsRcvd : (SL SL0), rcvBuffer : n N0 mts, rcvCheck : n N0 false, rcvEOF :
    B0, EOFPos : N1 > if allTrue(BL) or B0 and lastConsecutiveTrue(BL) >= N1 =
    true [label loadWordsFromBuffer] .
O --> "Bob"
V:Receiver --> Receiver
Atts:AttributeSet --> channel : "C", sender : "Alice"
N0 --> 2
I0 --> 1
N --> 0
SL --> (nil).StringList
SL0 --> "0" "1"
BL --> true true
B0 --> false
N1 --> 0
*********** solving condition fragment
allTrue(BL) or B0 and lastConsecutiveTrue(BL) >= N1 = true
*********** equation
eq allTrue(B BL) = allTrue(BL) and allTrue(B) .
B --> true
BL --> true
allTrue(true true)
--->
allTrue(true) and allTrue(true)
*********** equation
eq allTrue(B) = B .
B --> true
allTrue(true)
--->
true
*********** equation
eq allTrue(B) = B .
B --> true
allTrue(true)
--->
true
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> true
true and true
--->
true
*********** equation
eq lastConsecutiveTrue(BL) = if BL == (nil).BoolList or head(BL) == false then
    -1 else 1 + lastConsecutiveTrue(tail(BL)) fi .
BL --> true true
lastConsecutiveTrue(true true)
--->
if true true == (nil).BoolList or head(true true) == false then -1 else 1 +
    lastConsecutiveTrue(tail(true true)) fi
*********** equation
(built-in equation for symbol _==_)
true true == (nil).BoolList
--->
false
*********** equation
eq head(E:Bool L:BoolList) = E:Bool .
E:Bool --> true
L:BoolList --> true
head(true true)
--->
true
*********** equation
(built-in equation for symbol _==_)
true == false
--->
false
*********** equation
eq A:Bool or B = A:Bool and B xor A:Bool xor B .
A:Bool --> false
B --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then -1 else 1 + lastConsecutiveTrue(tail(true true)) fi
--->
1 + lastConsecutiveTrue(tail(true true))
*********** equation
eq tail(E:Bool L:BoolList) = L:BoolList .
E:Bool --> true
L:BoolList --> true
tail(true true)
--->
true
*********** equation
eq lastConsecutiveTrue(BL) = if BL == (nil).BoolList or head(BL) == false then
    -1 else 1 + lastConsecutiveTrue(tail(BL)) fi .
BL --> true
lastConsecutiveTrue(true)
--->
if true == (nil).BoolList or head(true) == false then -1 else 1 +
    lastConsecutiveTrue(tail(true)) fi
*********** equation
(built-in equation for symbol _==_)
true == (nil).BoolList
--->
false
*********** equation
eq head(E:Bool L:BoolList) = E:Bool .
E:Bool --> true
L:BoolList --> (nil).BoolList
head(true)
--->
true
*********** equation
(built-in equation for symbol _==_)
true == false
--->
false
*********** equation
eq A:Bool or B = A:Bool and B xor A:Bool xor B .
A:Bool --> false
B --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then -1 else 1 + lastConsecutiveTrue(tail(true)) fi
--->
1 + lastConsecutiveTrue(tail(true))
*********** equation
eq tail(E:Bool L:BoolList) = L:BoolList .
E:Bool --> true
L:BoolList --> (nil).BoolList
tail(true)
--->
(nil).BoolList
*********** equation
eq lastConsecutiveTrue(BL) = if BL == (nil).BoolList or head(BL) == false then
    -1 else 1 + lastConsecutiveTrue(tail(BL)) fi .
BL --> (nil).BoolList
lastConsecutiveTrue(nil)
--->
if (nil).BoolList == (nil).BoolList or head((nil).BoolList) == false then -1
    else 1 + lastConsecutiveTrue(tail(nil)) fi
*********** equation
(built-in equation for symbol _==_)
(nil).BoolList == (nil).BoolList
--->
true
*********** equation
eq head((nil).BoolList) = (nil).BoolList .
empty substitution
head((nil).BoolList)
--->
(nil).BoolList
*********** equation
(built-in equation for symbol _==_)
(nil).BoolList == false
--->
false
*********** equation
eq A:Bool or B = A:Bool and B xor A:Bool xor B .
A:Bool --> false
B --> true
true or false
--->
false and true xor false xor true
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> false
true and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> true
true xor false
--->
true
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> true
true xor false
--->
true
*********** equation
(built-in equation for symbol if_then_else_fi)
if true then -1 else 1 + lastConsecutiveTrue(tail(nil)) fi
--->
-1
*********** equation
(built-in equation for symbol _+_)
1 + -1
--->
0
*********** equation
(built-in equation for symbol _+_)
0 + 1
--->
1
*********** equation
(built-in equation for symbol _>=_)
1 >= 0
--->
true
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> false
true and false
--->
false
*********** equation
eq A:Bool or B = A:Bool and B xor A:Bool xor B .
A:Bool --> false
B --> true
true or false
--->
false and true xor false xor true
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> false
true and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> true
true xor false
--->
true
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> true
true xor false
--->
true
*********** success for condition fragment
allTrue(BL) or B0 and lastConsecutiveTrue(BL) >= N1 = true
O --> "Bob"
V:Receiver --> Receiver
Atts:AttributeSet --> channel : "C", sender : "Alice"
N0 --> 2
I0 --> 1
N --> 0
SL --> (nil).StringList
SL0 --> "0" "1"
BL --> true true
B0 --> false
N1 --> 0
*********** success #20
*********** rule
crl < O : V:Receiver | Atts:AttributeSet, bufferSize : N0, bufferStart : I0,
    greatestSeqNoRcvd : N, msgsRcvd : SL, rcvBuffer : SL0, rcvCheck : BL,
    rcvEOF : B0, EOFPos : N1 > => < O : V:Receiver | Atts:AttributeSet,
    bufferSize : N0, bufferStart : (N0 + I0), greatestSeqNoRcvd : (N + N0),
    msgsRcvd : (SL SL0), rcvBuffer : n N0 mts, rcvCheck : n N0 false, rcvEOF :
    B0, EOFPos : N1 > if allTrue(BL) or B0 and lastConsecutiveTrue(BL) >= N1 =
    true [label loadWordsFromBuffer] .
O --> "Bob"
V:Receiver --> Receiver
Atts:AttributeSet --> channel : "C", sender : "Alice"
N0 --> 2
I0 --> 1
N --> 0
SL --> (nil).StringList
SL0 --> "0" "1"
BL --> true true
B0 --> false
N1 --> 0
< "Bob" : Receiver | channel : "C", bufferSize : 2, bufferStart : 1,
    greatestSeqNoRcvd : 0, sender : "Alice", msgsRcvd : nil, rcvBuffer : ("0"
    "1"), rcvCheck : (true true), rcvEOF : false, EOFPos : 0 >
--->
< "Bob" : Receiver | (channel : "C", sender : "Alice"), bufferSize : 2,
    bufferStart : (2 + 1), greatestSeqNoRcvd : (0 + 2), msgsRcvd : (nil "0"
    "1"), rcvBuffer : n 2 mts, rcvCheck : n 2 false, rcvEOF : false, EOFPos : 0
    >
*********** equation
(built-in equation for symbol _+_)
1 + 2
--->
3
*********** equation
(built-in equation for symbol _+_)
0 + 2
--->
2
*********** equation
eq n N:Int mts = if N:Int <= 0 then (nil).StringList else mts n N:Int - 1 mts
    fi .
N:Int --> 2
n 2 mts
--->
if 2 <= 0 then (nil).StringList else mts n 2 - 1 mts fi
*********** equation
(built-in equation for symbol _<=_)
2 <= 0
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then (nil).StringList else mts n 2 - 1 mts fi
--->
mts n 2 - 1 mts
*********** equation
(built-in equation for symbol _-_)
2 - 1
--->
1
*********** equation
eq n N:Int mts = if N:Int <= 0 then (nil).StringList else mts n N:Int - 1 mts
    fi .
N:Int --> 1
n 1 mts
--->
if 1 <= 0 then (nil).StringList else mts n 1 - 1 mts fi
*********** equation
(built-in equation for symbol _<=_)
1 <= 0
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then (nil).StringList else mts n 1 - 1 mts fi
--->
mts n 1 - 1 mts
*********** equation
(built-in equation for symbol _-_)
1 - 1
--->
0
*********** equation
eq n N:Int mts = if N:Int <= 0 then (nil).StringList else mts n N:Int - 1 mts
    fi .
N:Int --> 0
n 0 mts
--->
if 0 <= 0 then (nil).StringList else mts n 0 - 1 mts fi
*********** equation
(built-in equation for symbol _<=_)
0 <= 0
--->
true
*********** equation
(built-in equation for symbol if_then_else_fi)
if true then (nil).StringList else mts n 0 - 1 mts fi
--->
(nil).StringList
*********** equation
eq n N:Int false = if N:Int <= 0 then (nil).BoolList else false n N:Int - 1
    false fi .
N:Int --> 2
n 2 false
--->
if 2 <= 0 then (nil).BoolList else false n 2 - 1 false fi
*********** equation
(built-in equation for symbol _<=_)
2 <= 0
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then (nil).BoolList else false n 2 - 1 false fi
--->
false n 2 - 1 false
*********** equation
(built-in equation for symbol _-_)
2 - 1
--->
1
*********** equation
eq n N:Int false = if N:Int <= 0 then (nil).BoolList else false n N:Int - 1
    false fi .
N:Int --> 1
n 1 false
--->
if 1 <= 0 then (nil).BoolList else false n 1 - 1 false fi
*********** equation
(built-in equation for symbol _<=_)
1 <= 0
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then (nil).BoolList else false n 1 - 1 false fi
--->
false n 1 - 1 false
*********** equation
(built-in equation for symbol _-_)
1 - 1
--->
0
*********** equation
eq n N:Int false = if N:Int <= 0 then (nil).BoolList else false n N:Int - 1
    false fi .
N:Int --> 0
n 0 false
--->
if 0 <= 0 then (nil).BoolList else false n 0 - 1 false fi
*********** equation
(built-in equation for symbol _<=_)
0 <= 0
--->
true
*********** equation
(built-in equation for symbol if_then_else_fi)
if true then (nil).BoolList else false n 0 - 1 false fi
--->
(nil).BoolList
*********** trial #21
crl < O : V:Channel | Atts:AttributeSet, msgs : ML, count : N > => (ML[random(
    N) rem size(ML)]) < O : V:Channel | Atts:AttributeSet, msgs : pop(ML,
    random(N) rem size(ML)), count : (N + 1) > if size(ML) > 0 = true [label
    convey-msg] .
O --> "C"
V:Channel --> Channel
Atts:AttributeSet --> (none).AttributeSet
ML --> Mnil
N --> 5
*********** solving condition fragment
size(ML) > 0 = true
*********** equation
eq size(T) = if T == Mnil then 0 else 1 + size(tail(T)) fi .
T --> Mnil
size(Mnil)
--->
if Mnil == Mnil then 0 else 1 + size(tail(Mnil)) fi
*********** equation
(built-in equation for symbol _==_)
Mnil == Mnil
--->
true
*********** equation
(built-in equation for symbol if_then_else_fi)
if true then 0 else 1 + size(tail(Mnil)) fi
--->
0
*********** equation
(built-in equation for symbol _>_)
0 > 0
--->
false
*********** failure for condition fragment
size(ML) > 0 = true
*********** failure #21
*********** trial #22
crl < O : V:Sender | Atts:AttributeSet, sendBuffer : ML, numWordsInBuffer : N',
    finishSend : B, bufferSize : N0, actionCount : I0 > < O' : V2:Channel |
    Atts2:AttributeSet, msgs : ML0, count : N > => < O : V:Sender |
    Atts:AttributeSet, sendBuffer : Mnil, numWordsInBuffer : 0, finishSend : B,
    bufferSize : N0, actionCount : (I0 + 1) > < O' : V2:Channel |
    Atts2:AttributeSet, msgs : (ML0 ++ ML), count : (N + 1) > if B and size(ML)
    > 0 or N' == N0 = true [label sendCurrentMsgs] .
O --> "Alice"
V:Sender --> Sender
Atts:AttributeSet --> msgsToSend : ("2" EOF), currentSeqNo : 2, receiver :
    "Bob", ackBuffer : (true false), channel : "C", bufferStart : 1
ML --> Mnil
N' --> 0
B --> false
N0 --> 2
I0 --> 4
O' --> "C"
V2:Channel --> Channel
Atts2:AttributeSet --> (none).AttributeSet
ML0 --> Mnil
N --> 5
*********** solving condition fragment
B and size(ML) > 0 or N' == N0 = true
*********** equation
eq size(T) = if T == Mnil then 0 else 1 + size(tail(T)) fi .
T --> Mnil
size(Mnil)
--->
if Mnil == Mnil then 0 else 1 + size(tail(Mnil)) fi
*********** equation
(built-in equation for symbol _==_)
Mnil == Mnil
--->
true
*********** equation
(built-in equation for symbol if_then_else_fi)
if true then 0 else 1 + size(tail(Mnil)) fi
--->
0
*********** equation
(built-in equation for symbol _>_)
0 > 0
--->
false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
(built-in equation for symbol _==_)
0 == 2
--->
false
*********** equation
eq A:Bool or B = A:Bool and B xor A:Bool xor B .
A:Bool --> false
B --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** failure for condition fragment
B and size(ML) > 0 or N' == N0 = true
*********** failure #22
*********** trial #23
crl < O : V:Sender | Atts:AttributeSet, ackBuffer : AckL, bufferStart : N0 >
    msg ack withSeqNo N from O' to O => < O : V:Sender | Atts:AttributeSet,
    ackBuffer : assign(AckL,0 : N - N0,true), bufferStart : N0 > if s N > N0 =
    true [label rcvNewAck] .
O --> "Alice"
V:Sender --> Sender
Atts:AttributeSet --> msgsToSend : ("2" EOF), sendBuffer : Mnil, currentSeqNo :
    2, receiver : "Bob", numWordsInBuffer : 0, finishSend : false, channel :
    "C", bufferSize : 2, actionCount : 4
AckL --> true false
N0 --> 1
N --> 2
O' --> "Bob"
*********** solving condition fragment
s N > N0 = true
*********** equation
(built-in equation for symbol _>_)
3 > 1
--->
true
*********** success for condition fragment
s N > N0 = true
O --> "Alice"
V:Sender --> Sender
Atts:AttributeSet --> msgsToSend : ("2" EOF), sendBuffer : Mnil, currentSeqNo :
    2, receiver : "Bob", numWordsInBuffer : 0, finishSend : false, channel :
    "C", bufferSize : 2, actionCount : 4
AckL --> true false
N0 --> 1
N --> 2
O' --> "Bob"
*********** success #23
*********** rule
crl < O : V:Sender | Atts:AttributeSet, ackBuffer : AckL, bufferStart : N0 >
    msg ack withSeqNo N from O' to O => < O : V:Sender | Atts:AttributeSet,
    ackBuffer : assign(AckL,0 : N - N0,true), bufferStart : N0 > if s N > N0 =
    true [label rcvNewAck] .
O --> "Alice"
V:Sender --> Sender
Atts:AttributeSet --> msgsToSend : ("2" EOF), sendBuffer : Mnil, currentSeqNo :
    2, receiver : "Bob", numWordsInBuffer : 0, finishSend : false, channel :
    "C", bufferSize : 2, actionCount : 4
AckL --> true false
N0 --> 1
N --> 2
O' --> "Bob"
< "Alice" : Sender | msgsToSend : ("2" EOF), sendBuffer : Mnil, currentSeqNo :
    2, receiver : "Bob", ackBuffer : (true false), numWordsInBuffer : 0,
    finishSend : false, channel : "C", bufferSize : 2, bufferStart : 1,
    actionCount : 4 > < "Bob" : Receiver | channel : "C", bufferSize : 2,
    bufferStart : 3, greatestSeqNoRcvd : 2, sender : "Alice", msgsRcvd : ("0"
    "1"), rcvBuffer : (mts mts), rcvCheck : (false false), rcvEOF : false,
    EOFPos : 0 > < "C" : Channel | msgs : Mnil, count : 5 > msg ack withSeqNo 2
    from "Bob" to "Alice"
--->
(< "Bob" : Receiver | channel : "C", bufferSize : 2, bufferStart : 3,
    greatestSeqNoRcvd : 2, sender : "Alice", msgsRcvd : ("0" "1"), rcvBuffer :
    (mts mts), rcvCheck : (false false), rcvEOF : false, EOFPos : 0 > < "C" :
    Channel | msgs : Mnil, count : 5 >) < "Alice" : Sender | (msgsToSend : ("2"
    EOF), sendBuffer : Mnil, currentSeqNo : 2, receiver : "Bob",
    numWordsInBuffer : 0, finishSend : false, channel : "C", bufferSize : 2,
    actionCount : 4), ackBuffer : assign(true false,0 : 2 - 1,true),
    bufferStart : 1 >
*********** equation
(built-in equation for symbol _-_)
2 - 1
--->
1
*********** equation
eq assign(BL,N:Int : N':Int,B) = if (N:Int > N':Int or N':Int >= size(BL)) or
    N:Int < 0 then BL else if N:Int == 0 then B assign(tail(BL),0 : N':Int - 1,
    B) else head(BL) assign(tail(BL),N:Int - 1 : N':Int - 1,B) fi fi .
BL --> true false
N:Int --> 0
N':Int --> 1
B --> true
assign(true false,0 : 1,true)
--->
if (0 > 1 or 1 >= size(true false)) or 0 < 0 then true false else if 0 == 0
    then true assign(tail(true false),0 : 1 - 1,true) else head(true false)
    assign(tail(true false),0 - 1 : 1 - 1,true) fi fi
*********** equation
(built-in equation for symbol _>_)
0 > 1
--->
false
*********** equation
eq size(L:BoolList) = $size(L:BoolList, 0) .
L:BoolList --> true false
size(true false)
--->
$size(true false, 0)
*********** equation
eq $size(E:Bool L:BoolList, C:Nat) = $size(L:BoolList, C:Nat + 1) .
E:Bool --> true
L:BoolList --> false
C:Nat --> 0
$size(true false, 0)
--->
$size(false, 0 + 1)
*********** equation
(built-in equation for symbol _+_)
0 + 1
--->
1
*********** equation
eq $size(E:Bool L:BoolList, C:Nat) = $size(L:BoolList, C:Nat + 1) .
E:Bool --> false
L:BoolList --> (nil).BoolList
C:Nat --> 1
$size(false, 1)
--->
$size((nil).BoolList, 1 + 1)
*********** equation
(built-in equation for symbol _+_)
1 + 1
--->
2
*********** equation
eq $size((nil).BoolList, C:Nat) = C:Nat .
C:Nat --> 2
$size((nil).BoolList, 2)
--->
2
*********** equation
(built-in equation for symbol _>=_)
1 >= 2
--->
false
*********** equation
eq A:Bool or B = A:Bool and B xor A:Bool xor B .
A:Bool --> false
B --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
(built-in equation for symbol _<_)
0 < 0
--->
false
*********** equation
eq A:Bool or B = A:Bool and B xor A:Bool xor B .
A:Bool --> false
B --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then true false else if 0 == 0 then true assign(tail(true false),0 : 1
    - 1,true) else head(true false) assign(tail(true false),0 - 1 : 1 - 1,true)
    fi fi
--->
if 0 == 0 then true assign(tail(true false),0 : 1 - 1,true) else head(true
    false) assign(tail(true false),0 - 1 : 1 - 1,true) fi
*********** equation
(built-in equation for symbol _==_)
0 == 0
--->
true
*********** equation
(built-in equation for symbol if_then_else_fi)
if true then true assign(tail(true false),0 : 1 - 1,true) else head(true false)
    assign(tail(true false),0 - 1 : 1 - 1,true) fi
--->
true assign(tail(true false),0 : 1 - 1,true)
*********** equation
eq tail(E:Bool L:BoolList) = L:BoolList .
E:Bool --> true
L:BoolList --> false
tail(true false)
--->
false
*********** equation
(built-in equation for symbol _-_)
1 - 1
--->
0
*********** equation
eq assign(BL,N:Int : N':Int,B) = if (N:Int > N':Int or N':Int >= size(BL)) or
    N:Int < 0 then BL else if N:Int == 0 then B assign(tail(BL),0 : N':Int - 1,
    B) else head(BL) assign(tail(BL),N:Int - 1 : N':Int - 1,B) fi fi .
BL --> false
N:Int --> 0
N':Int --> 0
B --> true
assign(false,0 : 0,true)
--->
if (0 > 0 or 0 >= size(false)) or 0 < 0 then false else if 0 == 0 then true
    assign(tail(false),0 : 0 - 1,true) else head(false) assign(tail(false),0 -
    1 : 0 - 1,true) fi fi
*********** equation
(built-in equation for symbol _>_)
0 > 0
--->
false
*********** equation
eq size(L:BoolList) = $size(L:BoolList, 0) .
L:BoolList --> false
size(false)
--->
$size(false, 0)
*********** equation
eq $size(E:Bool L:BoolList, C:Nat) = $size(L:BoolList, C:Nat + 1) .
E:Bool --> false
L:BoolList --> (nil).BoolList
C:Nat --> 0
$size(false, 0)
--->
$size((nil).BoolList, 0 + 1)
*********** equation
(built-in equation for symbol _+_)
0 + 1
--->
1
*********** equation
eq $size((nil).BoolList, C:Nat) = C:Nat .
C:Nat --> 1
$size((nil).BoolList, 1)
--->
1
*********** equation
(built-in equation for symbol _>=_)
0 >= 1
--->
false
*********** equation
eq A:Bool or B = A:Bool and B xor A:Bool xor B .
A:Bool --> false
B --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
(built-in equation for symbol _<_)
0 < 0
--->
false
*********** equation
eq A:Bool or B = A:Bool and B xor A:Bool xor B .
A:Bool --> false
B --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then false else if 0 == 0 then true assign(tail(false),0 : 0 - 1,true)
    else head(false) assign(tail(false),0 - 1 : 0 - 1,true) fi fi
--->
if 0 == 0 then true assign(tail(false),0 : 0 - 1,true) else head(false) assign(
    tail(false),0 - 1 : 0 - 1,true) fi
*********** equation
(built-in equation for symbol _==_)
0 == 0
--->
true
*********** equation
(built-in equation for symbol if_then_else_fi)
if true then true assign(tail(false),0 : 0 - 1,true) else head(false) assign(
    tail(false),0 - 1 : 0 - 1,true) fi
--->
true assign(tail(false),0 : 0 - 1,true)
*********** equation
eq tail(E:Bool L:BoolList) = L:BoolList .
E:Bool --> false
L:BoolList --> (nil).BoolList
tail(false)
--->
(nil).BoolList
*********** equation
(built-in equation for symbol _-_)
0 - 1
--->
-1
*********** equation
eq assign(BL,N:Int : N':Int,B) = if (N:Int > N':Int or N':Int >= size(BL)) or
    N:Int < 0 then BL else if N:Int == 0 then B assign(tail(BL),0 : N':Int - 1,
    B) else head(BL) assign(tail(BL),N:Int - 1 : N':Int - 1,B) fi fi .
BL --> (nil).BoolList
N:Int --> 0
N':Int --> -1
B --> true
assign(nil,0 : -1,true)
--->
if (0 > -1 or -1 >= size((nil).BoolList)) or 0 < 0 then (nil).BoolList else if
    0 == 0 then true assign(tail(nil),0 : -1 - 1,true) else head((
    nil).BoolList) assign(tail(nil),0 - 1 : -1 - 1,true) fi fi
*********** equation
(built-in equation for symbol _>_)
0 > -1
--->
true
*********** equation
eq size(L:BoolList) = $size(L:BoolList, 0) .
L:BoolList --> (nil).BoolList
size((nil).BoolList)
--->
$size((nil).BoolList, 0)
*********** equation
eq $size((nil).BoolList, C:Nat) = C:Nat .
C:Nat --> 0
$size((nil).BoolList, 0)
--->
0
*********** equation
(built-in equation for symbol _>=_)
-1 >= 0
--->
false
*********** equation
eq A:Bool or B = A:Bool and B xor A:Bool xor B .
A:Bool --> false
B --> true
true or false
--->
false and true xor false xor true
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> false
true and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> true
true xor false
--->
true
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> true
true xor false
--->
true
*********** equation
(built-in equation for symbol _<_)
0 < 0
--->
false
*********** equation
eq A:Bool or B = A:Bool and B xor A:Bool xor B .
A:Bool --> false
B --> true
true or false
--->
false and true xor false xor true
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> false
true and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> true
true xor false
--->
true
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> true
true xor false
--->
true
*********** equation
(built-in equation for symbol if_then_else_fi)
if true then (nil).BoolList else if 0 == 0 then true assign(tail(nil),0 : -1 -
    1,true) else head((nil).BoolList) assign(tail(nil),0 - 1 : -1 - 1,true) fi
    fi
--->
(nil).BoolList
*********** trial #24
crl < O : V:Sender | Atts:AttributeSet, msgsToSend : (S SL), sendBuffer : ML,
    currentSeqNo : N', receiver : O', ackBuffer : AckL, numWordsInBuffer : N,
    finishSend : B, bufferSize : N0, bufferStart : I, actionCount : I0 > => < O
    : V:Sender | Atts:AttributeSet, msgsToSend : SL, sendBuffer : ((msg S
    withSeqNo s N' from O to O') ++ ML), currentSeqNo : s N', receiver : O',
    ackBuffer : n N0 false, numWordsInBuffer : s N, finishSend : B, bufferSize
    : N0, bufferStart : (I + 1), actionCount : (I0 + 1) > if not B and (
    allTrue(AckL) and N == 0 or N < N0 and N > 0) = true [label load_word] .
O --> "Alice"
V:Sender --> Sender
Atts:AttributeSet --> channel : "C"
S --> "2"
SL --> EOF
ML --> Mnil
N' --> 2
O' --> "Bob"
AckL --> true true
N --> 0
B --> false
N0 --> 2
I --> 1
I0 --> 4
*********** solving condition fragment
not B and (allTrue(AckL) and N == 0 or N < N0 and N > 0) = true
*********** equation
eq not A:Bool = true xor A:Bool .
A:Bool --> false
not false
--->
true xor false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> true
true xor false
--->
true
*********** equation
eq allTrue(B BL) = allTrue(BL) and allTrue(B) .
B --> true
BL --> true
allTrue(true true)
--->
allTrue(true) and allTrue(true)
*********** equation
eq allTrue(B) = B .
B --> true
allTrue(true)
--->
true
*********** equation
eq allTrue(B) = B .
B --> true
allTrue(true)
--->
true
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> true
true and true
--->
true
*********** equation
(built-in equation for symbol _==_)
0 == 0
--->
true
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> true
true and true
--->
true
*********** equation
(built-in equation for symbol _<_)
0 < 2
--->
true
*********** equation
(built-in equation for symbol _>_)
0 > 0
--->
false
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> false
true and false
--->
false
*********** equation
eq A:Bool or B = A:Bool and B xor A:Bool xor B .
A:Bool --> false
B --> true
true or false
--->
false and true xor false xor true
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> false
true and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> true
true xor false
--->
true
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> true
true xor false
--->
true
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> true
true and true
--->
true
*********** success for condition fragment
not B and (allTrue(AckL) and N == 0 or N < N0 and N > 0) = true
O --> "Alice"
V:Sender --> Sender
Atts:AttributeSet --> channel : "C"
S --> "2"
SL --> EOF
ML --> Mnil
N' --> 2
O' --> "Bob"
AckL --> true true
N --> 0
B --> false
N0 --> 2
I --> 1
I0 --> 4
*********** success #24
*********** rule
crl < O : V:Sender | Atts:AttributeSet, msgsToSend : (S SL), sendBuffer : ML,
    currentSeqNo : N', receiver : O', ackBuffer : AckL, numWordsInBuffer : N,
    finishSend : B, bufferSize : N0, bufferStart : I, actionCount : I0 > => < O
    : V:Sender | Atts:AttributeSet, msgsToSend : SL, sendBuffer : ((msg S
    withSeqNo s N' from O to O') ++ ML), currentSeqNo : s N', receiver : O',
    ackBuffer : n N0 false, numWordsInBuffer : s N, finishSend : B, bufferSize
    : N0, bufferStart : (I + 1), actionCount : (I0 + 1) > if not B and (
    allTrue(AckL) and N == 0 or N < N0 and N > 0) = true [label load_word] .
O --> "Alice"
V:Sender --> Sender
Atts:AttributeSet --> channel : "C"
S --> "2"
SL --> EOF
ML --> Mnil
N' --> 2
O' --> "Bob"
AckL --> true true
N --> 0
B --> false
N0 --> 2
I --> 1
I0 --> 4
< "Alice" : Sender | msgsToSend : ("2" EOF), sendBuffer : Mnil, currentSeqNo :
    2, receiver : "Bob", ackBuffer : (true true), numWordsInBuffer : 0,
    finishSend : false, channel : "C", bufferSize : 2, bufferStart : 1,
    actionCount : 4 >
--->
< "Alice" : Sender | channel : "C", msgsToSend : EOF, sendBuffer : ((msg "2"
    withSeqNo s 2 from "Alice" to "Bob") ++ Mnil), currentSeqNo : s 2, receiver
    : "Bob", ackBuffer : n 2 false, numWordsInBuffer : 1, finishSend : false,
    bufferSize : 2, bufferStart : (1 + 1), actionCount : (4 + 1) >
*********** equation
eq n N:Int false = if N:Int <= 0 then (nil).BoolList else false n N:Int - 1
    false fi .
N:Int --> 2
n 2 false
--->
if 2 <= 0 then (nil).BoolList else false n 2 - 1 false fi
*********** equation
(built-in equation for symbol _<=_)
2 <= 0
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then (nil).BoolList else false n 2 - 1 false fi
--->
false n 2 - 1 false
*********** equation
(built-in equation for symbol _-_)
2 - 1
--->
1
*********** equation
eq n N:Int false = if N:Int <= 0 then (nil).BoolList else false n N:Int - 1
    false fi .
N:Int --> 1
n 1 false
--->
if 1 <= 0 then (nil).BoolList else false n 1 - 1 false fi
*********** equation
(built-in equation for symbol _<=_)
1 <= 0
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then (nil).BoolList else false n 1 - 1 false fi
--->
false n 1 - 1 false
*********** equation
(built-in equation for symbol _-_)
1 - 1
--->
0
*********** equation
eq n N:Int false = if N:Int <= 0 then (nil).BoolList else false n N:Int - 1
    false fi .
N:Int --> 0
n 0 false
--->
if 0 <= 0 then (nil).BoolList else false n 0 - 1 false fi
*********** equation
(built-in equation for symbol _<=_)
0 <= 0
--->
true
*********** equation
(built-in equation for symbol if_then_else_fi)
if true then (nil).BoolList else false n 0 - 1 false fi
--->
(nil).BoolList
*********** equation
(built-in equation for symbol _+_)
1 + 1
--->
2
*********** equation
(built-in equation for symbol _+_)
1 + 4
--->
5
*********** trial #25
crl < O : V:Receiver | Atts:AttributeSet, bufferSize : N0, bufferStart : I0,
    greatestSeqNoRcvd : N, msgsRcvd : SL, rcvBuffer : SL0, rcvCheck : BL,
    rcvEOF : B0, EOFPos : N1 > => < O : V:Receiver | Atts:AttributeSet,
    bufferSize : N0, bufferStart : (N0 + I0), greatestSeqNoRcvd : (N + N0),
    msgsRcvd : (SL SL0), rcvBuffer : n N0 mts, rcvCheck : n N0 false, rcvEOF :
    B0, EOFPos : N1 > if allTrue(BL) or B0 and lastConsecutiveTrue(BL) >= N1 =
    true [label loadWordsFromBuffer] .
O --> "Bob"
V:Receiver --> Receiver
Atts:AttributeSet --> channel : "C", sender : "Alice"
N0 --> 2
I0 --> 3
N --> 2
SL --> "0" "1"
SL0 --> mts mts
BL --> false false
B0 --> false
N1 --> 0
*********** solving condition fragment
allTrue(BL) or B0 and lastConsecutiveTrue(BL) >= N1 = true
*********** equation
eq allTrue(B BL) = allTrue(BL) and allTrue(B) .
B --> false
BL --> false
allTrue(false false)
--->
allTrue(false) and allTrue(false)
*********** equation
eq allTrue(B) = B .
B --> false
allTrue(false)
--->
false
*********** equation
eq allTrue(B) = B .
B --> false
allTrue(false)
--->
false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq lastConsecutiveTrue(BL) = if BL == (nil).BoolList or head(BL) == false then
    -1 else 1 + lastConsecutiveTrue(tail(BL)) fi .
BL --> false false
lastConsecutiveTrue(false false)
--->
if false false == (nil).BoolList or head(false false) == false then -1 else 1 +
    lastConsecutiveTrue(tail(false false)) fi
*********** equation
(built-in equation for symbol _==_)
false false == (nil).BoolList
--->
false
*********** equation
eq head(E:Bool L:BoolList) = E:Bool .
E:Bool --> false
L:BoolList --> false
head(false false)
--->
false
*********** equation
(built-in equation for symbol _==_)
false == false
--->
true
*********** equation
eq A:Bool or B = A:Bool and B xor A:Bool xor B .
A:Bool --> false
B --> true
true or false
--->
false and true xor false xor true
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> false
true and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> true
true xor false
--->
true
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> true
true xor false
--->
true
*********** equation
(built-in equation for symbol if_then_else_fi)
if true then -1 else 1 + lastConsecutiveTrue(tail(false false)) fi
--->
-1
*********** equation
(built-in equation for symbol _>=_)
-1 >= 0
--->
false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq A:Bool or B = A:Bool and B xor A:Bool xor B .
A:Bool --> false
B --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** failure for condition fragment
allTrue(BL) or B0 and lastConsecutiveTrue(BL) >= N1 = true
*********** failure #25
*********** trial #26
crl < O : V:Receiver | Atts:AttributeSet, msgsRcvd : (SL S0) > => < O :
    V:Receiver | Atts:AttributeSet, msgsRcvd : SL > if S0 == mts = true [label
    rmEmptyString] .
O --> "Bob"
V:Receiver --> Receiver
Atts:AttributeSet --> channel : "C", bufferSize : 2, bufferStart : 3,
    greatestSeqNoRcvd : 2, sender : "Alice", rcvBuffer : (mts mts), rcvCheck :
    (false false), rcvEOF : false, EOFPos : 0
SL --> "0"
S0 --> "1"
*********** solving condition fragment
S0 == mts = true
*********** equation
(built-in equation for symbol _==_)
"1" == mts
--->
false
*********** failure for condition fragment
S0 == mts = true
*********** failure #26
*********** trial #27
crl < O : V:Sender | Atts:AttributeSet, sendBuffer : ML, numWordsInBuffer : N',
    finishSend : B, bufferSize : N0, actionCount : I0 > < O' : V2:Channel |
    Atts2:AttributeSet, msgs : ML0, count : N > => < O : V:Sender |
    Atts:AttributeSet, sendBuffer : Mnil, numWordsInBuffer : 0, finishSend : B,
    bufferSize : N0, actionCount : (I0 + 1) > < O' : V2:Channel |
    Atts2:AttributeSet, msgs : (ML0 ++ ML), count : (N + 1) > if B and size(ML)
    > 0 or N' == N0 = true [label sendCurrentMsgs] .
O --> "Alice"
V:Sender --> Sender
Atts:AttributeSet --> msgsToSend : EOF, currentSeqNo : 3, receiver : "Bob",
    ackBuffer : (false false), channel : "C", bufferStart : 2
ML --> msg "2" withSeqNo 3 from "Alice" to "Bob"
N' --> 1
B --> false
N0 --> 2
I0 --> 5
O' --> "C"
V2:Channel --> Channel
Atts2:AttributeSet --> (none).AttributeSet
ML0 --> Mnil
N --> 5
*********** solving condition fragment
B and size(ML) > 0 or N' == N0 = true
*********** equation
eq size(T) = if T == Mnil then 0 else 1 + size(tail(T)) fi .
T --> msg "2" withSeqNo 3 from "Alice" to "Bob"
size(msg "2" withSeqNo 3 from "Alice" to "Bob")
--->
if msg "2" withSeqNo 3 from "Alice" to "Bob" == Mnil then 0 else 1 + size(tail(
    msg "2" withSeqNo 3 from "Alice" to "Bob")) fi
*********** equation
(built-in equation for symbol _==_)
msg "2" withSeqNo 3 from "Alice" to "Bob" == Mnil
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then 0 else 1 + size(tail(msg "2" withSeqNo 3 from "Alice" to "Bob"))
    fi
--->
1 + size(tail(msg "2" withSeqNo 3 from "Alice" to "Bob"))
*********** equation
eq tail(H ++ T) = T .
H --> msg "2" withSeqNo 3 from "Alice" to "Bob"
T --> Mnil
tail(msg "2" withSeqNo 3 from "Alice" to "Bob")
--->
Mnil
*********** equation
eq size(T) = if T == Mnil then 0 else 1 + size(tail(T)) fi .
T --> Mnil
size(Mnil)
--->
if Mnil == Mnil then 0 else 1 + size(tail(Mnil)) fi
*********** equation
(built-in equation for symbol _==_)
Mnil == Mnil
--->
true
*********** equation
(built-in equation for symbol if_then_else_fi)
if true then 0 else 1 + size(tail(Mnil)) fi
--->
0
*********** equation
(built-in equation for symbol _+_)
0 + 1
--->
1
*********** equation
(built-in equation for symbol _>_)
1 > 0
--->
true
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> false
true and false
--->
false
*********** equation
(built-in equation for symbol _==_)
1 == 2
--->
false
*********** equation
eq A:Bool or B = A:Bool and B xor A:Bool xor B .
A:Bool --> false
B --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** failure for condition fragment
B and size(ML) > 0 or N' == N0 = true
*********** failure #27
*********** trial #28
crl < O : V:Sender | Atts:AttributeSet, msgsToSend : (S SL), sendBuffer : ML,
    currentSeqNo : N', receiver : O', ackBuffer : AckL, numWordsInBuffer : N,
    finishSend : B, bufferSize : N0, bufferStart : I, actionCount : I0 > => < O
    : V:Sender | Atts:AttributeSet, msgsToSend : SL, sendBuffer : ((msg S
    withSeqNo s N' from O to O') ++ ML), currentSeqNo : s N', receiver : O',
    ackBuffer : n N0 false, numWordsInBuffer : s N, finishSend : B, bufferSize
    : N0, bufferStart : (I + 1), actionCount : (I0 + 1) > if not B and (
    allTrue(AckL) and N == 0 or N < N0 and N > 0) = true [label load_word] .
O --> "Alice"
V:Sender --> Sender
Atts:AttributeSet --> channel : "C"
S --> EOF
SL --> (nil).StringList
ML --> msg "2" withSeqNo 3 from "Alice" to "Bob"
N' --> 3
O' --> "Bob"
AckL --> false false
N --> 1
B --> false
N0 --> 2
I --> 2
I0 --> 5
*********** solving condition fragment
not B and (allTrue(AckL) and N == 0 or N < N0 and N > 0) = true
*********** equation
eq not A:Bool = true xor A:Bool .
A:Bool --> false
not false
--->
true xor false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> true
true xor false
--->
true
*********** equation
eq allTrue(B BL) = allTrue(BL) and allTrue(B) .
B --> false
BL --> false
allTrue(false false)
--->
allTrue(false) and allTrue(false)
*********** equation
eq allTrue(B) = B .
B --> false
allTrue(false)
--->
false
*********** equation
eq allTrue(B) = B .
B --> false
allTrue(false)
--->
false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
(built-in equation for symbol _==_)
1 == 0
--->
false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
(built-in equation for symbol _<_)
1 < 2
--->
true
*********** equation
(built-in equation for symbol _>_)
1 > 0
--->
true
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> true
true and true
--->
true
*********** equation
eq A:Bool or B = A:Bool and B xor A:Bool xor B .
A:Bool --> false
B --> true
true or false
--->
false and true xor false xor true
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> false
true and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> true
true xor false
--->
true
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> true
true xor false
--->
true
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> true
true and true
--->
true
*********** success for condition fragment
not B and (allTrue(AckL) and N == 0 or N < N0 and N > 0) = true
O --> "Alice"
V:Sender --> Sender
Atts:AttributeSet --> channel : "C"
S --> EOF
SL --> (nil).StringList
ML --> msg "2" withSeqNo 3 from "Alice" to "Bob"
N' --> 3
O' --> "Bob"
AckL --> false false
N --> 1
B --> false
N0 --> 2
I --> 2
I0 --> 5
*********** success #28
*********** rule
crl < O : V:Sender | Atts:AttributeSet, msgsToSend : (S SL), sendBuffer : ML,
    currentSeqNo : N', receiver : O', ackBuffer : AckL, numWordsInBuffer : N,
    finishSend : B, bufferSize : N0, bufferStart : I, actionCount : I0 > => < O
    : V:Sender | Atts:AttributeSet, msgsToSend : SL, sendBuffer : ((msg S
    withSeqNo s N' from O to O') ++ ML), currentSeqNo : s N', receiver : O',
    ackBuffer : n N0 false, numWordsInBuffer : s N, finishSend : B, bufferSize
    : N0, bufferStart : (I + 1), actionCount : (I0 + 1) > if not B and (
    allTrue(AckL) and N == 0 or N < N0 and N > 0) = true [label load_word] .
O --> "Alice"
V:Sender --> Sender
Atts:AttributeSet --> channel : "C"
S --> EOF
SL --> (nil).StringList
ML --> msg "2" withSeqNo 3 from "Alice" to "Bob"
N' --> 3
O' --> "Bob"
AckL --> false false
N --> 1
B --> false
N0 --> 2
I --> 2
I0 --> 5
< "Alice" : Sender | msgsToSend : EOF, sendBuffer : msg "2" withSeqNo 3 from
    "Alice" to "Bob", currentSeqNo : 3, receiver : "Bob", ackBuffer : (false
    false), numWordsInBuffer : 1, finishSend : false, channel : "C", bufferSize
    : 2, bufferStart : 2, actionCount : 5 >
--->
< "Alice" : Sender | channel : "C", msgsToSend : nil, sendBuffer : ((msg EOF
    withSeqNo s 3 from "Alice" to "Bob") ++ msg "2" withSeqNo 3 from "Alice" to
    "Bob"), currentSeqNo : s 3, receiver : "Bob", ackBuffer : n 2 false,
    numWordsInBuffer : s 1, finishSend : false, bufferSize : 2, bufferStart : (
    2 + 1), actionCount : (5 + 1) >
*********** equation
eq n N:Int false = if N:Int <= 0 then (nil).BoolList else false n N:Int - 1
    false fi .
N:Int --> 2
n 2 false
--->
if 2 <= 0 then (nil).BoolList else false n 2 - 1 false fi
*********** equation
(built-in equation for symbol _<=_)
2 <= 0
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then (nil).BoolList else false n 2 - 1 false fi
--->
false n 2 - 1 false
*********** equation
(built-in equation for symbol _-_)
2 - 1
--->
1
*********** equation
eq n N:Int false = if N:Int <= 0 then (nil).BoolList else false n N:Int - 1
    false fi .
N:Int --> 1
n 1 false
--->
if 1 <= 0 then (nil).BoolList else false n 1 - 1 false fi
*********** equation
(built-in equation for symbol _<=_)
1 <= 0
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then (nil).BoolList else false n 1 - 1 false fi
--->
false n 1 - 1 false
*********** equation
(built-in equation for symbol _-_)
1 - 1
--->
0
*********** equation
eq n N:Int false = if N:Int <= 0 then (nil).BoolList else false n N:Int - 1
    false fi .
N:Int --> 0
n 0 false
--->
if 0 <= 0 then (nil).BoolList else false n 0 - 1 false fi
*********** equation
(built-in equation for symbol _<=_)
0 <= 0
--->
true
*********** equation
(built-in equation for symbol if_then_else_fi)
if true then (nil).BoolList else false n 0 - 1 false fi
--->
(nil).BoolList
*********** equation
(built-in equation for symbol _+_)
1 + 2
--->
3
*********** equation
(built-in equation for symbol _+_)
1 + 5
--->
6
*********** trial #29
crl < O : V:Sender | Atts:AttributeSet, sendBuffer : ML, numWordsInBuffer : N',
    finishSend : B, bufferSize : N0, actionCount : I0 > < O' : V2:Channel |
    Atts2:AttributeSet, msgs : ML0, count : N > => < O : V:Sender |
    Atts:AttributeSet, sendBuffer : Mnil, numWordsInBuffer : 0, finishSend : B,
    bufferSize : N0, actionCount : (I0 + 1) > < O' : V2:Channel |
    Atts2:AttributeSet, msgs : (ML0 ++ ML), count : (N + 1) > if B and size(ML)
    > 0 or N' == N0 = true [label sendCurrentMsgs] .
O --> "Alice"
V:Sender --> Sender
Atts:AttributeSet --> msgsToSend : nil, currentSeqNo : 4, receiver : "Bob",
    ackBuffer : (false false), channel : "C", bufferStart : 3
ML --> (msg EOF withSeqNo 4 from "Alice" to "Bob") ++ msg "2" withSeqNo 3 from
    "Alice" to "Bob"
N' --> 2
B --> false
N0 --> 2
I0 --> 6
O' --> "C"
V2:Channel --> Channel
Atts2:AttributeSet --> (none).AttributeSet
ML0 --> Mnil
N --> 5
*********** solving condition fragment
B and size(ML) > 0 or N' == N0 = true
*********** equation
eq size(T) = if T == Mnil then 0 else 1 + size(tail(T)) fi .
T --> (msg EOF withSeqNo 4 from "Alice" to "Bob") ++ msg "2" withSeqNo 3 from
    "Alice" to "Bob"
size((msg EOF withSeqNo 4 from "Alice" to "Bob") ++ msg "2" withSeqNo 3 from
    "Alice" to "Bob")
--->
if (msg EOF withSeqNo 4 from "Alice" to "Bob") ++ msg "2" withSeqNo 3 from
    "Alice" to "Bob" == Mnil then 0 else 1 + size(tail((msg EOF withSeqNo 4
    from "Alice" to "Bob") ++ msg "2" withSeqNo 3 from "Alice" to "Bob")) fi
*********** equation
(built-in equation for symbol _==_)
(msg EOF withSeqNo 4 from "Alice" to "Bob") ++ msg "2" withSeqNo 3 from "Alice"
    to "Bob" == Mnil
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then 0 else 1 + size(tail((msg EOF withSeqNo 4 from "Alice" to "Bob")
    ++ msg "2" withSeqNo 3 from "Alice" to "Bob")) fi
--->
1 + size(tail((msg EOF withSeqNo 4 from "Alice" to "Bob") ++ msg "2" withSeqNo
    3 from "Alice" to "Bob"))
*********** equation
eq tail(H ++ T) = T .
H --> msg EOF withSeqNo 4 from "Alice" to "Bob"
T --> msg "2" withSeqNo 3 from "Alice" to "Bob"
tail((msg EOF withSeqNo 4 from "Alice" to "Bob") ++ msg "2" withSeqNo 3 from
    "Alice" to "Bob")
--->
msg "2" withSeqNo 3 from "Alice" to "Bob"
*********** equation
eq size(T) = if T == Mnil then 0 else 1 + size(tail(T)) fi .
T --> msg "2" withSeqNo 3 from "Alice" to "Bob"
size(msg "2" withSeqNo 3 from "Alice" to "Bob")
--->
if msg "2" withSeqNo 3 from "Alice" to "Bob" == Mnil then 0 else 1 + size(tail(
    msg "2" withSeqNo 3 from "Alice" to "Bob")) fi
*********** equation
(built-in equation for symbol _==_)
msg "2" withSeqNo 3 from "Alice" to "Bob" == Mnil
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then 0 else 1 + size(tail(msg "2" withSeqNo 3 from "Alice" to "Bob"))
    fi
--->
1 + size(tail(msg "2" withSeqNo 3 from "Alice" to "Bob"))
*********** equation
eq tail(H ++ T) = T .
H --> msg "2" withSeqNo 3 from "Alice" to "Bob"
T --> Mnil
tail(msg "2" withSeqNo 3 from "Alice" to "Bob")
--->
Mnil
*********** equation
eq size(T) = if T == Mnil then 0 else 1 + size(tail(T)) fi .
T --> Mnil
size(Mnil)
--->
if Mnil == Mnil then 0 else 1 + size(tail(Mnil)) fi
*********** equation
(built-in equation for symbol _==_)
Mnil == Mnil
--->
true
*********** equation
(built-in equation for symbol if_then_else_fi)
if true then 0 else 1 + size(tail(Mnil)) fi
--->
0
*********** equation
(built-in equation for symbol _+_)
0 + 1
--->
1
*********** equation
(built-in equation for symbol _+_)
1 + 1
--->
2
*********** equation
(built-in equation for symbol _>_)
2 > 0
--->
true
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> false
true and false
--->
false
*********** equation
(built-in equation for symbol _==_)
2 == 2
--->
true
*********** equation
eq A:Bool or B = A:Bool and B xor A:Bool xor B .
A:Bool --> false
B --> true
true or false
--->
false and true xor false xor true
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> false
true and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> true
true xor false
--->
true
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> true
true xor false
--->
true
*********** success for condition fragment
B and size(ML) > 0 or N' == N0 = true
O --> "Alice"
V:Sender --> Sender
Atts:AttributeSet --> msgsToSend : nil, currentSeqNo : 4, receiver : "Bob",
    ackBuffer : (false false), channel : "C", bufferStart : 3
ML --> (msg EOF withSeqNo 4 from "Alice" to "Bob") ++ msg "2" withSeqNo 3 from
    "Alice" to "Bob"
N' --> 2
B --> false
N0 --> 2
I0 --> 6
O' --> "C"
V2:Channel --> Channel
Atts2:AttributeSet --> (none).AttributeSet
ML0 --> Mnil
N --> 5
*********** success #29
*********** rule
crl < O : V:Sender | Atts:AttributeSet, sendBuffer : ML, numWordsInBuffer : N',
    finishSend : B, bufferSize : N0, actionCount : I0 > < O' : V2:Channel |
    Atts2:AttributeSet, msgs : ML0, count : N > => < O : V:Sender |
    Atts:AttributeSet, sendBuffer : Mnil, numWordsInBuffer : 0, finishSend : B,
    bufferSize : N0, actionCount : (I0 + 1) > < O' : V2:Channel |
    Atts2:AttributeSet, msgs : (ML0 ++ ML), count : (N + 1) > if B and size(ML)
    > 0 or N' == N0 = true [label sendCurrentMsgs] .
O --> "Alice"
V:Sender --> Sender
Atts:AttributeSet --> msgsToSend : nil, currentSeqNo : 4, receiver : "Bob",
    ackBuffer : (false false), channel : "C", bufferStart : 3
ML --> (msg EOF withSeqNo 4 from "Alice" to "Bob") ++ msg "2" withSeqNo 3 from
    "Alice" to "Bob"
N' --> 2
B --> false
N0 --> 2
I0 --> 6
O' --> "C"
V2:Channel --> Channel
Atts2:AttributeSet --> (none).AttributeSet
ML0 --> Mnil
N --> 5
< "Alice" : Sender | msgsToSend : nil, sendBuffer : ((msg EOF withSeqNo 4 from
    "Alice" to "Bob") ++ msg "2" withSeqNo 3 from "Alice" to "Bob"),
    currentSeqNo : 4, receiver : "Bob", ackBuffer : (false false),
    numWordsInBuffer : 2, finishSend : false, channel : "C", bufferSize : 2,
    bufferStart : 3, actionCount : 6 > < "Bob" : Receiver | channel : "C",
    bufferSize : 2, bufferStart : 3, greatestSeqNoRcvd : 2, sender : "Alice",
    msgsRcvd : ("0" "1"), rcvBuffer : (mts mts), rcvCheck : (false false),
    rcvEOF : false, EOFPos : 0 > < "C" : Channel | msgs : Mnil, count : 5 >
--->
< "Bob" : Receiver | channel : "C", bufferSize : 2, bufferStart : 3,
    greatestSeqNoRcvd : 2, sender : "Alice", msgsRcvd : ("0" "1"), rcvBuffer :
    (mts mts), rcvCheck : (false false), rcvEOF : false, EOFPos : 0 > < "Alice"
    : Sender | (msgsToSend : nil, currentSeqNo : 4, receiver : "Bob", ackBuffer
    : (false false), channel : "C", bufferStart : 3), sendBuffer : Mnil,
    numWordsInBuffer : 0, finishSend : false, bufferSize : 2, actionCount : (6
    + 1) > < "C" : Channel | none, msgs : (Mnil ++ (msg EOF withSeqNo 4 from
    "Alice" to "Bob") ++ msg "2" withSeqNo 3 from "Alice" to "Bob"), count : (5
    + 1) >
*********** equation
(built-in equation for symbol _+_)
1 + 6
--->
7
*********** equation
(built-in equation for symbol _+_)
1 + 5
--->
6
*********** trial #30
crl < O : V:Sender | Atts:AttributeSet, msgsToSend : nil, sendBuffer : ML,
    currentSeqNo : N', receiver : O', ackBuffer : A:[BoolList],
    numWordsInBuffer : N, finishSend : B, bufferSize : N0, bufferStart : I,
    actionCount : I0 > => < O : V:Sender | Atts:AttributeSet, msgsToSend : nil,
    sendBuffer : (ML ++ msg mts withSeqNo s N' from O to O'), currentSeqNo : s
    N', receiver : O', ackBuffer : n N0 false, numWordsInBuffer : s N,
    finishSend : true, bufferSize : N0, bufferStart : (I + 1), actionCount : (
    I0 + 1) > if not B and N < N0 = true [label load_dummy_word] .
O --> "Alice"
V:Sender --> Sender
Atts:AttributeSet --> channel : "C"
ML --> Mnil
N' --> 4
O' --> "Bob"
A:[BoolList] --> false false
N --> 0
B --> false
N0 --> 2
I --> 3
I0 --> 7
*********** solving condition fragment
not B and N < N0 = true
*********** equation
eq not A:Bool = true xor A:Bool .
A:Bool --> false
not false
--->
true xor false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> true
true xor false
--->
true
*********** equation
(built-in equation for symbol _<_)
0 < 2
--->
true
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> true
true and true
--->
true
*********** success for condition fragment
not B and N < N0 = true
O --> "Alice"
V:Sender --> Sender
Atts:AttributeSet --> channel : "C"
ML --> Mnil
N' --> 4
O' --> "Bob"
A:[BoolList] --> false false
N --> 0
B --> false
N0 --> 2
I --> 3
I0 --> 7
*********** success #30
*********** rule
crl < O : V:Sender | Atts:AttributeSet, msgsToSend : nil, sendBuffer : ML,
    currentSeqNo : N', receiver : O', ackBuffer : A:[BoolList],
    numWordsInBuffer : N, finishSend : B, bufferSize : N0, bufferStart : I,
    actionCount : I0 > => < O : V:Sender | Atts:AttributeSet, msgsToSend : nil,
    sendBuffer : (ML ++ msg mts withSeqNo s N' from O to O'), currentSeqNo : s
    N', receiver : O', ackBuffer : n N0 false, numWordsInBuffer : s N,
    finishSend : true, bufferSize : N0, bufferStart : (I + 1), actionCount : (
    I0 + 1) > if not B and N < N0 = true [label load_dummy_word] .
O --> "Alice"
V:Sender --> Sender
Atts:AttributeSet --> channel : "C"
ML --> Mnil
N' --> 4
O' --> "Bob"
A:[BoolList] --> false false
N --> 0
B --> false
N0 --> 2
I --> 3
I0 --> 7
< "Alice" : Sender | msgsToSend : nil, sendBuffer : Mnil, currentSeqNo : 4,
    receiver : "Bob", ackBuffer : (false false), numWordsInBuffer : 0,
    finishSend : false, channel : "C", bufferSize : 2, bufferStart : 3,
    actionCount : 7 >
--->
< "Alice" : Sender | channel : "C", msgsToSend : nil, sendBuffer : (Mnil ++ msg
    mts withSeqNo s 4 from "Alice" to "Bob"), currentSeqNo : s 4, receiver :
    "Bob", ackBuffer : n 2 false, numWordsInBuffer : 1, finishSend : true,
    bufferSize : 2, bufferStart : (3 + 1), actionCount : (7 + 1) >
*********** equation
eq n N:Int false = if N:Int <= 0 then (nil).BoolList else false n N:Int - 1
    false fi .
N:Int --> 2
n 2 false
--->
if 2 <= 0 then (nil).BoolList else false n 2 - 1 false fi
*********** equation
(built-in equation for symbol _<=_)
2 <= 0
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then (nil).BoolList else false n 2 - 1 false fi
--->
false n 2 - 1 false
*********** equation
(built-in equation for symbol _-_)
2 - 1
--->
1
*********** equation
eq n N:Int false = if N:Int <= 0 then (nil).BoolList else false n N:Int - 1
    false fi .
N:Int --> 1
n 1 false
--->
if 1 <= 0 then (nil).BoolList else false n 1 - 1 false fi
*********** equation
(built-in equation for symbol _<=_)
1 <= 0
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then (nil).BoolList else false n 1 - 1 false fi
--->
false n 1 - 1 false
*********** equation
(built-in equation for symbol _-_)
1 - 1
--->
0
*********** equation
eq n N:Int false = if N:Int <= 0 then (nil).BoolList else false n N:Int - 1
    false fi .
N:Int --> 0
n 0 false
--->
if 0 <= 0 then (nil).BoolList else false n 0 - 1 false fi
*********** equation
(built-in equation for symbol _<=_)
0 <= 0
--->
true
*********** equation
(built-in equation for symbol if_then_else_fi)
if true then (nil).BoolList else false n 0 - 1 false fi
--->
(nil).BoolList
*********** equation
(built-in equation for symbol _+_)
1 + 3
--->
4
*********** equation
(built-in equation for symbol _+_)
1 + 7
--->
8
*********** trial #31
crl < O : V:Channel | Atts:AttributeSet, msgs : ML, count : N > => (ML[random(
    N) rem size(ML)]) < O : V:Channel | Atts:AttributeSet, msgs : pop(ML,
    random(N) rem size(ML)), count : (N + 1) > if size(ML) > 0 = true [label
    convey-msg] .
O --> "C"
V:Channel --> Channel
Atts:AttributeSet --> (none).AttributeSet
ML --> (msg EOF withSeqNo 4 from "Alice" to "Bob") ++ msg "2" withSeqNo 3 from
    "Alice" to "Bob"
N --> 6
*********** solving condition fragment
size(ML) > 0 = true
*********** equation
eq size(T) = if T == Mnil then 0 else 1 + size(tail(T)) fi .
T --> (msg EOF withSeqNo 4 from "Alice" to "Bob") ++ msg "2" withSeqNo 3 from
    "Alice" to "Bob"
size((msg EOF withSeqNo 4 from "Alice" to "Bob") ++ msg "2" withSeqNo 3 from
    "Alice" to "Bob")
--->
if (msg EOF withSeqNo 4 from "Alice" to "Bob") ++ msg "2" withSeqNo 3 from
    "Alice" to "Bob" == Mnil then 0 else 1 + size(tail((msg EOF withSeqNo 4
    from "Alice" to "Bob") ++ msg "2" withSeqNo 3 from "Alice" to "Bob")) fi
*********** equation
(built-in equation for symbol _==_)
(msg EOF withSeqNo 4 from "Alice" to "Bob") ++ msg "2" withSeqNo 3 from "Alice"
    to "Bob" == Mnil
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then 0 else 1 + size(tail((msg EOF withSeqNo 4 from "Alice" to "Bob")
    ++ msg "2" withSeqNo 3 from "Alice" to "Bob")) fi
--->
1 + size(tail((msg EOF withSeqNo 4 from "Alice" to "Bob") ++ msg "2" withSeqNo
    3 from "Alice" to "Bob"))
*********** equation
eq tail(H ++ T) = T .
H --> msg EOF withSeqNo 4 from "Alice" to "Bob"
T --> msg "2" withSeqNo 3 from "Alice" to "Bob"
tail((msg EOF withSeqNo 4 from "Alice" to "Bob") ++ msg "2" withSeqNo 3 from
    "Alice" to "Bob")
--->
msg "2" withSeqNo 3 from "Alice" to "Bob"
*********** equation
eq size(T) = if T == Mnil then 0 else 1 + size(tail(T)) fi .
T --> msg "2" withSeqNo 3 from "Alice" to "Bob"
size(msg "2" withSeqNo 3 from "Alice" to "Bob")
--->
if msg "2" withSeqNo 3 from "Alice" to "Bob" == Mnil then 0 else 1 + size(tail(
    msg "2" withSeqNo 3 from "Alice" to "Bob")) fi
*********** equation
(built-in equation for symbol _==_)
msg "2" withSeqNo 3 from "Alice" to "Bob" == Mnil
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then 0 else 1 + size(tail(msg "2" withSeqNo 3 from "Alice" to "Bob"))
    fi
--->
1 + size(tail(msg "2" withSeqNo 3 from "Alice" to "Bob"))
*********** equation
eq tail(H ++ T) = T .
H --> msg "2" withSeqNo 3 from "Alice" to "Bob"
T --> Mnil
tail(msg "2" withSeqNo 3 from "Alice" to "Bob")
--->
Mnil
*********** equation
eq size(T) = if T == Mnil then 0 else 1 + size(tail(T)) fi .
T --> Mnil
size(Mnil)
--->
if Mnil == Mnil then 0 else 1 + size(tail(Mnil)) fi
*********** equation
(built-in equation for symbol _==_)
Mnil == Mnil
--->
true
*********** equation
(built-in equation for symbol if_then_else_fi)
if true then 0 else 1 + size(tail(Mnil)) fi
--->
0
*********** equation
(built-in equation for symbol _+_)
0 + 1
--->
1
*********** equation
(built-in equation for symbol _+_)
1 + 1
--->
2
*********** equation
(built-in equation for symbol _>_)
2 > 0
--->
true
*********** success for condition fragment
size(ML) > 0 = true
O --> "C"
V:Channel --> Channel
Atts:AttributeSet --> (none).AttributeSet
ML --> (msg EOF withSeqNo 4 from "Alice" to "Bob") ++ msg "2" withSeqNo 3 from
    "Alice" to "Bob"
N --> 6
*********** success #31
*********** rule
crl < O : V:Channel | Atts:AttributeSet, msgs : ML, count : N > => (ML[random(
    N) rem size(ML)]) < O : V:Channel | Atts:AttributeSet, msgs : pop(ML,
    random(N) rem size(ML)), count : (N + 1) > if size(ML) > 0 = true [label
    convey-msg] .
O --> "C"
V:Channel --> Channel
Atts:AttributeSet --> (none).AttributeSet
ML --> (msg EOF withSeqNo 4 from "Alice" to "Bob") ++ msg "2" withSeqNo 3 from
    "Alice" to "Bob"
N --> 6
< "C" : Channel | msgs : ((msg EOF withSeqNo 4 from "Alice" to "Bob") ++ msg
    "2" withSeqNo 3 from "Alice" to "Bob"), count : 6 >
--->
(((msg EOF withSeqNo 4 from "Alice" to "Bob") ++ msg "2" withSeqNo 3 from
    "Alice" to "Bob")[random(6) rem 2]) < "C" : Channel | none, msgs : pop((msg
    EOF withSeqNo 4 from "Alice" to "Bob") ++ msg "2" withSeqNo 3 from "Alice"
    to "Bob",random(6) rem 2), count : (6 + 1) >
*********** equation
(built-in equation for symbol random)
random(6)
--->
2340255427
*********** equation
(built-in equation for symbol _rem_)
2340255427 rem 2
--->
1
*********** equation
eq T[N] = if N <= 0 then if N == 0 then head(T) else Mnil fi else tail(T)[N -
    1] fi .
T --> (msg EOF withSeqNo 4 from "Alice" to "Bob") ++ msg "2" withSeqNo 3 from
    "Alice" to "Bob"
N --> 1
((msg EOF withSeqNo 4 from "Alice" to "Bob") ++ msg "2" withSeqNo 3 from
    "Alice" to "Bob")[1]
--->
if 1 <= 0 then if 1 == 0 then head((msg EOF withSeqNo 4 from "Alice" to "Bob")
    ++ msg "2" withSeqNo 3 from "Alice" to "Bob") else Mnil fi else tail((msg
    EOF withSeqNo 4 from "Alice" to "Bob") ++ msg "2" withSeqNo 3 from "Alice"
    to "Bob")[1 - 1] fi
*********** equation
(built-in equation for symbol _<=_)
1 <= 0
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then if 1 == 0 then head((msg EOF withSeqNo 4 from "Alice" to "Bob")
    ++ msg "2" withSeqNo 3 from "Alice" to "Bob") else Mnil fi else tail((msg
    EOF withSeqNo 4 from "Alice" to "Bob") ++ msg "2" withSeqNo 3 from "Alice"
    to "Bob")[1 - 1] fi
--->
tail((msg EOF withSeqNo 4 from "Alice" to "Bob") ++ msg "2" withSeqNo 3 from
    "Alice" to "Bob")[1 - 1]
*********** equation
eq tail(H ++ T) = T .
H --> msg EOF withSeqNo 4 from "Alice" to "Bob"
T --> msg "2" withSeqNo 3 from "Alice" to "Bob"
tail((msg EOF withSeqNo 4 from "Alice" to "Bob") ++ msg "2" withSeqNo 3 from
    "Alice" to "Bob")
--->
msg "2" withSeqNo 3 from "Alice" to "Bob"
*********** equation
(built-in equation for symbol _-_)
1 - 1
--->
0
*********** equation
eq T[N] = if N <= 0 then if N == 0 then head(T) else Mnil fi else tail(T)[N -
    1] fi .
T --> msg "2" withSeqNo 3 from "Alice" to "Bob"
N --> 0
msg "2" withSeqNo 3 from "Alice" to "Bob"[0]
--->
if 0 <= 0 then if 0 == 0 then head(msg "2" withSeqNo 3 from "Alice" to "Bob")
    else Mnil fi else tail(msg "2" withSeqNo 3 from "Alice" to "Bob")[0 - 1] fi
*********** equation
(built-in equation for symbol _<=_)
0 <= 0
--->
true
*********** equation
(built-in equation for symbol if_then_else_fi)
if true then if 0 == 0 then head(msg "2" withSeqNo 3 from "Alice" to "Bob")
    else Mnil fi else tail(msg "2" withSeqNo 3 from "Alice" to "Bob")[0 - 1] fi
--->
if 0 == 0 then head(msg "2" withSeqNo 3 from "Alice" to "Bob") else Mnil fi
*********** equation
(built-in equation for symbol _==_)
0 == 0
--->
true
*********** equation
(built-in equation for symbol if_then_else_fi)
if true then head(msg "2" withSeqNo 3 from "Alice" to "Bob") else Mnil fi
--->
head(msg "2" withSeqNo 3 from "Alice" to "Bob")
*********** equation
eq head(H ++ T) = H .
H --> msg "2" withSeqNo 3 from "Alice" to "Bob"
T --> Mnil
head(msg "2" withSeqNo 3 from "Alice" to "Bob")
--->
msg "2" withSeqNo 3 from "Alice" to "Bob"
*********** equation
eq pop(T,N) = if N == 0 then tail(T) else head(T) ++ pop(tail(T),N - 1) fi .
T --> (msg EOF withSeqNo 4 from "Alice" to "Bob") ++ msg "2" withSeqNo 3 from
    "Alice" to "Bob"
N --> 1
pop((msg EOF withSeqNo 4 from "Alice" to "Bob") ++ msg "2" withSeqNo 3 from
    "Alice" to "Bob",1)
--->
if 1 == 0 then tail((msg EOF withSeqNo 4 from "Alice" to "Bob") ++ msg "2"
    withSeqNo 3 from "Alice" to "Bob") else head((msg EOF withSeqNo 4 from
    "Alice" to "Bob") ++ msg "2" withSeqNo 3 from "Alice" to "Bob") ++ pop(
    tail((msg EOF withSeqNo 4 from "Alice" to "Bob") ++ msg "2" withSeqNo 3
    from "Alice" to "Bob"),1 - 1) fi
*********** equation
(built-in equation for symbol _==_)
1 == 0
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then tail((msg EOF withSeqNo 4 from "Alice" to "Bob") ++ msg "2"
    withSeqNo 3 from "Alice" to "Bob") else head((msg EOF withSeqNo 4 from
    "Alice" to "Bob") ++ msg "2" withSeqNo 3 from "Alice" to "Bob") ++ pop(
    tail((msg EOF withSeqNo 4 from "Alice" to "Bob") ++ msg "2" withSeqNo 3
    from "Alice" to "Bob"),1 - 1) fi
--->
head((msg EOF withSeqNo 4 from "Alice" to "Bob") ++ msg "2" withSeqNo 3 from
    "Alice" to "Bob") ++ pop(tail((msg EOF withSeqNo 4 from "Alice" to "Bob")
    ++ msg "2" withSeqNo 3 from "Alice" to "Bob"),1 - 1)
*********** equation
eq head(H ++ T) = H .
H --> msg EOF withSeqNo 4 from "Alice" to "Bob"
T --> msg "2" withSeqNo 3 from "Alice" to "Bob"
head((msg EOF withSeqNo 4 from "Alice" to "Bob") ++ msg "2" withSeqNo 3 from
    "Alice" to "Bob")
--->
msg EOF withSeqNo 4 from "Alice" to "Bob"
*********** equation
eq tail(H ++ T) = T .
H --> msg EOF withSeqNo 4 from "Alice" to "Bob"
T --> msg "2" withSeqNo 3 from "Alice" to "Bob"
tail((msg EOF withSeqNo 4 from "Alice" to "Bob") ++ msg "2" withSeqNo 3 from
    "Alice" to "Bob")
--->
msg "2" withSeqNo 3 from "Alice" to "Bob"
*********** equation
(built-in equation for symbol _-_)
1 - 1
--->
0
*********** equation
eq pop(T,N) = if N == 0 then tail(T) else head(T) ++ pop(tail(T),N - 1) fi .
T --> msg "2" withSeqNo 3 from "Alice" to "Bob"
N --> 0
pop(msg "2" withSeqNo 3 from "Alice" to "Bob",0)
--->
if 0 == 0 then tail(msg "2" withSeqNo 3 from "Alice" to "Bob") else head(msg
    "2" withSeqNo 3 from "Alice" to "Bob") ++ pop(tail(msg "2" withSeqNo 3 from
    "Alice" to "Bob"),0 - 1) fi
*********** equation
(built-in equation for symbol _==_)
0 == 0
--->
true
*********** equation
(built-in equation for symbol if_then_else_fi)
if true then tail(msg "2" withSeqNo 3 from "Alice" to "Bob") else head(msg "2"
    withSeqNo 3 from "Alice" to "Bob") ++ pop(tail(msg "2" withSeqNo 3 from
    "Alice" to "Bob"),0 - 1) fi
--->
tail(msg "2" withSeqNo 3 from "Alice" to "Bob")
*********** equation
eq tail(H ++ T) = T .
H --> msg "2" withSeqNo 3 from "Alice" to "Bob"
T --> Mnil
tail(msg "2" withSeqNo 3 from "Alice" to "Bob")
--->
Mnil
*********** equation
(built-in equation for symbol _+_)
1 + 6
--->
7
*********** trial #32
crl < O : V:Receiver | Atts:AttributeSet, greatestSeqNoRcvd : N' > msg S
    withSeqNo N from O' to O => < O : V:Receiver | Atts:AttributeSet,
    greatestSeqNoRcvd : N' > msg ack withSeqNo N' from O to O' if N <= N' =
    true [label rcvOldPacket] .
O --> "Bob"
V:Receiver --> Receiver
Atts:AttributeSet --> channel : "C", bufferSize : 2, bufferStart : 3, sender :
    "Alice", msgsRcvd : ("0" "1"), rcvBuffer : (mts mts), rcvCheck : (false
    false), rcvEOF : false, EOFPos : 0
N' --> 2
S --> "2"
N --> 3
O' --> "Alice"
*********** solving condition fragment
N <= N' = true
*********** equation
(built-in equation for symbol _<=_)
3 <= 2
--->
false
*********** failure for condition fragment
N <= N' = true
*********** failure #32
*********** trial #33
crl < O : V:Receiver | Atts:AttributeSet, bufferSize : N1, bufferStart : N0,
    greatestSeqNoRcvd : N', rcvBuffer : SL, rcvCheck : BL > < O2 : V2:Channel |
    Atts2:AttributeSet, count : N2 > msg S withSeqNo N from O' to O => (< O2 :
    V2:Channel | Atts2:AttributeSet, count : s N2 > msg ack withSeqNo N0 +
    lastConsecutiveTrue(assign(BL,N - N0,true)) from O to O') < O : V:Receiver
    | Atts:AttributeSet, bufferSize : N1, bufferStart : N0, greatestSeqNoRcvd :
    N', rcvBuffer : assign(SL,N - N0,S), rcvCheck : assign(BL,N - N0,true) > if
    N >= N' = true /\ N < N0 + N1 = true /\ not S == EOF = true [label
    rcvNewPacket] .
O --> "Bob"
V:Receiver --> Receiver
Atts:AttributeSet --> channel : "C", sender : "Alice", msgsRcvd : ("0" "1"),
    rcvEOF : false, EOFPos : 0
N1 --> 2
N0 --> 3
N' --> 2
SL --> mts mts
BL --> false false
O2 --> "C"
V2:Channel --> Channel
Atts2:AttributeSet --> msgs : msg EOF withSeqNo 4 from "Alice" to "Bob"
N2 --> 7
S --> "2"
N --> 3
O' --> "Alice"
*********** solving condition fragment
N >= N' = true
*********** equation
(built-in equation for symbol _>=_)
3 >= 2
--->
true
*********** success for condition fragment
N >= N' = true
O --> "Bob"
V:Receiver --> Receiver
Atts:AttributeSet --> channel : "C", sender : "Alice", msgsRcvd : ("0" "1"),
    rcvEOF : false, EOFPos : 0
N1 --> 2
N0 --> 3
N' --> 2
SL --> mts mts
BL --> false false
O2 --> "C"
V2:Channel --> Channel
Atts2:AttributeSet --> msgs : msg EOF withSeqNo 4 from "Alice" to "Bob"
N2 --> 7
S --> "2"
N --> 3
O' --> "Alice"
*********** solving condition fragment
N < N0 + N1 = true
*********** equation
(built-in equation for symbol _+_)
2 + 3
--->
5
*********** equation
(built-in equation for symbol _<_)
3 < 5
--->
true
*********** success for condition fragment
N < N0 + N1 = true
O --> "Bob"
V:Receiver --> Receiver
Atts:AttributeSet --> channel : "C", sender : "Alice", msgsRcvd : ("0" "1"),
    rcvEOF : false, EOFPos : 0
N1 --> 2
N0 --> 3
N' --> 2
SL --> mts mts
BL --> false false
O2 --> "C"
V2:Channel --> Channel
Atts2:AttributeSet --> msgs : msg EOF withSeqNo 4 from "Alice" to "Bob"
N2 --> 7
S --> "2"
N --> 3
O' --> "Alice"
*********** solving condition fragment
not S == EOF = true
*********** equation
(built-in equation for symbol _==_)
"2" == EOF
--->
false
*********** equation
eq not A:Bool = true xor A:Bool .
A:Bool --> false
not false
--->
true xor false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> true
true xor false
--->
true
*********** success for condition fragment
not S == EOF = true
O --> "Bob"
V:Receiver --> Receiver
Atts:AttributeSet --> channel : "C", sender : "Alice", msgsRcvd : ("0" "1"),
    rcvEOF : false, EOFPos : 0
N1 --> 2
N0 --> 3
N' --> 2
SL --> mts mts
BL --> false false
O2 --> "C"
V2:Channel --> Channel
Atts2:AttributeSet --> msgs : msg EOF withSeqNo 4 from "Alice" to "Bob"
N2 --> 7
S --> "2"
N --> 3
O' --> "Alice"
*********** success #33
*********** rule
crl < O : V:Receiver | Atts:AttributeSet, bufferSize : N1, bufferStart : N0,
    greatestSeqNoRcvd : N', rcvBuffer : SL, rcvCheck : BL > < O2 : V2:Channel |
    Atts2:AttributeSet, count : N2 > msg S withSeqNo N from O' to O => (< O2 :
    V2:Channel | Atts2:AttributeSet, count : s N2 > msg ack withSeqNo N0 +
    lastConsecutiveTrue(assign(BL,N - N0,true)) from O to O') < O : V:Receiver
    | Atts:AttributeSet, bufferSize : N1, bufferStart : N0, greatestSeqNoRcvd :
    N', rcvBuffer : assign(SL,N - N0,S), rcvCheck : assign(BL,N - N0,true) > if
    N >= N' = true /\ N < N0 + N1 = true /\ not S == EOF = true [label
    rcvNewPacket] .
O --> "Bob"
V:Receiver --> Receiver
Atts:AttributeSet --> channel : "C", sender : "Alice", msgsRcvd : ("0" "1"),
    rcvEOF : false, EOFPos : 0
N1 --> 2
N0 --> 3
N' --> 2
SL --> mts mts
BL --> false false
O2 --> "C"
V2:Channel --> Channel
Atts2:AttributeSet --> msgs : msg EOF withSeqNo 4 from "Alice" to "Bob"
N2 --> 7
S --> "2"
N --> 3
O' --> "Alice"
< "Alice" : Sender | msgsToSend : nil, sendBuffer : msg mts withSeqNo 5 from
    "Alice" to "Bob", currentSeqNo : 5, receiver : "Bob", ackBuffer : (false
    false), numWordsInBuffer : 1, finishSend : true, channel : "C", bufferSize
    : 2, bufferStart : 4, actionCount : 8 > < "Bob" : Receiver | channel : "C",
    bufferSize : 2, bufferStart : 3, greatestSeqNoRcvd : 2, sender : "Alice",
    msgsRcvd : ("0" "1"), rcvBuffer : (mts mts), rcvCheck : (false false),
    rcvEOF : false, EOFPos : 0 > < "C" : Channel | msgs : msg EOF withSeqNo 4
    from "Alice" to "Bob", count : 7 > msg "2" withSeqNo 3 from "Alice" to
    "Bob"
--->
< "Alice" : Sender | msgsToSend : nil, sendBuffer : msg mts withSeqNo 5 from
    "Alice" to "Bob", currentSeqNo : 5, receiver : "Bob", ackBuffer : (false
    false), numWordsInBuffer : 1, finishSend : true, channel : "C", bufferSize
    : 2, bufferStart : 4, actionCount : 8 > (< "C" : Channel | msgs : msg EOF
    withSeqNo 4 from "Alice" to "Bob", count : s 7 > msg ack withSeqNo 3 +
    lastConsecutiveTrue(assign(false false,3 - 3,true)) from "Bob" to "Alice")
    < "Bob" : Receiver | (channel : "C", sender : "Alice", msgsRcvd : ("0"
    "1"), rcvEOF : false, EOFPos : 0), bufferSize : 2, bufferStart : 3,
    greatestSeqNoRcvd : 2, rcvBuffer : assign(mts mts,3 - 3,"2"), rcvCheck :
    assign(false false,3 - 3,true) >
*********** equation
(built-in equation for symbol _-_)
3 - 3
--->
0
*********** equation
eq assign(BL,N:Int,B) = if N:Int < 0 or N:Int >= size(BL) then BL else if N:Int
    == 0 then B tail(BL) else head(BL) assign(tail(BL),N:Int - 1,B) fi fi .
BL --> false false
N:Int --> 0
B --> true
assign(false false,0,true)
--->
if 0 < 0 or 0 >= size(false false) then false false else if 0 == 0 then true
    tail(false false) else head(false false) assign(tail(false false),0 - 1,
    true) fi fi
*********** equation
(built-in equation for symbol _<_)
0 < 0
--->
false
*********** equation
eq size(L:BoolList) = $size(L:BoolList, 0) .
L:BoolList --> false false
size(false false)
--->
$size(false false, 0)
*********** equation
eq $size(E:Bool L:BoolList, C:Nat) = $size(L:BoolList, C:Nat + 1) .
E:Bool --> false
L:BoolList --> false
C:Nat --> 0
$size(false false, 0)
--->
$size(false, 0 + 1)
*********** equation
(built-in equation for symbol _+_)
0 + 1
--->
1
*********** equation
eq $size(E:Bool L:BoolList, C:Nat) = $size(L:BoolList, C:Nat + 1) .
E:Bool --> false
L:BoolList --> (nil).BoolList
C:Nat --> 1
$size(false, 1)
--->
$size((nil).BoolList, 1 + 1)
*********** equation
(built-in equation for symbol _+_)
1 + 1
--->
2
*********** equation
eq $size((nil).BoolList, C:Nat) = C:Nat .
C:Nat --> 2
$size((nil).BoolList, 2)
--->
2
*********** equation
(built-in equation for symbol _>=_)
0 >= 2
--->
false
*********** equation
eq A:Bool or B = A:Bool and B xor A:Bool xor B .
A:Bool --> false
B --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then false false else if 0 == 0 then true tail(false false) else head(
    false false) assign(tail(false false),0 - 1,true) fi fi
--->
if 0 == 0 then true tail(false false) else head(false false) assign(tail(false
    false),0 - 1,true) fi
*********** equation
(built-in equation for symbol _==_)
0 == 0
--->
true
*********** equation
(built-in equation for symbol if_then_else_fi)
if true then true tail(false false) else head(false false) assign(tail(false
    false),0 - 1,true) fi
--->
true tail(false false)
*********** equation
eq tail(E:Bool L:BoolList) = L:BoolList .
E:Bool --> false
L:BoolList --> false
tail(false false)
--->
false
*********** equation
eq lastConsecutiveTrue(BL) = if BL == (nil).BoolList or head(BL) == false then
    -1 else 1 + lastConsecutiveTrue(tail(BL)) fi .
BL --> true false
lastConsecutiveTrue(true false)
--->
if true false == (nil).BoolList or head(true false) == false then -1 else 1 +
    lastConsecutiveTrue(tail(true false)) fi
*********** equation
(built-in equation for symbol _==_)
true false == (nil).BoolList
--->
false
*********** equation
eq head(E:Bool L:BoolList) = E:Bool .
E:Bool --> true
L:BoolList --> false
head(true false)
--->
true
*********** equation
(built-in equation for symbol _==_)
true == false
--->
false
*********** equation
eq A:Bool or B = A:Bool and B xor A:Bool xor B .
A:Bool --> false
B --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then -1 else 1 + lastConsecutiveTrue(tail(true false)) fi
--->
1 + lastConsecutiveTrue(tail(true false))
*********** equation
eq tail(E:Bool L:BoolList) = L:BoolList .
E:Bool --> true
L:BoolList --> false
tail(true false)
--->
false
*********** equation
eq lastConsecutiveTrue(BL) = if BL == (nil).BoolList or head(BL) == false then
    -1 else 1 + lastConsecutiveTrue(tail(BL)) fi .
BL --> false
lastConsecutiveTrue(false)
--->
if false == (nil).BoolList or head(false) == false then -1 else 1 +
    lastConsecutiveTrue(tail(false)) fi
*********** equation
(built-in equation for symbol _==_)
false == (nil).BoolList
--->
false
*********** equation
eq head(E:Bool L:BoolList) = E:Bool .
E:Bool --> false
L:BoolList --> (nil).BoolList
head(false)
--->
false
*********** equation
(built-in equation for symbol _==_)
false == false
--->
true
*********** equation
eq A:Bool or B = A:Bool and B xor A:Bool xor B .
A:Bool --> false
B --> true
true or false
--->
false and true xor false xor true
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> false
true and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> true
true xor false
--->
true
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> true
true xor false
--->
true
*********** equation
(built-in equation for symbol if_then_else_fi)
if true then -1 else 1 + lastConsecutiveTrue(tail(false)) fi
--->
-1
*********** equation
(built-in equation for symbol _+_)
1 + -1
--->
0
*********** equation
(built-in equation for symbol _+_)
0 + 3
--->
3
*********** equation
eq assign(SL,N:Int,S) = if N:Int < 0 or N:Int >= size(SL) then SL else if N:Int
    == 0 then S tail(SL) else head(SL) assign(tail(SL),N:Int - 1,S) fi fi .
SL --> mts mts
N:Int --> 0
S --> "2"
assign(mts mts,0,"2")
--->
if 0 < 0 or 0 >= size(mts mts) then mts mts else if 0 == 0 then "2" tail(mts
    mts) else head(mts mts) assign(tail(mts mts),0 - 1,"2") fi fi
*********** equation
(built-in equation for symbol _<_)
0 < 0
--->
false
*********** equation
eq size(L:StringList) = $size(L:StringList, 0) .
L:StringList --> mts mts
size(mts mts)
--->
$size(mts mts, 0)
*********** equation
eq $size(E:String L:StringList, C:Nat) = $size(L:StringList, C:Nat + 1) .
E:String --> mts
L:StringList --> mts
C:Nat --> 0
$size(mts mts, 0)
--->
$size(mts, 0 + 1)
*********** equation
(built-in equation for symbol _+_)
0 + 1
--->
1
*********** equation
eq $size(E:String L:StringList, C:Nat) = $size(L:StringList, C:Nat + 1) .
E:String --> mts
L:StringList --> (nil).StringList
C:Nat --> 1
$size(mts, 1)
--->
$size((nil).StringList, 1 + 1)
*********** equation
(built-in equation for symbol _+_)
1 + 1
--->
2
*********** equation
eq $size((nil).StringList, C:Nat) = C:Nat .
C:Nat --> 2
$size((nil).StringList, 2)
--->
2
*********** equation
(built-in equation for symbol _>=_)
0 >= 2
--->
false
*********** equation
eq A:Bool or B = A:Bool and B xor A:Bool xor B .
A:Bool --> false
B --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then mts mts else if 0 == 0 then "2" tail(mts mts) else head(mts mts)
    assign(tail(mts mts),0 - 1,"2") fi fi
--->
if 0 == 0 then "2" tail(mts mts) else head(mts mts) assign(tail(mts mts),0 - 1,
    "2") fi
*********** equation
(built-in equation for symbol _==_)
0 == 0
--->
true
*********** equation
(built-in equation for symbol if_then_else_fi)
if true then "2" tail(mts mts) else head(mts mts) assign(tail(mts mts),0 - 1,
    "2") fi
--->
"2" tail(mts mts)
*********** equation
eq tail(E:String L:StringList) = L:StringList .
E:String --> mts
L:StringList --> mts
tail(mts mts)
--->
mts
*********** trial #34
crl < O : V:Sender | Atts:AttributeSet, msgsToSend : nil, sendBuffer : ML,
    currentSeqNo : N', receiver : O', ackBuffer : A:[BoolList],
    numWordsInBuffer : N, finishSend : B, bufferSize : N0, bufferStart : I,
    actionCount : I0 > => < O : V:Sender | Atts:AttributeSet, msgsToSend : nil,
    sendBuffer : (ML ++ msg mts withSeqNo s N' from O to O'), currentSeqNo : s
    N', receiver : O', ackBuffer : n N0 false, numWordsInBuffer : s N,
    finishSend : true, bufferSize : N0, bufferStart : (I + 1), actionCount : (
    I0 + 1) > if not B and N < N0 = true [label load_dummy_word] .
O --> "Alice"
V:Sender --> Sender
Atts:AttributeSet --> channel : "C"
ML --> msg mts withSeqNo 5 from "Alice" to "Bob"
N' --> 5
O' --> "Bob"
A:[BoolList] --> false false
N --> 1
B --> true
N0 --> 2
I --> 4
I0 --> 8
*********** solving condition fragment
not B and N < N0 = true
*********** equation
eq not A:Bool = true xor A:Bool .
A:Bool --> true
not true
--->
true xor true
*********** equation
eq A:Bool xor A:Bool = false .
A:Bool --> true
true xor true
--->
false
*********** equation
(built-in equation for symbol _<_)
1 < 2
--->
true
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> false
true and false
--->
false
*********** failure for condition fragment
not B and N < N0 = true
*********** failure #34
*********** trial #35
crl < O : V:Receiver | Atts:AttributeSet, bufferSize : N0, bufferStart : I0,
    greatestSeqNoRcvd : N, msgsRcvd : SL, rcvBuffer : SL0, rcvCheck : BL,
    rcvEOF : B0, EOFPos : N1 > => < O : V:Receiver | Atts:AttributeSet,
    bufferSize : N0, bufferStart : (N0 + I0), greatestSeqNoRcvd : (N + N0),
    msgsRcvd : (SL SL0), rcvBuffer : n N0 mts, rcvCheck : n N0 false, rcvEOF :
    B0, EOFPos : N1 > if allTrue(BL) or B0 and lastConsecutiveTrue(BL) >= N1 =
    true [label loadWordsFromBuffer] .
O --> "Bob"
V:Receiver --> Receiver
Atts:AttributeSet --> channel : "C", sender : "Alice"
N0 --> 2
I0 --> 3
N --> 2
SL --> "0" "1"
SL0 --> "2" mts
BL --> true false
B0 --> false
N1 --> 0
*********** solving condition fragment
allTrue(BL) or B0 and lastConsecutiveTrue(BL) >= N1 = true
*********** equation
eq allTrue(B BL) = allTrue(BL) and allTrue(B) .
B --> true
BL --> false
allTrue(true false)
--->
allTrue(false) and allTrue(true)
*********** equation
eq allTrue(B) = B .
B --> false
allTrue(false)
--->
false
*********** equation
eq allTrue(B) = B .
B --> true
allTrue(true)
--->
true
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> false
true and false
--->
false
*********** equation
eq lastConsecutiveTrue(BL) = if BL == (nil).BoolList or head(BL) == false then
    -1 else 1 + lastConsecutiveTrue(tail(BL)) fi .
BL --> true false
lastConsecutiveTrue(true false)
--->
if true false == (nil).BoolList or head(true false) == false then -1 else 1 +
    lastConsecutiveTrue(tail(true false)) fi
*********** equation
(built-in equation for symbol _==_)
true false == (nil).BoolList
--->
false
*********** equation
eq head(E:Bool L:BoolList) = E:Bool .
E:Bool --> true
L:BoolList --> false
head(true false)
--->
true
*********** equation
(built-in equation for symbol _==_)
true == false
--->
false
*********** equation
eq A:Bool or B = A:Bool and B xor A:Bool xor B .
A:Bool --> false
B --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then -1 else 1 + lastConsecutiveTrue(tail(true false)) fi
--->
1 + lastConsecutiveTrue(tail(true false))
*********** equation
eq tail(E:Bool L:BoolList) = L:BoolList .
E:Bool --> true
L:BoolList --> false
tail(true false)
--->
false
*********** equation
eq lastConsecutiveTrue(BL) = if BL == (nil).BoolList or head(BL) == false then
    -1 else 1 + lastConsecutiveTrue(tail(BL)) fi .
BL --> false
lastConsecutiveTrue(false)
--->
if false == (nil).BoolList or head(false) == false then -1 else 1 +
    lastConsecutiveTrue(tail(false)) fi
*********** equation
(built-in equation for symbol _==_)
false == (nil).BoolList
--->
false
*********** equation
eq head(E:Bool L:BoolList) = E:Bool .
E:Bool --> false
L:BoolList --> (nil).BoolList
head(false)
--->
false
*********** equation
(built-in equation for symbol _==_)
false == false
--->
true
*********** equation
eq A:Bool or B = A:Bool and B xor A:Bool xor B .
A:Bool --> false
B --> true
true or false
--->
false and true xor false xor true
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> false
true and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> true
true xor false
--->
true
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> true
true xor false
--->
true
*********** equation
(built-in equation for symbol if_then_else_fi)
if true then -1 else 1 + lastConsecutiveTrue(tail(false)) fi
--->
-1
*********** equation
(built-in equation for symbol _+_)
1 + -1
--->
0
*********** equation
(built-in equation for symbol _>=_)
0 >= 0
--->
true
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> false
true and false
--->
false
*********** equation
eq A:Bool or B = A:Bool and B xor A:Bool xor B .
A:Bool --> false
B --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** failure for condition fragment
allTrue(BL) or B0 and lastConsecutiveTrue(BL) >= N1 = true
*********** failure #35
*********** trial #36
crl < O : V:Receiver | Atts:AttributeSet, msgsRcvd : (SL S0) > => < O :
    V:Receiver | Atts:AttributeSet, msgsRcvd : SL > if S0 == mts = true [label
    rmEmptyString] .
O --> "Bob"
V:Receiver --> Receiver
Atts:AttributeSet --> channel : "C", bufferSize : 2, bufferStart : 3,
    greatestSeqNoRcvd : 2, sender : "Alice", rcvBuffer : ("2" mts), rcvCheck :
    (true false), rcvEOF : false, EOFPos : 0
SL --> "0"
S0 --> "1"
*********** solving condition fragment
S0 == mts = true
*********** equation
(built-in equation for symbol _==_)
"1" == mts
--->
false
*********** failure for condition fragment
S0 == mts = true
*********** failure #36
*********** trial #37
crl < O : V:Channel | Atts:AttributeSet, msgs : ML, count : N > => (ML[random(
    N) rem size(ML)]) < O : V:Channel | Atts:AttributeSet, msgs : pop(ML,
    random(N) rem size(ML)), count : (N + 1) > if size(ML) > 0 = true [label
    convey-msg] .
O --> "C"
V:Channel --> Channel
Atts:AttributeSet --> (none).AttributeSet
ML --> msg EOF withSeqNo 4 from "Alice" to "Bob"
N --> 8
*********** solving condition fragment
size(ML) > 0 = true
*********** equation
eq size(T) = if T == Mnil then 0 else 1 + size(tail(T)) fi .
T --> msg EOF withSeqNo 4 from "Alice" to "Bob"
size(msg EOF withSeqNo 4 from "Alice" to "Bob")
--->
if msg EOF withSeqNo 4 from "Alice" to "Bob" == Mnil then 0 else 1 + size(tail(
    msg EOF withSeqNo 4 from "Alice" to "Bob")) fi
*********** equation
(built-in equation for symbol _==_)
msg EOF withSeqNo 4 from "Alice" to "Bob" == Mnil
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then 0 else 1 + size(tail(msg EOF withSeqNo 4 from "Alice" to "Bob"))
    fi
--->
1 + size(tail(msg EOF withSeqNo 4 from "Alice" to "Bob"))
*********** equation
eq tail(H ++ T) = T .
H --> msg EOF withSeqNo 4 from "Alice" to "Bob"
T --> Mnil
tail(msg EOF withSeqNo 4 from "Alice" to "Bob")
--->
Mnil
*********** equation
eq size(T) = if T == Mnil then 0 else 1 + size(tail(T)) fi .
T --> Mnil
size(Mnil)
--->
if Mnil == Mnil then 0 else 1 + size(tail(Mnil)) fi
*********** equation
(built-in equation for symbol _==_)
Mnil == Mnil
--->
true
*********** equation
(built-in equation for symbol if_then_else_fi)
if true then 0 else 1 + size(tail(Mnil)) fi
--->
0
*********** equation
(built-in equation for symbol _+_)
0 + 1
--->
1
*********** equation
(built-in equation for symbol _>_)
1 > 0
--->
true
*********** success for condition fragment
size(ML) > 0 = true
O --> "C"
V:Channel --> Channel
Atts:AttributeSet --> (none).AttributeSet
ML --> msg EOF withSeqNo 4 from "Alice" to "Bob"
N --> 8
*********** success #37
*********** rule
crl < O : V:Channel | Atts:AttributeSet, msgs : ML, count : N > => (ML[random(
    N) rem size(ML)]) < O : V:Channel | Atts:AttributeSet, msgs : pop(ML,
    random(N) rem size(ML)), count : (N + 1) > if size(ML) > 0 = true [label
    convey-msg] .
O --> "C"
V:Channel --> Channel
Atts:AttributeSet --> (none).AttributeSet
ML --> msg EOF withSeqNo 4 from "Alice" to "Bob"
N --> 8
< "C" : Channel | msgs : msg EOF withSeqNo 4 from "Alice" to "Bob", count : 8 >
--->
(msg EOF withSeqNo 4 from "Alice" to "Bob"[random(8) rem 1]) < "C" : Channel |
    none, msgs : pop(msg EOF withSeqNo 4 from "Alice" to "Bob",random(8) rem
    1), count : (8 + 1) >
*********** equation
(built-in equation for symbol random)
random(8)
--->
1819583497
*********** equation
(built-in equation for symbol _rem_)
1819583497 rem 1
--->
0
*********** equation
eq T[N] = if N <= 0 then if N == 0 then head(T) else Mnil fi else tail(T)[N -
    1] fi .
T --> msg EOF withSeqNo 4 from "Alice" to "Bob"
N --> 0
msg EOF withSeqNo 4 from "Alice" to "Bob"[0]
--->
if 0 <= 0 then if 0 == 0 then head(msg EOF withSeqNo 4 from "Alice" to "Bob")
    else Mnil fi else tail(msg EOF withSeqNo 4 from "Alice" to "Bob")[0 - 1] fi
*********** equation
(built-in equation for symbol _<=_)
0 <= 0
--->
true
*********** equation
(built-in equation for symbol if_then_else_fi)
if true then if 0 == 0 then head(msg EOF withSeqNo 4 from "Alice" to "Bob")
    else Mnil fi else tail(msg EOF withSeqNo 4 from "Alice" to "Bob")[0 - 1] fi
--->
if 0 == 0 then head(msg EOF withSeqNo 4 from "Alice" to "Bob") else Mnil fi
*********** equation
(built-in equation for symbol _==_)
0 == 0
--->
true
*********** equation
(built-in equation for symbol if_then_else_fi)
if true then head(msg EOF withSeqNo 4 from "Alice" to "Bob") else Mnil fi
--->
head(msg EOF withSeqNo 4 from "Alice" to "Bob")
*********** equation
eq head(H ++ T) = H .
H --> msg EOF withSeqNo 4 from "Alice" to "Bob"
T --> Mnil
head(msg EOF withSeqNo 4 from "Alice" to "Bob")
--->
msg EOF withSeqNo 4 from "Alice" to "Bob"
*********** equation
eq pop(T,N) = if N == 0 then tail(T) else head(T) ++ pop(tail(T),N - 1) fi .
T --> msg EOF withSeqNo 4 from "Alice" to "Bob"
N --> 0
pop(msg EOF withSeqNo 4 from "Alice" to "Bob",0)
--->
if 0 == 0 then tail(msg EOF withSeqNo 4 from "Alice" to "Bob") else head(msg
    EOF withSeqNo 4 from "Alice" to "Bob") ++ pop(tail(msg EOF withSeqNo 4 from
    "Alice" to "Bob"),0 - 1) fi
*********** equation
(built-in equation for symbol _==_)
0 == 0
--->
true
*********** equation
(built-in equation for symbol if_then_else_fi)
if true then tail(msg EOF withSeqNo 4 from "Alice" to "Bob") else head(msg EOF
    withSeqNo 4 from "Alice" to "Bob") ++ pop(tail(msg EOF withSeqNo 4 from
    "Alice" to "Bob"),0 - 1) fi
--->
tail(msg EOF withSeqNo 4 from "Alice" to "Bob")
*********** equation
eq tail(H ++ T) = T .
H --> msg EOF withSeqNo 4 from "Alice" to "Bob"
T --> Mnil
tail(msg EOF withSeqNo 4 from "Alice" to "Bob")
--->
Mnil
*********** equation
(built-in equation for symbol _+_)
1 + 8
--->
9
*********** trial #38
crl < O : V:Receiver | Atts:AttributeSet, bufferSize : N1, bufferStart : N0,
    greatestSeqNoRcvd : N', rcvBuffer : SL, rcvCheck : BL, rcvEOF : A:[
    BoolList], EOFPos : A2:[Int,FindResult] > msg EOF withSeqNo N from O' to O
    => < O : V:Receiver | Atts:AttributeSet, bufferSize : N1, bufferStart : N0,
    greatestSeqNoRcvd : N', rcvBuffer : assign(SL,N - N0,EOF), rcvCheck :
    assign(BL,N - N0,true), rcvEOF : true, EOFPos : (N - N0) > msg ack
    withSeqNo N0 + lastConsecutiveTrue(assign(BL,N - N0,true)) from O to O' if
    N >= N' = true /\ N < N0 + N1 = true [label rcvEOFPacket] .
O --> "Bob"
V:Receiver --> Receiver
Atts:AttributeSet --> channel : "C", sender : "Alice", msgsRcvd : ("0" "1")
N1 --> 2
N0 --> 3
N' --> 2
SL --> "2" mts
BL --> true false
A:[BoolList] --> false
A2:[Int,FindResult] --> 0
N --> 4
O' --> "Alice"
*********** solving condition fragment
N >= N' = true
*********** equation
(built-in equation for symbol _>=_)
4 >= 2
--->
true
*********** success for condition fragment
N >= N' = true
O --> "Bob"
V:Receiver --> Receiver
Atts:AttributeSet --> channel : "C", sender : "Alice", msgsRcvd : ("0" "1")
N1 --> 2
N0 --> 3
N' --> 2
SL --> "2" mts
BL --> true false
A:[BoolList] --> false
A2:[Int,FindResult] --> 0
N --> 4
O' --> "Alice"
*********** solving condition fragment
N < N0 + N1 = true
*********** equation
(built-in equation for symbol _+_)
2 + 3
--->
5
*********** equation
(built-in equation for symbol _<_)
4 < 5
--->
true
*********** success for condition fragment
N < N0 + N1 = true
O --> "Bob"
V:Receiver --> Receiver
Atts:AttributeSet --> channel : "C", sender : "Alice", msgsRcvd : ("0" "1")
N1 --> 2
N0 --> 3
N' --> 2
SL --> "2" mts
BL --> true false
A:[BoolList] --> false
A2:[Int,FindResult] --> 0
N --> 4
O' --> "Alice"
*********** success #38
*********** rule
crl < O : V:Receiver | Atts:AttributeSet, bufferSize : N1, bufferStart : N0,
    greatestSeqNoRcvd : N', rcvBuffer : SL, rcvCheck : BL, rcvEOF : A:[
    BoolList], EOFPos : A2:[Int,FindResult] > msg EOF withSeqNo N from O' to O
    => < O : V:Receiver | Atts:AttributeSet, bufferSize : N1, bufferStart : N0,
    greatestSeqNoRcvd : N', rcvBuffer : assign(SL,N - N0,EOF), rcvCheck :
    assign(BL,N - N0,true), rcvEOF : true, EOFPos : (N - N0) > msg ack
    withSeqNo N0 + lastConsecutiveTrue(assign(BL,N - N0,true)) from O to O' if
    N >= N' = true /\ N < N0 + N1 = true [label rcvEOFPacket] .
O --> "Bob"
V:Receiver --> Receiver
Atts:AttributeSet --> channel : "C", sender : "Alice", msgsRcvd : ("0" "1")
N1 --> 2
N0 --> 3
N' --> 2
SL --> "2" mts
BL --> true false
A:[BoolList] --> false
A2:[Int,FindResult] --> 0
N --> 4
O' --> "Alice"
< "Alice" : Sender | msgsToSend : nil, sendBuffer : msg mts withSeqNo 5 from
    "Alice" to "Bob", currentSeqNo : 5, receiver : "Bob", ackBuffer : (false
    false), numWordsInBuffer : 1, finishSend : true, channel : "C", bufferSize
    : 2, bufferStart : 4, actionCount : 8 > < "Bob" : Receiver | channel : "C",
    bufferSize : 2, bufferStart : 3, greatestSeqNoRcvd : 2, sender : "Alice",
    msgsRcvd : ("0" "1"), rcvBuffer : ("2" mts), rcvCheck : (true false),
    rcvEOF : false, EOFPos : 0 > < "C" : Channel | msgs : Mnil, count : 9 > (
    msg EOF withSeqNo 4 from "Alice" to "Bob") msg ack withSeqNo 3 from "Bob"
    to "Alice"
--->
(< "Alice" : Sender | msgsToSend : nil, sendBuffer : msg mts withSeqNo 5 from
    "Alice" to "Bob", currentSeqNo : 5, receiver : "Bob", ackBuffer : (false
    false), numWordsInBuffer : 1, finishSend : true, channel : "C", bufferSize
    : 2, bufferStart : 4, actionCount : 8 > < "C" : Channel | msgs : Mnil,
    count : 9 > msg ack withSeqNo 3 from "Bob" to "Alice") < "Bob" : Receiver |
    (channel : "C", sender : "Alice", msgsRcvd : ("0" "1")), bufferSize : 2,
    bufferStart : 3, greatestSeqNoRcvd : 2, rcvBuffer : assign("2" mts,4 - 3,
    EOF), rcvCheck : assign(true false,4 - 3,true), rcvEOF : true, EOFPos : (4
    - 3) > msg ack withSeqNo 3 + lastConsecutiveTrue(assign(true false,4 - 3,
    true)) from "Bob" to "Alice"
*********** equation
(built-in equation for symbol _-_)
4 - 3
--->
1
*********** equation
eq assign(SL,N:Int,S) = if N:Int < 0 or N:Int >= size(SL) then SL else if N:Int
    == 0 then S tail(SL) else head(SL) assign(tail(SL),N:Int - 1,S) fi fi .
SL --> "2" mts
N:Int --> 1
S --> EOF
assign("2" mts,1,EOF)
--->
if 1 < 0 or 1 >= size("2" mts) then "2" mts else if 1 == 0 then EOF tail("2"
    mts) else head("2" mts) assign(tail("2" mts),1 - 1,EOF) fi fi
*********** equation
(built-in equation for symbol _<_)
1 < 0
--->
false
*********** equation
eq size(L:StringList) = $size(L:StringList, 0) .
L:StringList --> "2" mts
size("2" mts)
--->
$size("2" mts, 0)
*********** equation
eq $size(E:String L:StringList, C:Nat) = $size(L:StringList, C:Nat + 1) .
E:String --> "2"
L:StringList --> mts
C:Nat --> 0
$size("2" mts, 0)
--->
$size(mts, 0 + 1)
*********** equation
(built-in equation for symbol _+_)
0 + 1
--->
1
*********** equation
eq $size(E:String L:StringList, C:Nat) = $size(L:StringList, C:Nat + 1) .
E:String --> mts
L:StringList --> (nil).StringList
C:Nat --> 1
$size(mts, 1)
--->
$size((nil).StringList, 1 + 1)
*********** equation
(built-in equation for symbol _+_)
1 + 1
--->
2
*********** equation
eq $size((nil).StringList, C:Nat) = C:Nat .
C:Nat --> 2
$size((nil).StringList, 2)
--->
2
*********** equation
(built-in equation for symbol _>=_)
1 >= 2
--->
false
*********** equation
eq A:Bool or B = A:Bool and B xor A:Bool xor B .
A:Bool --> false
B --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then "2" mts else if 1 == 0 then EOF tail("2" mts) else head("2" mts)
    assign(tail("2" mts),1 - 1,EOF) fi fi
--->
if 1 == 0 then EOF tail("2" mts) else head("2" mts) assign(tail("2" mts),1 - 1,
    EOF) fi
*********** equation
(built-in equation for symbol _==_)
1 == 0
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then EOF tail("2" mts) else head("2" mts) assign(tail("2" mts),1 - 1,
    EOF) fi
--->
head("2" mts) assign(tail("2" mts),1 - 1,EOF)
*********** equation
eq head(E:String L:StringList) = E:String .
E:String --> "2"
L:StringList --> mts
head("2" mts)
--->
"2"
*********** equation
eq tail(E:String L:StringList) = L:StringList .
E:String --> "2"
L:StringList --> mts
tail("2" mts)
--->
mts
*********** equation
(built-in equation for symbol _-_)
1 - 1
--->
0
*********** equation
eq assign(SL,N:Int,S) = if N:Int < 0 or N:Int >= size(SL) then SL else if N:Int
    == 0 then S tail(SL) else head(SL) assign(tail(SL),N:Int - 1,S) fi fi .
SL --> mts
N:Int --> 0
S --> EOF
assign(mts,0,EOF)
--->
if 0 < 0 or 0 >= size(mts) then mts else if 0 == 0 then EOF tail(mts) else
    head(mts) assign(tail(mts),0 - 1,EOF) fi fi
*********** equation
(built-in equation for symbol _<_)
0 < 0
--->
false
*********** equation
eq size(L:StringList) = $size(L:StringList, 0) .
L:StringList --> mts
size(mts)
--->
$size(mts, 0)
*********** equation
eq $size(E:String L:StringList, C:Nat) = $size(L:StringList, C:Nat + 1) .
E:String --> mts
L:StringList --> (nil).StringList
C:Nat --> 0
$size(mts, 0)
--->
$size((nil).StringList, 0 + 1)
*********** equation
(built-in equation for symbol _+_)
0 + 1
--->
1
*********** equation
eq $size((nil).StringList, C:Nat) = C:Nat .
C:Nat --> 1
$size((nil).StringList, 1)
--->
1
*********** equation
(built-in equation for symbol _>=_)
0 >= 1
--->
false
*********** equation
eq A:Bool or B = A:Bool and B xor A:Bool xor B .
A:Bool --> false
B --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then mts else if 0 == 0 then EOF tail(mts) else head(mts) assign(tail(
    mts),0 - 1,EOF) fi fi
--->
if 0 == 0 then EOF tail(mts) else head(mts) assign(tail(mts),0 - 1,EOF) fi
*********** equation
(built-in equation for symbol _==_)
0 == 0
--->
true
*********** equation
(built-in equation for symbol if_then_else_fi)
if true then EOF tail(mts) else head(mts) assign(tail(mts),0 - 1,EOF) fi
--->
EOF tail(mts)
*********** equation
eq tail(E:String L:StringList) = L:StringList .
E:String --> mts
L:StringList --> (nil).StringList
tail(mts)
--->
(nil).StringList
*********** equation
eq assign(BL,N:Int,B) = if N:Int < 0 or N:Int >= size(BL) then BL else if N:Int
    == 0 then B tail(BL) else head(BL) assign(tail(BL),N:Int - 1,B) fi fi .
BL --> true false
N:Int --> 1
B --> true
assign(true false,1,true)
--->
if 1 < 0 or 1 >= size(true false) then true false else if 1 == 0 then true
    tail(true false) else head(true false) assign(tail(true false),1 - 1,true)
    fi fi
*********** equation
(built-in equation for symbol _<_)
1 < 0
--->
false
*********** equation
eq size(L:BoolList) = $size(L:BoolList, 0) .
L:BoolList --> true false
size(true false)
--->
$size(true false, 0)
*********** equation
eq $size(E:Bool L:BoolList, C:Nat) = $size(L:BoolList, C:Nat + 1) .
E:Bool --> true
L:BoolList --> false
C:Nat --> 0
$size(true false, 0)
--->
$size(false, 0 + 1)
*********** equation
(built-in equation for symbol _+_)
0 + 1
--->
1
*********** equation
eq $size(E:Bool L:BoolList, C:Nat) = $size(L:BoolList, C:Nat + 1) .
E:Bool --> false
L:BoolList --> (nil).BoolList
C:Nat --> 1
$size(false, 1)
--->
$size((nil).BoolList, 1 + 1)
*********** equation
(built-in equation for symbol _+_)
1 + 1
--->
2
*********** equation
eq $size((nil).BoolList, C:Nat) = C:Nat .
C:Nat --> 2
$size((nil).BoolList, 2)
--->
2
*********** equation
(built-in equation for symbol _>=_)
1 >= 2
--->
false
*********** equation
eq A:Bool or B = A:Bool and B xor A:Bool xor B .
A:Bool --> false
B --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then true false else if 1 == 0 then true tail(true false) else head(
    true false) assign(tail(true false),1 - 1,true) fi fi
--->
if 1 == 0 then true tail(true false) else head(true false) assign(tail(true
    false),1 - 1,true) fi
*********** equation
(built-in equation for symbol _==_)
1 == 0
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then true tail(true false) else head(true false) assign(tail(true
    false),1 - 1,true) fi
--->
head(true false) assign(tail(true false),1 - 1,true)
*********** equation
eq head(E:Bool L:BoolList) = E:Bool .
E:Bool --> true
L:BoolList --> false
head(true false)
--->
true
*********** equation
eq tail(E:Bool L:BoolList) = L:BoolList .
E:Bool --> true
L:BoolList --> false
tail(true false)
--->
false
*********** equation
(built-in equation for symbol _-_)
1 - 1
--->
0
*********** equation
eq assign(BL,N:Int,B) = if N:Int < 0 or N:Int >= size(BL) then BL else if N:Int
    == 0 then B tail(BL) else head(BL) assign(tail(BL),N:Int - 1,B) fi fi .
BL --> false
N:Int --> 0
B --> true
assign(false,0,true)
--->
if 0 < 0 or 0 >= size(false) then false else if 0 == 0 then true tail(false)
    else head(false) assign(tail(false),0 - 1,true) fi fi
*********** equation
(built-in equation for symbol _<_)
0 < 0
--->
false
*********** equation
eq size(L:BoolList) = $size(L:BoolList, 0) .
L:BoolList --> false
size(false)
--->
$size(false, 0)
*********** equation
eq $size(E:Bool L:BoolList, C:Nat) = $size(L:BoolList, C:Nat + 1) .
E:Bool --> false
L:BoolList --> (nil).BoolList
C:Nat --> 0
$size(false, 0)
--->
$size((nil).BoolList, 0 + 1)
*********** equation
(built-in equation for symbol _+_)
0 + 1
--->
1
*********** equation
eq $size((nil).BoolList, C:Nat) = C:Nat .
C:Nat --> 1
$size((nil).BoolList, 1)
--->
1
*********** equation
(built-in equation for symbol _>=_)
0 >= 1
--->
false
*********** equation
eq A:Bool or B = A:Bool and B xor A:Bool xor B .
A:Bool --> false
B --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then false else if 0 == 0 then true tail(false) else head(false)
    assign(tail(false),0 - 1,true) fi fi
--->
if 0 == 0 then true tail(false) else head(false) assign(tail(false),0 - 1,true)
    fi
*********** equation
(built-in equation for symbol _==_)
0 == 0
--->
true
*********** equation
(built-in equation for symbol if_then_else_fi)
if true then true tail(false) else head(false) assign(tail(false),0 - 1,true)
    fi
--->
true tail(false)
*********** equation
eq tail(E:Bool L:BoolList) = L:BoolList .
E:Bool --> false
L:BoolList --> (nil).BoolList
tail(false)
--->
(nil).BoolList
*********** equation
eq lastConsecutiveTrue(BL) = if BL == (nil).BoolList or head(BL) == false then
    -1 else 1 + lastConsecutiveTrue(tail(BL)) fi .
BL --> true true
lastConsecutiveTrue(true true)
--->
if true true == (nil).BoolList or head(true true) == false then -1 else 1 +
    lastConsecutiveTrue(tail(true true)) fi
*********** equation
(built-in equation for symbol _==_)
true true == (nil).BoolList
--->
false
*********** equation
eq head(E:Bool L:BoolList) = E:Bool .
E:Bool --> true
L:BoolList --> true
head(true true)
--->
true
*********** equation
(built-in equation for symbol _==_)
true == false
--->
false
*********** equation
eq A:Bool or B = A:Bool and B xor A:Bool xor B .
A:Bool --> false
B --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then -1 else 1 + lastConsecutiveTrue(tail(true true)) fi
--->
1 + lastConsecutiveTrue(tail(true true))
*********** equation
eq tail(E:Bool L:BoolList) = L:BoolList .
E:Bool --> true
L:BoolList --> true
tail(true true)
--->
true
*********** equation
eq lastConsecutiveTrue(BL) = if BL == (nil).BoolList or head(BL) == false then
    -1 else 1 + lastConsecutiveTrue(tail(BL)) fi .
BL --> true
lastConsecutiveTrue(true)
--->
if true == (nil).BoolList or head(true) == false then -1 else 1 +
    lastConsecutiveTrue(tail(true)) fi
*********** equation
(built-in equation for symbol _==_)
true == (nil).BoolList
--->
false
*********** equation
eq head(E:Bool L:BoolList) = E:Bool .
E:Bool --> true
L:BoolList --> (nil).BoolList
head(true)
--->
true
*********** equation
(built-in equation for symbol _==_)
true == false
--->
false
*********** equation
eq A:Bool or B = A:Bool and B xor A:Bool xor B .
A:Bool --> false
B --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then -1 else 1 + lastConsecutiveTrue(tail(true)) fi
--->
1 + lastConsecutiveTrue(tail(true))
*********** equation
eq tail(E:Bool L:BoolList) = L:BoolList .
E:Bool --> true
L:BoolList --> (nil).BoolList
tail(true)
--->
(nil).BoolList
*********** equation
eq lastConsecutiveTrue(BL) = if BL == (nil).BoolList or head(BL) == false then
    -1 else 1 + lastConsecutiveTrue(tail(BL)) fi .
BL --> (nil).BoolList
lastConsecutiveTrue(nil)
--->
if (nil).BoolList == (nil).BoolList or head((nil).BoolList) == false then -1
    else 1 + lastConsecutiveTrue(tail(nil)) fi
*********** equation
(built-in equation for symbol _==_)
(nil).BoolList == (nil).BoolList
--->
true
*********** equation
eq head((nil).BoolList) = (nil).BoolList .
empty substitution
head((nil).BoolList)
--->
(nil).BoolList
*********** equation
(built-in equation for symbol _==_)
(nil).BoolList == false
--->
false
*********** equation
eq A:Bool or B = A:Bool and B xor A:Bool xor B .
A:Bool --> false
B --> true
true or false
--->
false and true xor false xor true
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> false
true and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> true
true xor false
--->
true
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> true
true xor false
--->
true
*********** equation
(built-in equation for symbol if_then_else_fi)
if true then -1 else 1 + lastConsecutiveTrue(tail(nil)) fi
--->
-1
*********** equation
(built-in equation for symbol _+_)
1 + -1
--->
0
*********** equation
(built-in equation for symbol _+_)
0 + 1
--->
1
*********** equation
(built-in equation for symbol _+_)
1 + 3
--->
4
*********** trial #39
crl < O : V:Receiver | Atts:AttributeSet, bufferSize : N0, bufferStart : I0,
    greatestSeqNoRcvd : N, msgsRcvd : SL, rcvBuffer : SL0, rcvCheck : BL,
    rcvEOF : B0, EOFPos : N1 > => < O : V:Receiver | Atts:AttributeSet,
    bufferSize : N0, bufferStart : (N0 + I0), greatestSeqNoRcvd : (N + N0),
    msgsRcvd : (SL SL0), rcvBuffer : n N0 mts, rcvCheck : n N0 false, rcvEOF :
    B0, EOFPos : N1 > if allTrue(BL) or B0 and lastConsecutiveTrue(BL) >= N1 =
    true [label loadWordsFromBuffer] .
O --> "Bob"
V:Receiver --> Receiver
Atts:AttributeSet --> channel : "C", sender : "Alice"
N0 --> 2
I0 --> 3
N --> 2
SL --> "0" "1"
SL0 --> "2" EOF
BL --> true true
B0 --> true
N1 --> 1
*********** solving condition fragment
allTrue(BL) or B0 and lastConsecutiveTrue(BL) >= N1 = true
*********** equation
eq allTrue(B BL) = allTrue(BL) and allTrue(B) .
B --> true
BL --> true
allTrue(true true)
--->
allTrue(true) and allTrue(true)
*********** equation
eq allTrue(B) = B .
B --> true
allTrue(true)
--->
true
*********** equation
eq allTrue(B) = B .
B --> true
allTrue(true)
--->
true
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> true
true and true
--->
true
*********** equation
eq lastConsecutiveTrue(BL) = if BL == (nil).BoolList or head(BL) == false then
    -1 else 1 + lastConsecutiveTrue(tail(BL)) fi .
BL --> true true
lastConsecutiveTrue(true true)
--->
if true true == (nil).BoolList or head(true true) == false then -1 else 1 +
    lastConsecutiveTrue(tail(true true)) fi
*********** equation
(built-in equation for symbol _==_)
true true == (nil).BoolList
--->
false
*********** equation
eq head(E:Bool L:BoolList) = E:Bool .
E:Bool --> true
L:BoolList --> true
head(true true)
--->
true
*********** equation
(built-in equation for symbol _==_)
true == false
--->
false
*********** equation
eq A:Bool or B = A:Bool and B xor A:Bool xor B .
A:Bool --> false
B --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then -1 else 1 + lastConsecutiveTrue(tail(true true)) fi
--->
1 + lastConsecutiveTrue(tail(true true))
*********** equation
eq tail(E:Bool L:BoolList) = L:BoolList .
E:Bool --> true
L:BoolList --> true
tail(true true)
--->
true
*********** equation
eq lastConsecutiveTrue(BL) = if BL == (nil).BoolList or head(BL) == false then
    -1 else 1 + lastConsecutiveTrue(tail(BL)) fi .
BL --> true
lastConsecutiveTrue(true)
--->
if true == (nil).BoolList or head(true) == false then -1 else 1 +
    lastConsecutiveTrue(tail(true)) fi
*********** equation
(built-in equation for symbol _==_)
true == (nil).BoolList
--->
false
*********** equation
eq head(E:Bool L:BoolList) = E:Bool .
E:Bool --> true
L:BoolList --> (nil).BoolList
head(true)
--->
true
*********** equation
(built-in equation for symbol _==_)
true == false
--->
false
*********** equation
eq A:Bool or B = A:Bool and B xor A:Bool xor B .
A:Bool --> false
B --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then -1 else 1 + lastConsecutiveTrue(tail(true)) fi
--->
1 + lastConsecutiveTrue(tail(true))
*********** equation
eq tail(E:Bool L:BoolList) = L:BoolList .
E:Bool --> true
L:BoolList --> (nil).BoolList
tail(true)
--->
(nil).BoolList
*********** equation
eq lastConsecutiveTrue(BL) = if BL == (nil).BoolList or head(BL) == false then
    -1 else 1 + lastConsecutiveTrue(tail(BL)) fi .
BL --> (nil).BoolList
lastConsecutiveTrue(nil)
--->
if (nil).BoolList == (nil).BoolList or head((nil).BoolList) == false then -1
    else 1 + lastConsecutiveTrue(tail(nil)) fi
*********** equation
(built-in equation for symbol _==_)
(nil).BoolList == (nil).BoolList
--->
true
*********** equation
eq head((nil).BoolList) = (nil).BoolList .
empty substitution
head((nil).BoolList)
--->
(nil).BoolList
*********** equation
(built-in equation for symbol _==_)
(nil).BoolList == false
--->
false
*********** equation
eq A:Bool or B = A:Bool and B xor A:Bool xor B .
A:Bool --> false
B --> true
true or false
--->
false and true xor false xor true
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> false
true and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> true
true xor false
--->
true
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> true
true xor false
--->
true
*********** equation
(built-in equation for symbol if_then_else_fi)
if true then -1 else 1 + lastConsecutiveTrue(tail(nil)) fi
--->
-1
*********** equation
(built-in equation for symbol _+_)
1 + -1
--->
0
*********** equation
(built-in equation for symbol _+_)
0 + 1
--->
1
*********** equation
(built-in equation for symbol _>=_)
1 >= 1
--->
true
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> true
true and true
--->
true
*********** equation
eq A:Bool or B = A:Bool and B xor A:Bool xor B .
A:Bool --> true
B --> true
true or true
--->
true and true xor true xor true
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> true
true and true
--->
true
*********** equation
eq A:Bool xor A:Bool = false .
A:Bool --> true
true xor true
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> true
true xor false
--->
true
*********** success for condition fragment
allTrue(BL) or B0 and lastConsecutiveTrue(BL) >= N1 = true
O --> "Bob"
V:Receiver --> Receiver
Atts:AttributeSet --> channel : "C", sender : "Alice"
N0 --> 2
I0 --> 3
N --> 2
SL --> "0" "1"
SL0 --> "2" EOF
BL --> true true
B0 --> true
N1 --> 1
*********** success #39
*********** rule
crl < O : V:Receiver | Atts:AttributeSet, bufferSize : N0, bufferStart : I0,
    greatestSeqNoRcvd : N, msgsRcvd : SL, rcvBuffer : SL0, rcvCheck : BL,
    rcvEOF : B0, EOFPos : N1 > => < O : V:Receiver | Atts:AttributeSet,
    bufferSize : N0, bufferStart : (N0 + I0), greatestSeqNoRcvd : (N + N0),
    msgsRcvd : (SL SL0), rcvBuffer : n N0 mts, rcvCheck : n N0 false, rcvEOF :
    B0, EOFPos : N1 > if allTrue(BL) or B0 and lastConsecutiveTrue(BL) >= N1 =
    true [label loadWordsFromBuffer] .
O --> "Bob"
V:Receiver --> Receiver
Atts:AttributeSet --> channel : "C", sender : "Alice"
N0 --> 2
I0 --> 3
N --> 2
SL --> "0" "1"
SL0 --> "2" EOF
BL --> true true
B0 --> true
N1 --> 1
< "Bob" : Receiver | channel : "C", bufferSize : 2, bufferStart : 3,
    greatestSeqNoRcvd : 2, sender : "Alice", msgsRcvd : ("0" "1"), rcvBuffer :
    ("2" EOF), rcvCheck : (true true), rcvEOF : true, EOFPos : 1 >
--->
< "Bob" : Receiver | (channel : "C", sender : "Alice"), bufferSize : 2,
    bufferStart : (2 + 3), greatestSeqNoRcvd : (2 + 2), msgsRcvd : (("0" "1")
    "2" EOF), rcvBuffer : n 2 mts, rcvCheck : n 2 false, rcvEOF : true, EOFPos
    : 1 >
*********** equation
(built-in equation for symbol _+_)
2 + 3
--->
5
*********** equation
(built-in equation for symbol _+_)
2 + 2
--->
4
*********** equation
eq n N:Int mts = if N:Int <= 0 then (nil).StringList else mts n N:Int - 1 mts
    fi .
N:Int --> 2
n 2 mts
--->
if 2 <= 0 then (nil).StringList else mts n 2 - 1 mts fi
*********** equation
(built-in equation for symbol _<=_)
2 <= 0
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then (nil).StringList else mts n 2 - 1 mts fi
--->
mts n 2 - 1 mts
*********** equation
(built-in equation for symbol _-_)
2 - 1
--->
1
*********** equation
eq n N:Int mts = if N:Int <= 0 then (nil).StringList else mts n N:Int - 1 mts
    fi .
N:Int --> 1
n 1 mts
--->
if 1 <= 0 then (nil).StringList else mts n 1 - 1 mts fi
*********** equation
(built-in equation for symbol _<=_)
1 <= 0
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then (nil).StringList else mts n 1 - 1 mts fi
--->
mts n 1 - 1 mts
*********** equation
(built-in equation for symbol _-_)
1 - 1
--->
0
*********** equation
eq n N:Int mts = if N:Int <= 0 then (nil).StringList else mts n N:Int - 1 mts
    fi .
N:Int --> 0
n 0 mts
--->
if 0 <= 0 then (nil).StringList else mts n 0 - 1 mts fi
*********** equation
(built-in equation for symbol _<=_)
0 <= 0
--->
true
*********** equation
(built-in equation for symbol if_then_else_fi)
if true then (nil).StringList else mts n 0 - 1 mts fi
--->
(nil).StringList
*********** equation
eq n N:Int false = if N:Int <= 0 then (nil).BoolList else false n N:Int - 1
    false fi .
N:Int --> 2
n 2 false
--->
if 2 <= 0 then (nil).BoolList else false n 2 - 1 false fi
*********** equation
(built-in equation for symbol _<=_)
2 <= 0
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then (nil).BoolList else false n 2 - 1 false fi
--->
false n 2 - 1 false
*********** equation
(built-in equation for symbol _-_)
2 - 1
--->
1
*********** equation
eq n N:Int false = if N:Int <= 0 then (nil).BoolList else false n N:Int - 1
    false fi .
N:Int --> 1
n 1 false
--->
if 1 <= 0 then (nil).BoolList else false n 1 - 1 false fi
*********** equation
(built-in equation for symbol _<=_)
1 <= 0
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then (nil).BoolList else false n 1 - 1 false fi
--->
false n 1 - 1 false
*********** equation
(built-in equation for symbol _-_)
1 - 1
--->
0
*********** equation
eq n N:Int false = if N:Int <= 0 then (nil).BoolList else false n N:Int - 1
    false fi .
N:Int --> 0
n 0 false
--->
if 0 <= 0 then (nil).BoolList else false n 0 - 1 false fi
*********** equation
(built-in equation for symbol _<=_)
0 <= 0
--->
true
*********** equation
(built-in equation for symbol if_then_else_fi)
if true then (nil).BoolList else false n 0 - 1 false fi
--->
(nil).BoolList
*********** trial #40
crl < O : V:Channel | Atts:AttributeSet, msgs : ML, count : N > => (ML[random(
    N) rem size(ML)]) < O : V:Channel | Atts:AttributeSet, msgs : pop(ML,
    random(N) rem size(ML)), count : (N + 1) > if size(ML) > 0 = true [label
    convey-msg] .
O --> "C"
V:Channel --> Channel
Atts:AttributeSet --> (none).AttributeSet
ML --> Mnil
N --> 9
*********** solving condition fragment
size(ML) > 0 = true
*********** equation
eq size(T) = if T == Mnil then 0 else 1 + size(tail(T)) fi .
T --> Mnil
size(Mnil)
--->
if Mnil == Mnil then 0 else 1 + size(tail(Mnil)) fi
*********** equation
(built-in equation for symbol _==_)
Mnil == Mnil
--->
true
*********** equation
(built-in equation for symbol if_then_else_fi)
if true then 0 else 1 + size(tail(Mnil)) fi
--->
0
*********** equation
(built-in equation for symbol _>_)
0 > 0
--->
false
*********** failure for condition fragment
size(ML) > 0 = true
*********** failure #40
*********** trial #41
crl < O : V:Sender | Atts:AttributeSet, sendBuffer : ML, numWordsInBuffer : N',
    finishSend : B, bufferSize : N0, actionCount : I0 > < O' : V2:Channel |
    Atts2:AttributeSet, msgs : ML0, count : N > => < O : V:Sender |
    Atts:AttributeSet, sendBuffer : Mnil, numWordsInBuffer : 0, finishSend : B,
    bufferSize : N0, actionCount : (I0 + 1) > < O' : V2:Channel |
    Atts2:AttributeSet, msgs : (ML0 ++ ML), count : (N + 1) > if B and size(ML)
    > 0 or N' == N0 = true [label sendCurrentMsgs] .
O --> "Alice"
V:Sender --> Sender
Atts:AttributeSet --> msgsToSend : nil, currentSeqNo : 5, receiver : "Bob",
    ackBuffer : (false false), channel : "C", bufferStart : 4
ML --> msg mts withSeqNo 5 from "Alice" to "Bob"
N' --> 1
B --> true
N0 --> 2
I0 --> 8
O' --> "C"
V2:Channel --> Channel
Atts2:AttributeSet --> (none).AttributeSet
ML0 --> Mnil
N --> 9
*********** solving condition fragment
B and size(ML) > 0 or N' == N0 = true
*********** equation
eq size(T) = if T == Mnil then 0 else 1 + size(tail(T)) fi .
T --> msg mts withSeqNo 5 from "Alice" to "Bob"
size(msg mts withSeqNo 5 from "Alice" to "Bob")
--->
if msg mts withSeqNo 5 from "Alice" to "Bob" == Mnil then 0 else 1 + size(tail(
    msg mts withSeqNo 5 from "Alice" to "Bob")) fi
*********** equation
(built-in equation for symbol _==_)
msg mts withSeqNo 5 from "Alice" to "Bob" == Mnil
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then 0 else 1 + size(tail(msg mts withSeqNo 5 from "Alice" to "Bob"))
    fi
--->
1 + size(tail(msg mts withSeqNo 5 from "Alice" to "Bob"))
*********** equation
eq tail(H ++ T) = T .
H --> msg mts withSeqNo 5 from "Alice" to "Bob"
T --> Mnil
tail(msg mts withSeqNo 5 from "Alice" to "Bob")
--->
Mnil
*********** equation
eq size(T) = if T == Mnil then 0 else 1 + size(tail(T)) fi .
T --> Mnil
size(Mnil)
--->
if Mnil == Mnil then 0 else 1 + size(tail(Mnil)) fi
*********** equation
(built-in equation for symbol _==_)
Mnil == Mnil
--->
true
*********** equation
(built-in equation for symbol if_then_else_fi)
if true then 0 else 1 + size(tail(Mnil)) fi
--->
0
*********** equation
(built-in equation for symbol _+_)
0 + 1
--->
1
*********** equation
(built-in equation for symbol _>_)
1 > 0
--->
true
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> true
true and true
--->
true
*********** equation
(built-in equation for symbol _==_)
1 == 2
--->
false
*********** equation
eq A:Bool or B = A:Bool and B xor A:Bool xor B .
A:Bool --> false
B --> true
true or false
--->
false and true xor false xor true
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> false
true and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> true
true xor false
--->
true
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> true
true xor false
--->
true
*********** success for condition fragment
B and size(ML) > 0 or N' == N0 = true
O --> "Alice"
V:Sender --> Sender
Atts:AttributeSet --> msgsToSend : nil, currentSeqNo : 5, receiver : "Bob",
    ackBuffer : (false false), channel : "C", bufferStart : 4
ML --> msg mts withSeqNo 5 from "Alice" to "Bob"
N' --> 1
B --> true
N0 --> 2
I0 --> 8
O' --> "C"
V2:Channel --> Channel
Atts2:AttributeSet --> (none).AttributeSet
ML0 --> Mnil
N --> 9
*********** success #41
*********** rule
crl < O : V:Sender | Atts:AttributeSet, sendBuffer : ML, numWordsInBuffer : N',
    finishSend : B, bufferSize : N0, actionCount : I0 > < O' : V2:Channel |
    Atts2:AttributeSet, msgs : ML0, count : N > => < O : V:Sender |
    Atts:AttributeSet, sendBuffer : Mnil, numWordsInBuffer : 0, finishSend : B,
    bufferSize : N0, actionCount : (I0 + 1) > < O' : V2:Channel |
    Atts2:AttributeSet, msgs : (ML0 ++ ML), count : (N + 1) > if B and size(ML)
    > 0 or N' == N0 = true [label sendCurrentMsgs] .
O --> "Alice"
V:Sender --> Sender
Atts:AttributeSet --> msgsToSend : nil, currentSeqNo : 5, receiver : "Bob",
    ackBuffer : (false false), channel : "C", bufferStart : 4
ML --> msg mts withSeqNo 5 from "Alice" to "Bob"
N' --> 1
B --> true
N0 --> 2
I0 --> 8
O' --> "C"
V2:Channel --> Channel
Atts2:AttributeSet --> (none).AttributeSet
ML0 --> Mnil
N --> 9
< "Alice" : Sender | msgsToSend : nil, sendBuffer : msg mts withSeqNo 5 from
    "Alice" to "Bob", currentSeqNo : 5, receiver : "Bob", ackBuffer : (false
    false), numWordsInBuffer : 1, finishSend : true, channel : "C", bufferSize
    : 2, bufferStart : 4, actionCount : 8 > < "Bob" : Receiver | channel : "C",
    bufferSize : 2, bufferStart : 5, greatestSeqNoRcvd : 4, sender : "Alice",
    msgsRcvd : ("0" "1" "2" EOF), rcvBuffer : (mts mts), rcvCheck : (false
    false), rcvEOF : true, EOFPos : 1 > < "C" : Channel | msgs : Mnil, count :
    9 > (msg ack withSeqNo 3 from "Bob" to "Alice") msg ack withSeqNo 4 from
    "Bob" to "Alice"
--->
(< "Bob" : Receiver | channel : "C", bufferSize : 2, bufferStart : 5,
    greatestSeqNoRcvd : 4, sender : "Alice", msgsRcvd : ("0" "1" "2" EOF),
    rcvBuffer : (mts mts), rcvCheck : (false false), rcvEOF : true, EOFPos : 1
    > (msg ack withSeqNo 3 from "Bob" to "Alice") msg ack withSeqNo 4 from
    "Bob" to "Alice") < "Alice" : Sender | (msgsToSend : nil, currentSeqNo : 5,
    receiver : "Bob", ackBuffer : (false false), channel : "C", bufferStart :
    4), sendBuffer : Mnil, numWordsInBuffer : 0, finishSend : true, bufferSize
    : 2, actionCount : (8 + 1) > < "C" : Channel | none, msgs : (Mnil ++ msg
    mts withSeqNo 5 from "Alice" to "Bob"), count : (9 + 1) >
*********** equation
(built-in equation for symbol _+_)
1 + 8
--->
9
*********** equation
(built-in equation for symbol _+_)
1 + 9
--->
10
*********** trial #42
crl < O : V:Sender | Atts:AttributeSet, msgsToSend : nil, sendBuffer : ML,
    currentSeqNo : N', receiver : O', ackBuffer : A:[BoolList],
    numWordsInBuffer : N, finishSend : B, bufferSize : N0, bufferStart : I,
    actionCount : I0 > => < O : V:Sender | Atts:AttributeSet, msgsToSend : nil,
    sendBuffer : (ML ++ msg mts withSeqNo s N' from O to O'), currentSeqNo : s
    N', receiver : O', ackBuffer : n N0 false, numWordsInBuffer : s N,
    finishSend : true, bufferSize : N0, bufferStart : (I + 1), actionCount : (
    I0 + 1) > if not B and N < N0 = true [label load_dummy_word] .
O --> "Alice"
V:Sender --> Sender
Atts:AttributeSet --> channel : "C"
ML --> Mnil
N' --> 5
O' --> "Bob"
A:[BoolList] --> false false
N --> 0
B --> true
N0 --> 2
I --> 4
I0 --> 9
*********** solving condition fragment
not B and N < N0 = true
*********** equation
eq not A:Bool = true xor A:Bool .
A:Bool --> true
not true
--->
true xor true
*********** equation
eq A:Bool xor A:Bool = false .
A:Bool --> true
true xor true
--->
false
*********** equation
(built-in equation for symbol _<_)
0 < 2
--->
true
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> false
true and false
--->
false
*********** failure for condition fragment
not B and N < N0 = true
*********** failure #42
*********** trial #43
crl < O : V:Receiver | Atts:AttributeSet, msgsRcvd : (SL S0) > => < O :
    V:Receiver | Atts:AttributeSet, msgsRcvd : SL > if S0 == mts = true [label
    rmEmptyString] .
O --> "Bob"
V:Receiver --> Receiver
Atts:AttributeSet --> channel : "C", bufferSize : 2, bufferStart : 5,
    greatestSeqNoRcvd : 4, sender : "Alice", rcvBuffer : (mts mts), rcvCheck :
    (false false), rcvEOF : true, EOFPos : 1
SL --> "0" "1" "2"
S0 --> EOF
*********** solving condition fragment
S0 == mts = true
*********** equation
(built-in equation for symbol _==_)
EOF == mts
--->
false
*********** failure for condition fragment
S0 == mts = true
*********** failure #43
*********** trial #44
crl < O : V:Receiver | Atts:AttributeSet, bufferSize : N0, bufferStart : I0,
    greatestSeqNoRcvd : N, msgsRcvd : SL, rcvBuffer : SL0, rcvCheck : BL,
    rcvEOF : B0, EOFPos : N1 > => < O : V:Receiver | Atts:AttributeSet,
    bufferSize : N0, bufferStart : (N0 + I0), greatestSeqNoRcvd : (N + N0),
    msgsRcvd : (SL SL0), rcvBuffer : n N0 mts, rcvCheck : n N0 false, rcvEOF :
    B0, EOFPos : N1 > if allTrue(BL) or B0 and lastConsecutiveTrue(BL) >= N1 =
    true [label loadWordsFromBuffer] .
O --> "Bob"
V:Receiver --> Receiver
Atts:AttributeSet --> channel : "C", sender : "Alice"
N0 --> 2
I0 --> 5
N --> 4
SL --> "0" "1" "2" EOF
SL0 --> mts mts
BL --> false false
B0 --> true
N1 --> 1
*********** solving condition fragment
allTrue(BL) or B0 and lastConsecutiveTrue(BL) >= N1 = true
*********** equation
eq allTrue(B BL) = allTrue(BL) and allTrue(B) .
B --> false
BL --> false
allTrue(false false)
--->
allTrue(false) and allTrue(false)
*********** equation
eq allTrue(B) = B .
B --> false
allTrue(false)
--->
false
*********** equation
eq allTrue(B) = B .
B --> false
allTrue(false)
--->
false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq lastConsecutiveTrue(BL) = if BL == (nil).BoolList or head(BL) == false then
    -1 else 1 + lastConsecutiveTrue(tail(BL)) fi .
BL --> false false
lastConsecutiveTrue(false false)
--->
if false false == (nil).BoolList or head(false false) == false then -1 else 1 +
    lastConsecutiveTrue(tail(false false)) fi
*********** equation
(built-in equation for symbol _==_)
false false == (nil).BoolList
--->
false
*********** equation
eq head(E:Bool L:BoolList) = E:Bool .
E:Bool --> false
L:BoolList --> false
head(false false)
--->
false
*********** equation
(built-in equation for symbol _==_)
false == false
--->
true
*********** equation
eq A:Bool or B = A:Bool and B xor A:Bool xor B .
A:Bool --> false
B --> true
true or false
--->
false and true xor false xor true
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> false
true and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> true
true xor false
--->
true
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> true
true xor false
--->
true
*********** equation
(built-in equation for symbol if_then_else_fi)
if true then -1 else 1 + lastConsecutiveTrue(tail(false false)) fi
--->
-1
*********** equation
(built-in equation for symbol _>=_)
-1 >= 1
--->
false
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> false
true and false
--->
false
*********** equation
eq A:Bool or B = A:Bool and B xor A:Bool xor B .
A:Bool --> false
B --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** failure for condition fragment
allTrue(BL) or B0 and lastConsecutiveTrue(BL) >= N1 = true
*********** failure #44
*********** trial #45
crl < O : V:Channel | Atts:AttributeSet, msgs : ML, count : N > => (ML[random(
    N) rem size(ML)]) < O : V:Channel | Atts:AttributeSet, msgs : pop(ML,
    random(N) rem size(ML)), count : (N + 1) > if size(ML) > 0 = true [label
    convey-msg] .
O --> "C"
V:Channel --> Channel
Atts:AttributeSet --> (none).AttributeSet
ML --> msg mts withSeqNo 5 from "Alice" to "Bob"
N --> 10
*********** solving condition fragment
size(ML) > 0 = true
*********** equation
eq size(T) = if T == Mnil then 0 else 1 + size(tail(T)) fi .
T --> msg mts withSeqNo 5 from "Alice" to "Bob"
size(msg mts withSeqNo 5 from "Alice" to "Bob")
--->
if msg mts withSeqNo 5 from "Alice" to "Bob" == Mnil then 0 else 1 + size(tail(
    msg mts withSeqNo 5 from "Alice" to "Bob")) fi
*********** equation
(built-in equation for symbol _==_)
msg mts withSeqNo 5 from "Alice" to "Bob" == Mnil
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then 0 else 1 + size(tail(msg mts withSeqNo 5 from "Alice" to "Bob"))
    fi
--->
1 + size(tail(msg mts withSeqNo 5 from "Alice" to "Bob"))
*********** equation
eq tail(H ++ T) = T .
H --> msg mts withSeqNo 5 from "Alice" to "Bob"
T --> Mnil
tail(msg mts withSeqNo 5 from "Alice" to "Bob")
--->
Mnil
*********** equation
eq size(T) = if T == Mnil then 0 else 1 + size(tail(T)) fi .
T --> Mnil
size(Mnil)
--->
if Mnil == Mnil then 0 else 1 + size(tail(Mnil)) fi
*********** equation
(built-in equation for symbol _==_)
Mnil == Mnil
--->
true
*********** equation
(built-in equation for symbol if_then_else_fi)
if true then 0 else 1 + size(tail(Mnil)) fi
--->
0
*********** equation
(built-in equation for symbol _+_)
0 + 1
--->
1
*********** equation
(built-in equation for symbol _>_)
1 > 0
--->
true
*********** success for condition fragment
size(ML) > 0 = true
O --> "C"
V:Channel --> Channel
Atts:AttributeSet --> (none).AttributeSet
ML --> msg mts withSeqNo 5 from "Alice" to "Bob"
N --> 10
*********** success #45
*********** rule
crl < O : V:Channel | Atts:AttributeSet, msgs : ML, count : N > => (ML[random(
    N) rem size(ML)]) < O : V:Channel | Atts:AttributeSet, msgs : pop(ML,
    random(N) rem size(ML)), count : (N + 1) > if size(ML) > 0 = true [label
    convey-msg] .
O --> "C"
V:Channel --> Channel
Atts:AttributeSet --> (none).AttributeSet
ML --> msg mts withSeqNo 5 from "Alice" to "Bob"
N --> 10
< "C" : Channel | msgs : msg mts withSeqNo 5 from "Alice" to "Bob", count : 10
    >
--->
(msg mts withSeqNo 5 from "Alice" to "Bob"[random(10) rem 1]) < "C" : Channel |
    none, msgs : pop(msg mts withSeqNo 5 from "Alice" to "Bob",random(10) rem
    1), count : (10 + 1) >
*********** equation
(built-in equation for symbol random)
random(10)
--->
2774094101
*********** equation
(built-in equation for symbol _rem_)
2774094101 rem 1
--->
0
*********** equation
eq T[N] = if N <= 0 then if N == 0 then head(T) else Mnil fi else tail(T)[N -
    1] fi .
T --> msg mts withSeqNo 5 from "Alice" to "Bob"
N --> 0
msg mts withSeqNo 5 from "Alice" to "Bob"[0]
--->
if 0 <= 0 then if 0 == 0 then head(msg mts withSeqNo 5 from "Alice" to "Bob")
    else Mnil fi else tail(msg mts withSeqNo 5 from "Alice" to "Bob")[0 - 1] fi
*********** equation
(built-in equation for symbol _<=_)
0 <= 0
--->
true
*********** equation
(built-in equation for symbol if_then_else_fi)
if true then if 0 == 0 then head(msg mts withSeqNo 5 from "Alice" to "Bob")
    else Mnil fi else tail(msg mts withSeqNo 5 from "Alice" to "Bob")[0 - 1] fi
--->
if 0 == 0 then head(msg mts withSeqNo 5 from "Alice" to "Bob") else Mnil fi
*********** equation
(built-in equation for symbol _==_)
0 == 0
--->
true
*********** equation
(built-in equation for symbol if_then_else_fi)
if true then head(msg mts withSeqNo 5 from "Alice" to "Bob") else Mnil fi
--->
head(msg mts withSeqNo 5 from "Alice" to "Bob")
*********** equation
eq head(H ++ T) = H .
H --> msg mts withSeqNo 5 from "Alice" to "Bob"
T --> Mnil
head(msg mts withSeqNo 5 from "Alice" to "Bob")
--->
msg mts withSeqNo 5 from "Alice" to "Bob"
*********** equation
eq pop(T,N) = if N == 0 then tail(T) else head(T) ++ pop(tail(T),N - 1) fi .
T --> msg mts withSeqNo 5 from "Alice" to "Bob"
N --> 0
pop(msg mts withSeqNo 5 from "Alice" to "Bob",0)
--->
if 0 == 0 then tail(msg mts withSeqNo 5 from "Alice" to "Bob") else head(msg
    mts withSeqNo 5 from "Alice" to "Bob") ++ pop(tail(msg mts withSeqNo 5 from
    "Alice" to "Bob"),0 - 1) fi
*********** equation
(built-in equation for symbol _==_)
0 == 0
--->
true
*********** equation
(built-in equation for symbol if_then_else_fi)
if true then tail(msg mts withSeqNo 5 from "Alice" to "Bob") else head(msg mts
    withSeqNo 5 from "Alice" to "Bob") ++ pop(tail(msg mts withSeqNo 5 from
    "Alice" to "Bob"),0 - 1) fi
--->
tail(msg mts withSeqNo 5 from "Alice" to "Bob")
*********** equation
eq tail(H ++ T) = T .
H --> msg mts withSeqNo 5 from "Alice" to "Bob"
T --> Mnil
tail(msg mts withSeqNo 5 from "Alice" to "Bob")
--->
Mnil
*********** equation
(built-in equation for symbol _+_)
1 + 10
--->
11
*********** trial #46
crl < O : V:Sender | Atts:AttributeSet, ackBuffer : AckL, bufferStart : N0 >
    msg ack withSeqNo N from O' to O => < O : V:Sender | Atts:AttributeSet,
    ackBuffer : assign(AckL,0 : N - N0,true), bufferStart : N0 > if s N > N0 =
    true [label rcvNewAck] .
O --> "Alice"
V:Sender --> Sender
Atts:AttributeSet --> msgsToSend : nil, sendBuffer : Mnil, currentSeqNo : 5,
    receiver : "Bob", numWordsInBuffer : 0, finishSend : true, channel : "C",
    bufferSize : 2, actionCount : 9
AckL --> false false
N0 --> 4
N --> 3
O' --> "Bob"
*********** solving condition fragment
s N > N0 = true
*********** equation
(built-in equation for symbol _>_)
4 > 4
--->
false
*********** failure for condition fragment
s N > N0 = true
*********** failure #46
*********** trial #47
crl < O : V:Sender | Atts:AttributeSet, ackBuffer : AckL, bufferStart : N0 >
    msg ack withSeqNo N from O' to O => < O : V:Sender | Atts:AttributeSet,
    ackBuffer : assign(AckL,0 : N - N0,true), bufferStart : N0 > if s N > N0 =
    true [label rcvNewAck] .
O --> "Alice"
V:Sender --> Sender
Atts:AttributeSet --> msgsToSend : nil, sendBuffer : Mnil, currentSeqNo : 5,
    receiver : "Bob", numWordsInBuffer : 0, finishSend : true, channel : "C",
    bufferSize : 2, actionCount : 9
AckL --> false false
N0 --> 4
N --> 4
O' --> "Bob"
*********** solving condition fragment
s N > N0 = true
*********** equation
(built-in equation for symbol _>_)
5 > 4
--->
true
*********** success for condition fragment
s N > N0 = true
O --> "Alice"
V:Sender --> Sender
Atts:AttributeSet --> msgsToSend : nil, sendBuffer : Mnil, currentSeqNo : 5,
    receiver : "Bob", numWordsInBuffer : 0, finishSend : true, channel : "C",
    bufferSize : 2, actionCount : 9
AckL --> false false
N0 --> 4
N --> 4
O' --> "Bob"
*********** success #47
*********** rule
crl < O : V:Sender | Atts:AttributeSet, ackBuffer : AckL, bufferStart : N0 >
    msg ack withSeqNo N from O' to O => < O : V:Sender | Atts:AttributeSet,
    ackBuffer : assign(AckL,0 : N - N0,true), bufferStart : N0 > if s N > N0 =
    true [label rcvNewAck] .
O --> "Alice"
V:Sender --> Sender
Atts:AttributeSet --> msgsToSend : nil, sendBuffer : Mnil, currentSeqNo : 5,
    receiver : "Bob", numWordsInBuffer : 0, finishSend : true, channel : "C",
    bufferSize : 2, actionCount : 9
AckL --> false false
N0 --> 4
N --> 4
O' --> "Bob"
< "Alice" : Sender | msgsToSend : nil, sendBuffer : Mnil, currentSeqNo : 5,
    receiver : "Bob", ackBuffer : (false false), numWordsInBuffer : 0,
    finishSend : true, channel : "C", bufferSize : 2, bufferStart : 4,
    actionCount : 9 > < "Bob" : Receiver | channel : "C", bufferSize : 2,
    bufferStart : 5, greatestSeqNoRcvd : 4, sender : "Alice", msgsRcvd : ("0"
    "1" "2" EOF), rcvBuffer : (mts mts), rcvCheck : (false false), rcvEOF :
    true, EOFPos : 1 > < "C" : Channel | msgs : Mnil, count : 11 > (msg mts
    withSeqNo 5 from "Alice" to "Bob") (msg ack withSeqNo 3 from "Bob" to
    "Alice") msg ack withSeqNo 4 from "Bob" to "Alice"
--->
(< "Bob" : Receiver | channel : "C", bufferSize : 2, bufferStart : 5,
    greatestSeqNoRcvd : 4, sender : "Alice", msgsRcvd : ("0" "1" "2" EOF),
    rcvBuffer : (mts mts), rcvCheck : (false false), rcvEOF : true, EOFPos : 1
    > < "C" : Channel | msgs : Mnil, count : 11 > (msg mts withSeqNo 5 from
    "Alice" to "Bob") msg ack withSeqNo 3 from "Bob" to "Alice") < "Alice" :
    Sender | (msgsToSend : nil, sendBuffer : Mnil, currentSeqNo : 5, receiver :
    "Bob", numWordsInBuffer : 0, finishSend : true, channel : "C", bufferSize :
    2, actionCount : 9), ackBuffer : assign(false false,0 : 4 - 4,true),
    bufferStart : 4 >
*********** equation
(built-in equation for symbol _-_)
4 - 4
--->
0
*********** equation
eq assign(BL,N:Int : N':Int,B) = if (N:Int > N':Int or N':Int >= size(BL)) or
    N:Int < 0 then BL else if N:Int == 0 then B assign(tail(BL),0 : N':Int - 1,
    B) else head(BL) assign(tail(BL),N:Int - 1 : N':Int - 1,B) fi fi .
BL --> false false
N:Int --> 0
N':Int --> 0
B --> true
assign(false false,0 : 0,true)
--->
if (0 > 0 or 0 >= size(false false)) or 0 < 0 then false false else if 0 == 0
    then true assign(tail(false false),0 : 0 - 1,true) else head(false false)
    assign(tail(false false),0 - 1 : 0 - 1,true) fi fi
*********** equation
(built-in equation for symbol _>_)
0 > 0
--->
false
*********** equation
eq size(L:BoolList) = $size(L:BoolList, 0) .
L:BoolList --> false false
size(false false)
--->
$size(false false, 0)
*********** equation
eq $size(E:Bool L:BoolList, C:Nat) = $size(L:BoolList, C:Nat + 1) .
E:Bool --> false
L:BoolList --> false
C:Nat --> 0
$size(false false, 0)
--->
$size(false, 0 + 1)
*********** equation
(built-in equation for symbol _+_)
0 + 1
--->
1
*********** equation
eq $size(E:Bool L:BoolList, C:Nat) = $size(L:BoolList, C:Nat + 1) .
E:Bool --> false
L:BoolList --> (nil).BoolList
C:Nat --> 1
$size(false, 1)
--->
$size((nil).BoolList, 1 + 1)
*********** equation
(built-in equation for symbol _+_)
1 + 1
--->
2
*********** equation
eq $size((nil).BoolList, C:Nat) = C:Nat .
C:Nat --> 2
$size((nil).BoolList, 2)
--->
2
*********** equation
(built-in equation for symbol _>=_)
0 >= 2
--->
false
*********** equation
eq A:Bool or B = A:Bool and B xor A:Bool xor B .
A:Bool --> false
B --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
(built-in equation for symbol _<_)
0 < 0
--->
false
*********** equation
eq A:Bool or B = A:Bool and B xor A:Bool xor B .
A:Bool --> false
B --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then false false else if 0 == 0 then true assign(tail(false false),0 :
    0 - 1,true) else head(false false) assign(tail(false false),0 - 1 : 0 - 1,
    true) fi fi
--->
if 0 == 0 then true assign(tail(false false),0 : 0 - 1,true) else head(false
    false) assign(tail(false false),0 - 1 : 0 - 1,true) fi
*********** equation
(built-in equation for symbol _==_)
0 == 0
--->
true
*********** equation
(built-in equation for symbol if_then_else_fi)
if true then true assign(tail(false false),0 : 0 - 1,true) else head(false
    false) assign(tail(false false),0 - 1 : 0 - 1,true) fi
--->
true assign(tail(false false),0 : 0 - 1,true)
*********** equation
eq tail(E:Bool L:BoolList) = L:BoolList .
E:Bool --> false
L:BoolList --> false
tail(false false)
--->
false
*********** equation
(built-in equation for symbol _-_)
0 - 1
--->
-1
*********** equation
eq assign(BL,N:Int : N':Int,B) = if (N:Int > N':Int or N':Int >= size(BL)) or
    N:Int < 0 then BL else if N:Int == 0 then B assign(tail(BL),0 : N':Int - 1,
    B) else head(BL) assign(tail(BL),N:Int - 1 : N':Int - 1,B) fi fi .
BL --> false
N:Int --> 0
N':Int --> -1
B --> true
assign(false,0 : -1,true)
--->
if (0 > -1 or -1 >= size(false)) or 0 < 0 then false else if 0 == 0 then true
    assign(tail(false),0 : -1 - 1,true) else head(false) assign(tail(false),0 -
    1 : -1 - 1,true) fi fi
*********** equation
(built-in equation for symbol _>_)
0 > -1
--->
true
*********** equation
eq size(L:BoolList) = $size(L:BoolList, 0) .
L:BoolList --> false
size(false)
--->
$size(false, 0)
*********** equation
eq $size(E:Bool L:BoolList, C:Nat) = $size(L:BoolList, C:Nat + 1) .
E:Bool --> false
L:BoolList --> (nil).BoolList
C:Nat --> 0
$size(false, 0)
--->
$size((nil).BoolList, 0 + 1)
*********** equation
(built-in equation for symbol _+_)
0 + 1
--->
1
*********** equation
eq $size((nil).BoolList, C:Nat) = C:Nat .
C:Nat --> 1
$size((nil).BoolList, 1)
--->
1
*********** equation
(built-in equation for symbol _>=_)
-1 >= 1
--->
false
*********** equation
eq A:Bool or B = A:Bool and B xor A:Bool xor B .
A:Bool --> false
B --> true
true or false
--->
false and true xor false xor true
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> false
true and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> true
true xor false
--->
true
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> true
true xor false
--->
true
*********** equation
(built-in equation for symbol _<_)
0 < 0
--->
false
*********** equation
eq A:Bool or B = A:Bool and B xor A:Bool xor B .
A:Bool --> false
B --> true
true or false
--->
false and true xor false xor true
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> false
true and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> true
true xor false
--->
true
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> true
true xor false
--->
true
*********** equation
(built-in equation for symbol if_then_else_fi)
if true then false else if 0 == 0 then true assign(tail(false),0 : -1 - 1,true)
    else head(false) assign(tail(false),0 - 1 : -1 - 1,true) fi fi
--->
false
*********** trial #48
crl < O : V:Sender | Atts:AttributeSet, msgsToSend : nil, sendBuffer : ML,
    currentSeqNo : N', receiver : O', ackBuffer : A:[BoolList],
    numWordsInBuffer : N, finishSend : B, bufferSize : N0, bufferStart : I,
    actionCount : I0 > => < O : V:Sender | Atts:AttributeSet, msgsToSend : nil,
    sendBuffer : (ML ++ msg mts withSeqNo s N' from O to O'), currentSeqNo : s
    N', receiver : O', ackBuffer : n N0 false, numWordsInBuffer : s N,
    finishSend : true, bufferSize : N0, bufferStart : (I + 1), actionCount : (
    I0 + 1) > if not B and N < N0 = true [label load_dummy_word] .
O --> "Alice"
V:Sender --> Sender
Atts:AttributeSet --> channel : "C"
ML --> Mnil
N' --> 5
O' --> "Bob"
A:[BoolList] --> true false
N --> 0
B --> true
N0 --> 2
I --> 4
I0 --> 9
*********** solving condition fragment
not B and N < N0 = true
*********** equation
eq not A:Bool = true xor A:Bool .
A:Bool --> true
not true
--->
true xor true
*********** equation
eq A:Bool xor A:Bool = false .
A:Bool --> true
true xor true
--->
false
*********** equation
(built-in equation for symbol _<_)
0 < 2
--->
true
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> false
true and false
--->
false
*********** failure for condition fragment
not B and N < N0 = true
*********** failure #48
*********** trial #49
crl < O : V:Channel | Atts:AttributeSet, msgs : ML, count : N > => (ML[random(
    N) rem size(ML)]) < O : V:Channel | Atts:AttributeSet, msgs : pop(ML,
    random(N) rem size(ML)), count : (N + 1) > if size(ML) > 0 = true [label
    convey-msg] .
O --> "C"
V:Channel --> Channel
Atts:AttributeSet --> (none).AttributeSet
ML --> Mnil
N --> 11
*********** solving condition fragment
size(ML) > 0 = true
*********** equation
eq size(T) = if T == Mnil then 0 else 1 + size(tail(T)) fi .
T --> Mnil
size(Mnil)
--->
if Mnil == Mnil then 0 else 1 + size(tail(Mnil)) fi
*********** equation
(built-in equation for symbol _==_)
Mnil == Mnil
--->
true
*********** equation
(built-in equation for symbol if_then_else_fi)
if true then 0 else 1 + size(tail(Mnil)) fi
--->
0
*********** equation
(built-in equation for symbol _>_)
0 > 0
--->
false
*********** failure for condition fragment
size(ML) > 0 = true
*********** failure #49
*********** trial #50
crl < O : V:Sender | Atts:AttributeSet, currentSeqNo : N' > msg ack withSeqNo N
    from O' to O => < O : V:Sender | Atts:AttributeSet, currentSeqNo : N' > if
    s N < N' = true [label rcvTooOldAck] .
O --> "Alice"
V:Sender --> Sender
Atts:AttributeSet --> msgsToSend : nil, sendBuffer : Mnil, receiver : "Bob",
    ackBuffer : (true false), numWordsInBuffer : 0, finishSend : true, channel
    : "C", bufferSize : 2, bufferStart : 4, actionCount : 9
N' --> 5
N --> 3
O' --> "Bob"
*********** solving condition fragment
s N < N' = true
*********** equation
(built-in equation for symbol _<_)
4 < 5
--->
true
*********** success for condition fragment
s N < N' = true
O --> "Alice"
V:Sender --> Sender
Atts:AttributeSet --> msgsToSend : nil, sendBuffer : Mnil, receiver : "Bob",
    ackBuffer : (true false), numWordsInBuffer : 0, finishSend : true, channel
    : "C", bufferSize : 2, bufferStart : 4, actionCount : 9
N' --> 5
N --> 3
O' --> "Bob"
*********** success #50
*********** rule
crl < O : V:Sender | Atts:AttributeSet, currentSeqNo : N' > msg ack withSeqNo N
    from O' to O => < O : V:Sender | Atts:AttributeSet, currentSeqNo : N' > if
    s N < N' = true [label rcvTooOldAck] .
O --> "Alice"
V:Sender --> Sender
Atts:AttributeSet --> msgsToSend : nil, sendBuffer : Mnil, receiver : "Bob",
    ackBuffer : (true false), numWordsInBuffer : 0, finishSend : true, channel
    : "C", bufferSize : 2, bufferStart : 4, actionCount : 9
N' --> 5
N --> 3
O' --> "Bob"
< "Alice" : Sender | msgsToSend : nil, sendBuffer : Mnil, currentSeqNo : 5,
    receiver : "Bob", ackBuffer : (true false), numWordsInBuffer : 0,
    finishSend : true, channel : "C", bufferSize : 2, bufferStart : 4,
    actionCount : 9 > < "Bob" : Receiver | channel : "C", bufferSize : 2,
    bufferStart : 5, greatestSeqNoRcvd : 4, sender : "Alice", msgsRcvd : ("0"
    "1" "2" EOF), rcvBuffer : (mts mts), rcvCheck : (false false), rcvEOF :
    true, EOFPos : 1 > < "C" : Channel | msgs : Mnil, count : 11 > (msg mts
    withSeqNo 5 from "Alice" to "Bob") msg ack withSeqNo 3 from "Bob" to
    "Alice"
--->
(< "Bob" : Receiver | channel : "C", bufferSize : 2, bufferStart : 5,
    greatestSeqNoRcvd : 4, sender : "Alice", msgsRcvd : ("0" "1" "2" EOF),
    rcvBuffer : (mts mts), rcvCheck : (false false), rcvEOF : true, EOFPos : 1
    > < "C" : Channel | msgs : Mnil, count : 11 > msg mts withSeqNo 5 from
    "Alice" to "Bob") < "Alice" : Sender | (msgsToSend : nil, sendBuffer :
    Mnil, receiver : "Bob", ackBuffer : (true false), numWordsInBuffer : 0,
    finishSend : true, channel : "C", bufferSize : 2, bufferStart : 4,
    actionCount : 9), currentSeqNo : 5 >
*********** trial #51
crl < O : V:Sender | Atts:AttributeSet, msgsToSend : nil, sendBuffer : ML,
    currentSeqNo : N', receiver : O', ackBuffer : A:[BoolList],
    numWordsInBuffer : N, finishSend : B, bufferSize : N0, bufferStart : I,
    actionCount : I0 > => < O : V:Sender | Atts:AttributeSet, msgsToSend : nil,
    sendBuffer : (ML ++ msg mts withSeqNo s N' from O to O'), currentSeqNo : s
    N', receiver : O', ackBuffer : n N0 false, numWordsInBuffer : s N,
    finishSend : true, bufferSize : N0, bufferStart : (I + 1), actionCount : (
    I0 + 1) > if not B and N < N0 = true [label load_dummy_word] .
O --> "Alice"
V:Sender --> Sender
Atts:AttributeSet --> channel : "C"
ML --> Mnil
N' --> 5
O' --> "Bob"
A:[BoolList] --> true false
N --> 0
B --> true
N0 --> 2
I --> 4
I0 --> 9
*********** solving condition fragment
not B and N < N0 = true
*********** equation
eq not A:Bool = true xor A:Bool .
A:Bool --> true
not true
--->
true xor true
*********** equation
eq A:Bool xor A:Bool = false .
A:Bool --> true
true xor true
--->
false
*********** equation
(built-in equation for symbol _<_)
0 < 2
--->
true
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> false
true and false
--->
false
*********** failure for condition fragment
not B and N < N0 = true
*********** failure #51
*********** trial #52
crl < O : V:Receiver | Atts:AttributeSet, greatestSeqNoRcvd : N' > msg S
    withSeqNo N from O' to O => < O : V:Receiver | Atts:AttributeSet,
    greatestSeqNoRcvd : N' > msg ack withSeqNo N' from O to O' if N <= N' =
    true [label rcvOldPacket] .
O --> "Bob"
V:Receiver --> Receiver
Atts:AttributeSet --> channel : "C", bufferSize : 2, bufferStart : 5, sender :
    "Alice", msgsRcvd : ("0" "1" "2" EOF), rcvBuffer : (mts mts), rcvCheck : (
    false false), rcvEOF : true, EOFPos : 1
N' --> 4
S --> mts
N --> 5
O' --> "Alice"
*********** solving condition fragment
N <= N' = true
*********** equation
(built-in equation for symbol _<=_)
5 <= 4
--->
false
*********** failure for condition fragment
N <= N' = true
*********** failure #52
*********** trial #53
crl < O : V:Receiver | Atts:AttributeSet, bufferSize : N1, bufferStart : N0,
    greatestSeqNoRcvd : N', rcvBuffer : SL, rcvCheck : BL > < O2 : V2:Channel |
    Atts2:AttributeSet, count : N2 > msg S withSeqNo N from O' to O => (< O2 :
    V2:Channel | Atts2:AttributeSet, count : s N2 > msg ack withSeqNo N0 +
    lastConsecutiveTrue(assign(BL,N - N0,true)) from O to O') < O : V:Receiver
    | Atts:AttributeSet, bufferSize : N1, bufferStart : N0, greatestSeqNoRcvd :
    N', rcvBuffer : assign(SL,N - N0,S), rcvCheck : assign(BL,N - N0,true) > if
    N >= N' = true /\ N < N0 + N1 = true /\ not S == EOF = true [label
    rcvNewPacket] .
O --> "Bob"
V:Receiver --> Receiver
Atts:AttributeSet --> channel : "C", sender : "Alice", msgsRcvd : ("0" "1" "2"
    EOF), rcvEOF : true, EOFPos : 1
N1 --> 2
N0 --> 5
N' --> 4
SL --> mts mts
BL --> false false
O2 --> "C"
V2:Channel --> Channel
Atts2:AttributeSet --> msgs : Mnil
N2 --> 11
S --> mts
N --> 5
O' --> "Alice"
*********** solving condition fragment
N >= N' = true
*********** equation
(built-in equation for symbol _>=_)
5 >= 4
--->
true
*********** success for condition fragment
N >= N' = true
O --> "Bob"
V:Receiver --> Receiver
Atts:AttributeSet --> channel : "C", sender : "Alice", msgsRcvd : ("0" "1" "2"
    EOF), rcvEOF : true, EOFPos : 1
N1 --> 2
N0 --> 5
N' --> 4
SL --> mts mts
BL --> false false
O2 --> "C"
V2:Channel --> Channel
Atts2:AttributeSet --> msgs : Mnil
N2 --> 11
S --> mts
N --> 5
O' --> "Alice"
*********** solving condition fragment
N < N0 + N1 = true
*********** equation
(built-in equation for symbol _+_)
2 + 5
--->
7
*********** equation
(built-in equation for symbol _<_)
5 < 7
--->
true
*********** success for condition fragment
N < N0 + N1 = true
O --> "Bob"
V:Receiver --> Receiver
Atts:AttributeSet --> channel : "C", sender : "Alice", msgsRcvd : ("0" "1" "2"
    EOF), rcvEOF : true, EOFPos : 1
N1 --> 2
N0 --> 5
N' --> 4
SL --> mts mts
BL --> false false
O2 --> "C"
V2:Channel --> Channel
Atts2:AttributeSet --> msgs : Mnil
N2 --> 11
S --> mts
N --> 5
O' --> "Alice"
*********** solving condition fragment
not S == EOF = true
*********** equation
(built-in equation for symbol _==_)
mts == EOF
--->
false
*********** equation
eq not A:Bool = true xor A:Bool .
A:Bool --> false
not false
--->
true xor false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> true
true xor false
--->
true
*********** success for condition fragment
not S == EOF = true
O --> "Bob"
V:Receiver --> Receiver
Atts:AttributeSet --> channel : "C", sender : "Alice", msgsRcvd : ("0" "1" "2"
    EOF), rcvEOF : true, EOFPos : 1
N1 --> 2
N0 --> 5
N' --> 4
SL --> mts mts
BL --> false false
O2 --> "C"
V2:Channel --> Channel
Atts2:AttributeSet --> msgs : Mnil
N2 --> 11
S --> mts
N --> 5
O' --> "Alice"
*********** success #53
*********** rule
crl < O : V:Receiver | Atts:AttributeSet, bufferSize : N1, bufferStart : N0,
    greatestSeqNoRcvd : N', rcvBuffer : SL, rcvCheck : BL > < O2 : V2:Channel |
    Atts2:AttributeSet, count : N2 > msg S withSeqNo N from O' to O => (< O2 :
    V2:Channel | Atts2:AttributeSet, count : s N2 > msg ack withSeqNo N0 +
    lastConsecutiveTrue(assign(BL,N - N0,true)) from O to O') < O : V:Receiver
    | Atts:AttributeSet, bufferSize : N1, bufferStart : N0, greatestSeqNoRcvd :
    N', rcvBuffer : assign(SL,N - N0,S), rcvCheck : assign(BL,N - N0,true) > if
    N >= N' = true /\ N < N0 + N1 = true /\ not S == EOF = true [label
    rcvNewPacket] .
O --> "Bob"
V:Receiver --> Receiver
Atts:AttributeSet --> channel : "C", sender : "Alice", msgsRcvd : ("0" "1" "2"
    EOF), rcvEOF : true, EOFPos : 1
N1 --> 2
N0 --> 5
N' --> 4
SL --> mts mts
BL --> false false
O2 --> "C"
V2:Channel --> Channel
Atts2:AttributeSet --> msgs : Mnil
N2 --> 11
S --> mts
N --> 5
O' --> "Alice"
< "Alice" : Sender | msgsToSend : nil, sendBuffer : Mnil, currentSeqNo : 5,
    receiver : "Bob", ackBuffer : (true false), numWordsInBuffer : 0,
    finishSend : true, channel : "C", bufferSize : 2, bufferStart : 4,
    actionCount : 9 > < "Bob" : Receiver | channel : "C", bufferSize : 2,
    bufferStart : 5, greatestSeqNoRcvd : 4, sender : "Alice", msgsRcvd : ("0"
    "1" "2" EOF), rcvBuffer : (mts mts), rcvCheck : (false false), rcvEOF :
    true, EOFPos : 1 > < "C" : Channel | msgs : Mnil, count : 11 > msg mts
    withSeqNo 5 from "Alice" to "Bob"
--->
< "Alice" : Sender | msgsToSend : nil, sendBuffer : Mnil, currentSeqNo : 5,
    receiver : "Bob", ackBuffer : (true false), numWordsInBuffer : 0,
    finishSend : true, channel : "C", bufferSize : 2, bufferStart : 4,
    actionCount : 9 > (< "C" : Channel | msgs : Mnil, count : s 11 > msg ack
    withSeqNo 5 + lastConsecutiveTrue(assign(false false,5 - 5,true)) from
    "Bob" to "Alice") < "Bob" : Receiver | (channel : "C", sender : "Alice",
    msgsRcvd : ("0" "1" "2" EOF), rcvEOF : true, EOFPos : 1), bufferSize : 2,
    bufferStart : 5, greatestSeqNoRcvd : 4, rcvBuffer : assign(mts mts,5 - 5,
    mts), rcvCheck : assign(false false,5 - 5,true) >
*********** equation
(built-in equation for symbol _-_)
5 - 5
--->
0
*********** equation
eq assign(BL,N:Int,B) = if N:Int < 0 or N:Int >= size(BL) then BL else if N:Int
    == 0 then B tail(BL) else head(BL) assign(tail(BL),N:Int - 1,B) fi fi .
BL --> false false
N:Int --> 0
B --> true
assign(false false,0,true)
--->
if 0 < 0 or 0 >= size(false false) then false false else if 0 == 0 then true
    tail(false false) else head(false false) assign(tail(false false),0 - 1,
    true) fi fi
*********** equation
(built-in equation for symbol _<_)
0 < 0
--->
false
*********** equation
eq size(L:BoolList) = $size(L:BoolList, 0) .
L:BoolList --> false false
size(false false)
--->
$size(false false, 0)
*********** equation
eq $size(E:Bool L:BoolList, C:Nat) = $size(L:BoolList, C:Nat + 1) .
E:Bool --> false
L:BoolList --> false
C:Nat --> 0
$size(false false, 0)
--->
$size(false, 0 + 1)
*********** equation
(built-in equation for symbol _+_)
0 + 1
--->
1
*********** equation
eq $size(E:Bool L:BoolList, C:Nat) = $size(L:BoolList, C:Nat + 1) .
E:Bool --> false
L:BoolList --> (nil).BoolList
C:Nat --> 1
$size(false, 1)
--->
$size((nil).BoolList, 1 + 1)
*********** equation
(built-in equation for symbol _+_)
1 + 1
--->
2
*********** equation
eq $size((nil).BoolList, C:Nat) = C:Nat .
C:Nat --> 2
$size((nil).BoolList, 2)
--->
2
*********** equation
(built-in equation for symbol _>=_)
0 >= 2
--->
false
*********** equation
eq A:Bool or B = A:Bool and B xor A:Bool xor B .
A:Bool --> false
B --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then false false else if 0 == 0 then true tail(false false) else head(
    false false) assign(tail(false false),0 - 1,true) fi fi
--->
if 0 == 0 then true tail(false false) else head(false false) assign(tail(false
    false),0 - 1,true) fi
*********** equation
(built-in equation for symbol _==_)
0 == 0
--->
true
*********** equation
(built-in equation for symbol if_then_else_fi)
if true then true tail(false false) else head(false false) assign(tail(false
    false),0 - 1,true) fi
--->
true tail(false false)
*********** equation
eq tail(E:Bool L:BoolList) = L:BoolList .
E:Bool --> false
L:BoolList --> false
tail(false false)
--->
false
*********** equation
eq lastConsecutiveTrue(BL) = if BL == (nil).BoolList or head(BL) == false then
    -1 else 1 + lastConsecutiveTrue(tail(BL)) fi .
BL --> true false
lastConsecutiveTrue(true false)
--->
if true false == (nil).BoolList or head(true false) == false then -1 else 1 +
    lastConsecutiveTrue(tail(true false)) fi
*********** equation
(built-in equation for symbol _==_)
true false == (nil).BoolList
--->
false
*********** equation
eq head(E:Bool L:BoolList) = E:Bool .
E:Bool --> true
L:BoolList --> false
head(true false)
--->
true
*********** equation
(built-in equation for symbol _==_)
true == false
--->
false
*********** equation
eq A:Bool or B = A:Bool and B xor A:Bool xor B .
A:Bool --> false
B --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then -1 else 1 + lastConsecutiveTrue(tail(true false)) fi
--->
1 + lastConsecutiveTrue(tail(true false))
*********** equation
eq tail(E:Bool L:BoolList) = L:BoolList .
E:Bool --> true
L:BoolList --> false
tail(true false)
--->
false
*********** equation
eq lastConsecutiveTrue(BL) = if BL == (nil).BoolList or head(BL) == false then
    -1 else 1 + lastConsecutiveTrue(tail(BL)) fi .
BL --> false
lastConsecutiveTrue(false)
--->
if false == (nil).BoolList or head(false) == false then -1 else 1 +
    lastConsecutiveTrue(tail(false)) fi
*********** equation
(built-in equation for symbol _==_)
false == (nil).BoolList
--->
false
*********** equation
eq head(E:Bool L:BoolList) = E:Bool .
E:Bool --> false
L:BoolList --> (nil).BoolList
head(false)
--->
false
*********** equation
(built-in equation for symbol _==_)
false == false
--->
true
*********** equation
eq A:Bool or B = A:Bool and B xor A:Bool xor B .
A:Bool --> false
B --> true
true or false
--->
false and true xor false xor true
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> false
true and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> true
true xor false
--->
true
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> true
true xor false
--->
true
*********** equation
(built-in equation for symbol if_then_else_fi)
if true then -1 else 1 + lastConsecutiveTrue(tail(false)) fi
--->
-1
*********** equation
(built-in equation for symbol _+_)
1 + -1
--->
0
*********** equation
(built-in equation for symbol _+_)
0 + 5
--->
5
*********** equation
eq assign(SL,N:Int,S) = if N:Int < 0 or N:Int >= size(SL) then SL else if N:Int
    == 0 then S tail(SL) else head(SL) assign(tail(SL),N:Int - 1,S) fi fi .
SL --> mts mts
N:Int --> 0
S --> mts
assign(mts mts,0,mts)
--->
if 0 < 0 or 0 >= size(mts mts) then mts mts else if 0 == 0 then mts tail(mts
    mts) else head(mts mts) assign(tail(mts mts),0 - 1,mts) fi fi
*********** equation
(built-in equation for symbol _<_)
0 < 0
--->
false
*********** equation
eq size(L:StringList) = $size(L:StringList, 0) .
L:StringList --> mts mts
size(mts mts)
--->
$size(mts mts, 0)
*********** equation
eq $size(E:String L:StringList, C:Nat) = $size(L:StringList, C:Nat + 1) .
E:String --> mts
L:StringList --> mts
C:Nat --> 0
$size(mts mts, 0)
--->
$size(mts, 0 + 1)
*********** equation
(built-in equation for symbol _+_)
0 + 1
--->
1
*********** equation
eq $size(E:String L:StringList, C:Nat) = $size(L:StringList, C:Nat + 1) .
E:String --> mts
L:StringList --> (nil).StringList
C:Nat --> 1
$size(mts, 1)
--->
$size((nil).StringList, 1 + 1)
*********** equation
(built-in equation for symbol _+_)
1 + 1
--->
2
*********** equation
eq $size((nil).StringList, C:Nat) = C:Nat .
C:Nat --> 2
$size((nil).StringList, 2)
--->
2
*********** equation
(built-in equation for symbol _>=_)
0 >= 2
--->
false
*********** equation
eq A:Bool or B = A:Bool and B xor A:Bool xor B .
A:Bool --> false
B --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then mts mts else if 0 == 0 then mts tail(mts mts) else head(mts mts)
    assign(tail(mts mts),0 - 1,mts) fi fi
--->
if 0 == 0 then mts tail(mts mts) else head(mts mts) assign(tail(mts mts),0 - 1,
    mts) fi
*********** equation
(built-in equation for symbol _==_)
0 == 0
--->
true
*********** equation
(built-in equation for symbol if_then_else_fi)
if true then mts tail(mts mts) else head(mts mts) assign(tail(mts mts),0 - 1,
    mts) fi
--->
mts tail(mts mts)
*********** equation
eq tail(E:String L:StringList) = L:StringList .
E:String --> mts
L:StringList --> mts
tail(mts mts)
--->
mts
*********** trial #54
crl < O : V:Receiver | Atts:AttributeSet, bufferSize : N0, bufferStart : I0,
    greatestSeqNoRcvd : N, msgsRcvd : SL, rcvBuffer : SL0, rcvCheck : BL,
    rcvEOF : B0, EOFPos : N1 > => < O : V:Receiver | Atts:AttributeSet,
    bufferSize : N0, bufferStart : (N0 + I0), greatestSeqNoRcvd : (N + N0),
    msgsRcvd : (SL SL0), rcvBuffer : n N0 mts, rcvCheck : n N0 false, rcvEOF :
    B0, EOFPos : N1 > if allTrue(BL) or B0 and lastConsecutiveTrue(BL) >= N1 =
    true [label loadWordsFromBuffer] .
O --> "Bob"
V:Receiver --> Receiver
Atts:AttributeSet --> channel : "C", sender : "Alice"
N0 --> 2
I0 --> 5
N --> 4
SL --> "0" "1" "2" EOF
SL0 --> mts mts
BL --> true false
B0 --> true
N1 --> 1
*********** solving condition fragment
allTrue(BL) or B0 and lastConsecutiveTrue(BL) >= N1 = true
*********** equation
eq allTrue(B BL) = allTrue(BL) and allTrue(B) .
B --> true
BL --> false
allTrue(true false)
--->
allTrue(false) and allTrue(true)
*********** equation
eq allTrue(B) = B .
B --> false
allTrue(false)
--->
false
*********** equation
eq allTrue(B) = B .
B --> true
allTrue(true)
--->
true
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> false
true and false
--->
false
*********** equation
eq lastConsecutiveTrue(BL) = if BL == (nil).BoolList or head(BL) == false then
    -1 else 1 + lastConsecutiveTrue(tail(BL)) fi .
BL --> true false
lastConsecutiveTrue(true false)
--->
if true false == (nil).BoolList or head(true false) == false then -1 else 1 +
    lastConsecutiveTrue(tail(true false)) fi
*********** equation
(built-in equation for symbol _==_)
true false == (nil).BoolList
--->
false
*********** equation
eq head(E:Bool L:BoolList) = E:Bool .
E:Bool --> true
L:BoolList --> false
head(true false)
--->
true
*********** equation
(built-in equation for symbol _==_)
true == false
--->
false
*********** equation
eq A:Bool or B = A:Bool and B xor A:Bool xor B .
A:Bool --> false
B --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then -1 else 1 + lastConsecutiveTrue(tail(true false)) fi
--->
1 + lastConsecutiveTrue(tail(true false))
*********** equation
eq tail(E:Bool L:BoolList) = L:BoolList .
E:Bool --> true
L:BoolList --> false
tail(true false)
--->
false
*********** equation
eq lastConsecutiveTrue(BL) = if BL == (nil).BoolList or head(BL) == false then
    -1 else 1 + lastConsecutiveTrue(tail(BL)) fi .
BL --> false
lastConsecutiveTrue(false)
--->
if false == (nil).BoolList or head(false) == false then -1 else 1 +
    lastConsecutiveTrue(tail(false)) fi
*********** equation
(built-in equation for symbol _==_)
false == (nil).BoolList
--->
false
*********** equation
eq head(E:Bool L:BoolList) = E:Bool .
E:Bool --> false
L:BoolList --> (nil).BoolList
head(false)
--->
false
*********** equation
(built-in equation for symbol _==_)
false == false
--->
true
*********** equation
eq A:Bool or B = A:Bool and B xor A:Bool xor B .
A:Bool --> false
B --> true
true or false
--->
false and true xor false xor true
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> false
true and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> true
true xor false
--->
true
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> true
true xor false
--->
true
*********** equation
(built-in equation for symbol if_then_else_fi)
if true then -1 else 1 + lastConsecutiveTrue(tail(false)) fi
--->
-1
*********** equation
(built-in equation for symbol _+_)
1 + -1
--->
0
*********** equation
(built-in equation for symbol _>=_)
0 >= 1
--->
false
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> false
true and false
--->
false
*********** equation
eq A:Bool or B = A:Bool and B xor A:Bool xor B .
A:Bool --> false
B --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** failure for condition fragment
allTrue(BL) or B0 and lastConsecutiveTrue(BL) >= N1 = true
*********** failure #54
*********** trial #55
crl < O : V:Receiver | Atts:AttributeSet, msgsRcvd : (SL S0) > => < O :
    V:Receiver | Atts:AttributeSet, msgsRcvd : SL > if S0 == mts = true [label
    rmEmptyString] .
O --> "Bob"
V:Receiver --> Receiver
Atts:AttributeSet --> channel : "C", bufferSize : 2, bufferStart : 5,
    greatestSeqNoRcvd : 4, sender : "Alice", rcvBuffer : (mts mts), rcvCheck :
    (true false), rcvEOF : true, EOFPos : 1
SL --> "0" "1" "2"
S0 --> EOF
*********** solving condition fragment
S0 == mts = true
*********** equation
(built-in equation for symbol _==_)
EOF == mts
--->
false
*********** failure for condition fragment
S0 == mts = true
*********** failure #55
*********** trial #56
crl < O : V:Channel | Atts:AttributeSet, msgs : ML, count : N > => (ML[random(
    N) rem size(ML)]) < O : V:Channel | Atts:AttributeSet, msgs : pop(ML,
    random(N) rem size(ML)), count : (N + 1) > if size(ML) > 0 = true [label
    convey-msg] .
O --> "C"
V:Channel --> Channel
Atts:AttributeSet --> (none).AttributeSet
ML --> Mnil
N --> 12
*********** solving condition fragment
size(ML) > 0 = true
*********** equation
eq size(T) = if T == Mnil then 0 else 1 + size(tail(T)) fi .
T --> Mnil
size(Mnil)
--->
if Mnil == Mnil then 0 else 1 + size(tail(Mnil)) fi
*********** equation
(built-in equation for symbol _==_)
Mnil == Mnil
--->
true
*********** equation
(built-in equation for symbol if_then_else_fi)
if true then 0 else 1 + size(tail(Mnil)) fi
--->
0
*********** equation
(built-in equation for symbol _>_)
0 > 0
--->
false
*********** failure for condition fragment
size(ML) > 0 = true
*********** failure #56
*********** trial #57
crl < O : V:Sender | Atts:AttributeSet, sendBuffer : ML, numWordsInBuffer : N',
    finishSend : B, bufferSize : N0, actionCount : I0 > < O' : V2:Channel |
    Atts2:AttributeSet, msgs : ML0, count : N > => < O : V:Sender |
    Atts:AttributeSet, sendBuffer : Mnil, numWordsInBuffer : 0, finishSend : B,
    bufferSize : N0, actionCount : (I0 + 1) > < O' : V2:Channel |
    Atts2:AttributeSet, msgs : (ML0 ++ ML), count : (N + 1) > if B and size(ML)
    > 0 or N' == N0 = true [label sendCurrentMsgs] .
O --> "Alice"
V:Sender --> Sender
Atts:AttributeSet --> msgsToSend : nil, currentSeqNo : 5, receiver : "Bob",
    ackBuffer : (true false), channel : "C", bufferStart : 4
ML --> Mnil
N' --> 0
B --> true
N0 --> 2
I0 --> 9
O' --> "C"
V2:Channel --> Channel
Atts2:AttributeSet --> (none).AttributeSet
ML0 --> Mnil
N --> 12
*********** solving condition fragment
B and size(ML) > 0 or N' == N0 = true
*********** equation
eq size(T) = if T == Mnil then 0 else 1 + size(tail(T)) fi .
T --> Mnil
size(Mnil)
--->
if Mnil == Mnil then 0 else 1 + size(tail(Mnil)) fi
*********** equation
(built-in equation for symbol _==_)
Mnil == Mnil
--->
true
*********** equation
(built-in equation for symbol if_then_else_fi)
if true then 0 else 1 + size(tail(Mnil)) fi
--->
0
*********** equation
(built-in equation for symbol _>_)
0 > 0
--->
false
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> false
true and false
--->
false
*********** equation
(built-in equation for symbol _==_)
0 == 2
--->
false
*********** equation
eq A:Bool or B = A:Bool and B xor A:Bool xor B .
A:Bool --> false
B --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** failure for condition fragment
B and size(ML) > 0 or N' == N0 = true
*********** failure #57
*********** trial #58
crl < O : V:Sender | Atts:AttributeSet, ackBuffer : AckL, bufferStart : N0 >
    msg ack withSeqNo N from O' to O => < O : V:Sender | Atts:AttributeSet,
    ackBuffer : assign(AckL,0 : N - N0,true), bufferStart : N0 > if s N > N0 =
    true [label rcvNewAck] .
O --> "Alice"
V:Sender --> Sender
Atts:AttributeSet --> msgsToSend : nil, sendBuffer : Mnil, currentSeqNo : 5,
    receiver : "Bob", numWordsInBuffer : 0, finishSend : true, channel : "C",
    bufferSize : 2, actionCount : 9
AckL --> true false
N0 --> 4
N --> 5
O' --> "Bob"
*********** solving condition fragment
s N > N0 = true
*********** equation
(built-in equation for symbol _>_)
6 > 4
--->
true
*********** success for condition fragment
s N > N0 = true
O --> "Alice"
V:Sender --> Sender
Atts:AttributeSet --> msgsToSend : nil, sendBuffer : Mnil, currentSeqNo : 5,
    receiver : "Bob", numWordsInBuffer : 0, finishSend : true, channel : "C",
    bufferSize : 2, actionCount : 9
AckL --> true false
N0 --> 4
N --> 5
O' --> "Bob"
*********** success #58
*********** rule
crl < O : V:Sender | Atts:AttributeSet, ackBuffer : AckL, bufferStart : N0 >
    msg ack withSeqNo N from O' to O => < O : V:Sender | Atts:AttributeSet,
    ackBuffer : assign(AckL,0 : N - N0,true), bufferStart : N0 > if s N > N0 =
    true [label rcvNewAck] .
O --> "Alice"
V:Sender --> Sender
Atts:AttributeSet --> msgsToSend : nil, sendBuffer : Mnil, currentSeqNo : 5,
    receiver : "Bob", numWordsInBuffer : 0, finishSend : true, channel : "C",
    bufferSize : 2, actionCount : 9
AckL --> true false
N0 --> 4
N --> 5
O' --> "Bob"
< "Alice" : Sender | msgsToSend : nil, sendBuffer : Mnil, currentSeqNo : 5,
    receiver : "Bob", ackBuffer : (true false), numWordsInBuffer : 0,
    finishSend : true, channel : "C", bufferSize : 2, bufferStart : 4,
    actionCount : 9 > < "Bob" : Receiver | channel : "C", bufferSize : 2,
    bufferStart : 5, greatestSeqNoRcvd : 4, sender : "Alice", msgsRcvd : ("0"
    "1" "2" EOF), rcvBuffer : (mts mts), rcvCheck : (true false), rcvEOF :
    true, EOFPos : 1 > < "C" : Channel | msgs : Mnil, count : 12 > msg ack
    withSeqNo 5 from "Bob" to "Alice"
--->
(< "Bob" : Receiver | channel : "C", bufferSize : 2, bufferStart : 5,
    greatestSeqNoRcvd : 4, sender : "Alice", msgsRcvd : ("0" "1" "2" EOF),
    rcvBuffer : (mts mts), rcvCheck : (true false), rcvEOF : true, EOFPos : 1 >
    < "C" : Channel | msgs : Mnil, count : 12 >) < "Alice" : Sender | (
    msgsToSend : nil, sendBuffer : Mnil, currentSeqNo : 5, receiver : "Bob",
    numWordsInBuffer : 0, finishSend : true, channel : "C", bufferSize : 2,
    actionCount : 9), ackBuffer : assign(true false,0 : 5 - 4,true),
    bufferStart : 4 >
*********** equation
(built-in equation for symbol _-_)
5 - 4
--->
1
*********** equation
eq assign(BL,N:Int : N':Int,B) = if (N:Int > N':Int or N':Int >= size(BL)) or
    N:Int < 0 then BL else if N:Int == 0 then B assign(tail(BL),0 : N':Int - 1,
    B) else head(BL) assign(tail(BL),N:Int - 1 : N':Int - 1,B) fi fi .
BL --> true false
N:Int --> 0
N':Int --> 1
B --> true
assign(true false,0 : 1,true)
--->
if (0 > 1 or 1 >= size(true false)) or 0 < 0 then true false else if 0 == 0
    then true assign(tail(true false),0 : 1 - 1,true) else head(true false)
    assign(tail(true false),0 - 1 : 1 - 1,true) fi fi
*********** equation
(built-in equation for symbol _>_)
0 > 1
--->
false
*********** equation
eq size(L:BoolList) = $size(L:BoolList, 0) .
L:BoolList --> true false
size(true false)
--->
$size(true false, 0)
*********** equation
eq $size(E:Bool L:BoolList, C:Nat) = $size(L:BoolList, C:Nat + 1) .
E:Bool --> true
L:BoolList --> false
C:Nat --> 0
$size(true false, 0)
--->
$size(false, 0 + 1)
*********** equation
(built-in equation for symbol _+_)
0 + 1
--->
1
*********** equation
eq $size(E:Bool L:BoolList, C:Nat) = $size(L:BoolList, C:Nat + 1) .
E:Bool --> false
L:BoolList --> (nil).BoolList
C:Nat --> 1
$size(false, 1)
--->
$size((nil).BoolList, 1 + 1)
*********** equation
(built-in equation for symbol _+_)
1 + 1
--->
2
*********** equation
eq $size((nil).BoolList, C:Nat) = C:Nat .
C:Nat --> 2
$size((nil).BoolList, 2)
--->
2
*********** equation
(built-in equation for symbol _>=_)
1 >= 2
--->
false
*********** equation
eq A:Bool or B = A:Bool and B xor A:Bool xor B .
A:Bool --> false
B --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
(built-in equation for symbol _<_)
0 < 0
--->
false
*********** equation
eq A:Bool or B = A:Bool and B xor A:Bool xor B .
A:Bool --> false
B --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then true false else if 0 == 0 then true assign(tail(true false),0 : 1
    - 1,true) else head(true false) assign(tail(true false),0 - 1 : 1 - 1,true)
    fi fi
--->
if 0 == 0 then true assign(tail(true false),0 : 1 - 1,true) else head(true
    false) assign(tail(true false),0 - 1 : 1 - 1,true) fi
*********** equation
(built-in equation for symbol _==_)
0 == 0
--->
true
*********** equation
(built-in equation for symbol if_then_else_fi)
if true then true assign(tail(true false),0 : 1 - 1,true) else head(true false)
    assign(tail(true false),0 - 1 : 1 - 1,true) fi
--->
true assign(tail(true false),0 : 1 - 1,true)
*********** equation
eq tail(E:Bool L:BoolList) = L:BoolList .
E:Bool --> true
L:BoolList --> false
tail(true false)
--->
false
*********** equation
(built-in equation for symbol _-_)
1 - 1
--->
0
*********** equation
eq assign(BL,N:Int : N':Int,B) = if (N:Int > N':Int or N':Int >= size(BL)) or
    N:Int < 0 then BL else if N:Int == 0 then B assign(tail(BL),0 : N':Int - 1,
    B) else head(BL) assign(tail(BL),N:Int - 1 : N':Int - 1,B) fi fi .
BL --> false
N:Int --> 0
N':Int --> 0
B --> true
assign(false,0 : 0,true)
--->
if (0 > 0 or 0 >= size(false)) or 0 < 0 then false else if 0 == 0 then true
    assign(tail(false),0 : 0 - 1,true) else head(false) assign(tail(false),0 -
    1 : 0 - 1,true) fi fi
*********** equation
(built-in equation for symbol _>_)
0 > 0
--->
false
*********** equation
eq size(L:BoolList) = $size(L:BoolList, 0) .
L:BoolList --> false
size(false)
--->
$size(false, 0)
*********** equation
eq $size(E:Bool L:BoolList, C:Nat) = $size(L:BoolList, C:Nat + 1) .
E:Bool --> false
L:BoolList --> (nil).BoolList
C:Nat --> 0
$size(false, 0)
--->
$size((nil).BoolList, 0 + 1)
*********** equation
(built-in equation for symbol _+_)
0 + 1
--->
1
*********** equation
eq $size((nil).BoolList, C:Nat) = C:Nat .
C:Nat --> 1
$size((nil).BoolList, 1)
--->
1
*********** equation
(built-in equation for symbol _>=_)
0 >= 1
--->
false
*********** equation
eq A:Bool or B = A:Bool and B xor A:Bool xor B .
A:Bool --> false
B --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
(built-in equation for symbol _<_)
0 < 0
--->
false
*********** equation
eq A:Bool or B = A:Bool and B xor A:Bool xor B .
A:Bool --> false
B --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then false else if 0 == 0 then true assign(tail(false),0 : 0 - 1,true)
    else head(false) assign(tail(false),0 - 1 : 0 - 1,true) fi fi
--->
if 0 == 0 then true assign(tail(false),0 : 0 - 1,true) else head(false) assign(
    tail(false),0 - 1 : 0 - 1,true) fi
*********** equation
(built-in equation for symbol _==_)
0 == 0
--->
true
*********** equation
(built-in equation for symbol if_then_else_fi)
if true then true assign(tail(false),0 : 0 - 1,true) else head(false) assign(
    tail(false),0 - 1 : 0 - 1,true) fi
--->
true assign(tail(false),0 : 0 - 1,true)
*********** equation
eq tail(E:Bool L:BoolList) = L:BoolList .
E:Bool --> false
L:BoolList --> (nil).BoolList
tail(false)
--->
(nil).BoolList
*********** equation
(built-in equation for symbol _-_)
0 - 1
--->
-1
*********** equation
eq assign(BL,N:Int : N':Int,B) = if (N:Int > N':Int or N':Int >= size(BL)) or
    N:Int < 0 then BL else if N:Int == 0 then B assign(tail(BL),0 : N':Int - 1,
    B) else head(BL) assign(tail(BL),N:Int - 1 : N':Int - 1,B) fi fi .
BL --> (nil).BoolList
N:Int --> 0
N':Int --> -1
B --> true
assign(nil,0 : -1,true)
--->
if (0 > -1 or -1 >= size((nil).BoolList)) or 0 < 0 then (nil).BoolList else if
    0 == 0 then true assign(tail(nil),0 : -1 - 1,true) else head((
    nil).BoolList) assign(tail(nil),0 - 1 : -1 - 1,true) fi fi
*********** equation
(built-in equation for symbol _>_)
0 > -1
--->
true
*********** equation
eq size(L:BoolList) = $size(L:BoolList, 0) .
L:BoolList --> (nil).BoolList
size((nil).BoolList)
--->
$size((nil).BoolList, 0)
*********** equation
eq $size((nil).BoolList, C:Nat) = C:Nat .
C:Nat --> 0
$size((nil).BoolList, 0)
--->
0
*********** equation
(built-in equation for symbol _>=_)
-1 >= 0
--->
false
*********** equation
eq A:Bool or B = A:Bool and B xor A:Bool xor B .
A:Bool --> false
B --> true
true or false
--->
false and true xor false xor true
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> false
true and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> true
true xor false
--->
true
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> true
true xor false
--->
true
*********** equation
(built-in equation for symbol _<_)
0 < 0
--->
false
*********** equation
eq A:Bool or B = A:Bool and B xor A:Bool xor B .
A:Bool --> false
B --> true
true or false
--->
false and true xor false xor true
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> false
true and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> true
true xor false
--->
true
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> true
true xor false
--->
true
*********** equation
(built-in equation for symbol if_then_else_fi)
if true then (nil).BoolList else if 0 == 0 then true assign(tail(nil),0 : -1 -
    1,true) else head((nil).BoolList) assign(tail(nil),0 - 1 : -1 - 1,true) fi
    fi
--->
(nil).BoolList
*********** trial #59
crl < O : V:Sender | Atts:AttributeSet, msgsToSend : nil, sendBuffer : ML,
    currentSeqNo : N', receiver : O', ackBuffer : A:[BoolList],
    numWordsInBuffer : N, finishSend : B, bufferSize : N0, bufferStart : I,
    actionCount : I0 > => < O : V:Sender | Atts:AttributeSet, msgsToSend : nil,
    sendBuffer : (ML ++ msg mts withSeqNo s N' from O to O'), currentSeqNo : s
    N', receiver : O', ackBuffer : n N0 false, numWordsInBuffer : s N,
    finishSend : true, bufferSize : N0, bufferStart : (I + 1), actionCount : (
    I0 + 1) > if not B and N < N0 = true [label load_dummy_word] .
O --> "Alice"
V:Sender --> Sender
Atts:AttributeSet --> channel : "C"
ML --> Mnil
N' --> 5
O' --> "Bob"
A:[BoolList] --> true true
N --> 0
B --> true
N0 --> 2
I --> 4
I0 --> 9
*********** solving condition fragment
not B and N < N0 = true
*********** equation
eq not A:Bool = true xor A:Bool .
A:Bool --> true
not true
--->
true xor true
*********** equation
eq A:Bool xor A:Bool = false .
A:Bool --> true
true xor true
--->
false
*********** equation
(built-in equation for symbol _<_)
0 < 2
--->
true
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> false
true and false
--->
false
*********** failure for condition fragment
not B and N < N0 = true
*********** failure #59
*********** trial #60
crl < O : V:Sender | Atts:AttributeSet, sendBuffer : ML, numWordsInBuffer : N',
    finishSend : B, bufferSize : N0, actionCount : I0 > < O' : V2:Channel |
    Atts2:AttributeSet, msgs : ML0, count : N > => < O : V:Sender |
    Atts:AttributeSet, sendBuffer : Mnil, numWordsInBuffer : 0, finishSend : B,
    bufferSize : N0, actionCount : (I0 + 1) > < O' : V2:Channel |
    Atts2:AttributeSet, msgs : (ML0 ++ ML), count : (N + 1) > if B and size(ML)
    > 0 or N' == N0 = true [label sendCurrentMsgs] .
O --> "Alice"
V:Sender --> Sender
Atts:AttributeSet --> msgsToSend : nil, currentSeqNo : 5, receiver : "Bob",
    ackBuffer : (true true), channel : "C", bufferStart : 4
ML --> Mnil
N' --> 0
B --> true
N0 --> 2
I0 --> 9
O' --> "C"
V2:Channel --> Channel
Atts2:AttributeSet --> (none).AttributeSet
ML0 --> Mnil
N --> 12
*********** solving condition fragment
B and size(ML) > 0 or N' == N0 = true
*********** equation
eq size(T) = if T == Mnil then 0 else 1 + size(tail(T)) fi .
T --> Mnil
size(Mnil)
--->
if Mnil == Mnil then 0 else 1 + size(tail(Mnil)) fi
*********** equation
(built-in equation for symbol _==_)
Mnil == Mnil
--->
true
*********** equation
(built-in equation for symbol if_then_else_fi)
if true then 0 else 1 + size(tail(Mnil)) fi
--->
0
*********** equation
(built-in equation for symbol _>_)
0 > 0
--->
false
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> false
true and false
--->
false
*********** equation
(built-in equation for symbol _==_)
0 == 2
--->
false
*********** equation
eq A:Bool or B = A:Bool and B xor A:Bool xor B .
A:Bool --> false
B --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** failure for condition fragment
B and size(ML) > 0 or N' == N0 = true
*********** failure #60
rewrites: 1421 in 28ms cpu (28ms real) (50585 rewrites/second)
result Configuration: < "Alice" : Sender | msgsToSend : nil, sendBuffer : Mnil,
    currentSeqNo : 5, receiver : "Bob", ackBuffer : (true true),
    numWordsInBuffer : 0, finishSend : true, channel : "C", bufferSize : 2,
    bufferStart : 4, actionCount : 9 > < "Bob" : Receiver | channel : "C",
    bufferSize : 2, bufferStart : 5, greatestSeqNoRcvd : 4, sender : "Alice",
    msgsRcvd : ("0" "1" "2" EOF), rcvBuffer : (mts mts), rcvCheck : (true
    false), rcvEOF : true, EOFPos : 1 > < "C" : Channel | msgs : Mnil, count :
    12 >
Bye.
