omod SEQNO-UNORDERED is
    including MESSAGE-WRAPPER . --- msg wrapper and loss
    protecting RANDOM + STRING + NAT + BOOL + BOOL-LIST + STRING-LIST .
    sort Content . --- message content without sequence numbers
    subsort String < Content . --- "messages" are just strings
    subsort String < Oid .

    op ack : -> Content [ctor] . --- acknowledgment message
    --- sequence number wrapper:
    op _withSeqNo_ : Content Nat -> MsgContent [ctor] .

    sort MsgList .
    subsort Msg < MsgList .
    op Mnil : -> MsgList [ctor] .
    op _++_ : MsgList MsgList -> MsgList [ctor assoc id: Mnil] .
    op head : MsgList -> Msg .
    op tail : MsgList -> MsgList .
    op _[_] : MsgList Int -> Msg .
    op size : MsgList -> Nat .
    op pop(_,_) : MsgList Int -> MsgList .

    vars N N' : Nat . 
    var NZ : NzNat . 
    vars O O' O2 : Oid .
    vars S S0 S1 : String . 
    vars SL SL' : StringList .
    vars B B0 B1 : Bool .
    var BList : BoolList . 
    vars Ack Ack0 Ack1 : Bool . 
    var AckL : BoolList .
    vars M M0 M1 : Msg .
    vars ML ML0 : MsgList .
    var H : Msg .
    var T : MsgList .


    eq head(H ++ T) = H .
    eq tail(H ++ T) = T .
    eq tail(Mnil) = Mnil .
    eq head(Mnil) = Mnil .
    eq T [ N ] = if N <= 0 then if N == 0 then head(T) else Mnil fi else tail(T) [ N - 1 ] fi .
    eq size(T) = if T == Mnil then 0 else 1 + size(tail(T)) fi .

    eq pop(T , N) = if N == 0 then tail(T) else head(T) ++ (pop(tail(T), N - 1)) fi .

    class Channel | msgs : MsgList,
                    count : Nat .
        --- crl [msg-loss] : < O : Channel | msgs : M ++ ML , count : N > => < O : Channel | msgs : ML , count : N + 1 > if random(N) rem 100 == 0 .
        
        crl [convey-msg] : < O : Channel | msgs :  ML , count : N > => < O : Channel | msgs : pop( ML , random(size(ML)) rem (size(ML)) ) , count : N + 1 > ((ML) [ random(size(ML)) rem (size(ML)) ]) if size(ML) > 0 .


    class Sender | msgsToSend : StringList, sendBuffer : MsgList, currentSeqNo : Nat, receiver : Oid , ackBuffer : BoolList , numWordsInBuffer : Nat , finishSend : Bool , channel : Oid .


    rl [start] :
        < O : Sender | currentSeqNo : 0 >
        =>  
        < O : Sender | ackBuffer : true true , finishSend : false > .

    crl [load_word] : 
        < O : Sender | msgsToSend : S SL, sendBuffer : ML , numWordsInBuffer : N , currentSeqNo : N' , ackBuffer : AckL , finishSend : B , receiver : O' > 
        => 
        < O : Sender | msgsToSend : SL, sendBuffer : (msg (S withSeqNo s N') from O to O') ++ ML, numWordsInBuffer : s N , currentSeqNo : s N' , ackBuffer : false false > if ((N == 0 and allTrue(AckL)) or (N < 2 and N > 0)) and not B .

    crl [load_dummy_word] : 
        < O : Sender | msgsToSend : nil, sendBuffer : ML , numWordsInBuffer : N , currentSeqNo : N' , finishSend : B , receiver : O' > 
        => 
        < O : Sender | msgsToSend : nil, sendBuffer : ML ++ (msg (mts withSeqNo s N') from O to O' ) , numWordsInBuffer : s N , currentSeqNo : s N' , finishSend : true , ackBuffer : false false > if N < 2 and not B .

    crl [sendCurrentMsgs] :
        < O : Sender | sendBuffer : ML , numWordsInBuffer : N', finishSend : B > < O' : Channel | msgs : ML0 , count : N >
        =>  < O : Sender | sendBuffer : Mnil , numWordsInBuffer : 0 > < O' : Channel | msgs : (ML0 ++ ML) , count : 1 + N > if ((N' == 2)) .

    rl [receiveAck0] :
        (msg (ack withSeqNo N) from O' to O) < O : Sender | currentSeqNo : s N, ackBuffer : Ack0 Ack1 >
    => < O : Sender | ackBuffer : true Ack0 > .

    rl [receiveAck1] :
        (msg (ack withSeqNo s N) from O' to O) < O : Sender | currentSeqNo : s N, ackBuffer : Ack0 Ack1 >
    => < O : Sender | ackBuffer : true true > .

    crl [rcvTooOldAck] : 
        (msg (ack withSeqNo N) from O' to O) < O : Sender | currentSeqNo : N' >
    =>
        < O : Sender | > if s N < N' .

    
    
    class Receiver | greatestSeqNoRcvd : Nat,
                    sender : Oid,
                    msgsRcvd : StringList ,
                    rcvBuffer : StringList ,
                    rcvCheck : BoolList ,
                    channel : Oid .
    
        --- rl [sendAck] :
        ---     < O : Receiver | greatestSeqNoRcvd : NZ, sender : O' , sendAck : false >
        --- =>
        ---     < O : Receiver | sendAck : true > msg (ack withSeqNo NZ) from O to O' .

        crl [rcvNewPacket0WORevPacket1] :
            (msg (S withSeqNo s N) from O' to O) < O : Receiver | rcvBuffer : S0 S1, rcvCheck : B0 B1 , greatestSeqNoRcvd : N > < O2 : Channel | msgs : ML , count : N' >
        =>
            < O : Receiver | rcvBuffer : S S1 , rcvCheck :  true false > < O2 : Channel | msgs : ML ++ (msg (ack withSeqNo N) from O to O') , count : 1 + N' > if B1 == false and (random(7 * N) rem 2 == 0).

        crl [rcvNewPacket0AfterRevPacket1] :
            (msg (S withSeqNo s N) from O' to O) < O : Receiver | rcvBuffer : S0 S1, rcvCheck : B0 B1 , greatestSeqNoRcvd : N > < O2 : Channel | msgs : ML , count : N' >
        =>
            < O : Receiver | rcvBuffer : S S1 , rcvCheck :  true true  > < O2 : Channel | msgs : ML ++ (msg (ack withSeqNo N + 2) from O to O') , count : 1 + N' > if B1 == true .
        
        crl [rcvNewPacket1WORevPacket0] :
            (msg (S withSeqNo s s N) from O' to O) < O : Receiver | rcvBuffer : S0 S1, rcvCheck : B0 B1 , greatestSeqNoRcvd : N > < O2 : Channel | msgs : ML , count : N' >
        =>
            < O : Receiver | rcvBuffer : S0 S , rcvCheck :  false true > < O2 : Channel | msgs : ML ++ (msg (ack withSeqNo N) from O to O') , count : 1 + N' > if B0 == false .

        crl [rcvNewPacket1AfterRevPacket0] :
            (msg (S withSeqNo s s N) from O' to O) < O : Receiver | rcvBuffer : S0 S1, rcvCheck : B0 B1 , greatestSeqNoRcvd : N > < O2 : Channel | msgs : ML , count : N' >
        =>
            < O : Receiver | rcvBuffer : S0 S , rcvCheck :  true true > < O2 : Channel | msgs : ML ++ (msg (ack withSeqNo N + 2) from O to O') , count : 1 + N' > if B0 == true .

        crl [loadWordsFromBuffer] :
            < O : Receiver | rcvBuffer : S0 S1, msgsRcvd : SL , rcvCheck : BList , greatestSeqNoRcvd : N >
        => 
            < O : Receiver | rcvBuffer : mts mts , msgsRcvd :  SL S0 S1, rcvCheck : false false, greatestSeqNoRcvd : N + 2 > if allTrue(BList) .

        crl [rmEmptyString] : 
            < O : Receiver | msgsRcvd : SL S0 >
        =>
            < O : Receiver | msgsRcvd : SL > if S0 == mts .

        crl [rcvOldPacket] :
            (msg (S withSeqNo N) from O' to O) < O : Receiver | greatestSeqNoRcvd : N' >
        =>
            < O : Receiver | > msg (ack withSeqNo N') from O to O' if N <= N' .

endom